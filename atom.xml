<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kai&#39;s Blog</title>
  
  <subtitle>Kai&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-13T10:03:35.444Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AstorKai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>漫谈HTTPS</title>
    <link href="http://yoursite.com/2019/08/13/%E6%BC%AB%E8%B0%88HTTPS/"/>
    <id>http://yoursite.com/2019/08/13/漫谈HTTPS/</id>
    <published>2019-08-13T03:34:00.000Z</published>
    <updated>2019-08-13T10:03:35.444Z</updated>
    
    <content type="html"><![CDATA[<p>Hypertext Transfer Protocol Secure (HTTPS)是对于HTTP的拓展，用于解决在计算机通信过程中的安全性问题。  </p><p>HTTPS并非是应用层的一种新协议，只是将HTTP通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。</p><p><img src="漫谈HTTPS/httpoverssl.jpg" alt=""></p><p>如上图所示：HTTPS即为HTTP over SSL 或 HTTP over TLS。</p><h2 id="HTTP-amp-HTTPS"><a href="#HTTP-amp-HTTPS" class="headerlink" title="HTTP &amp; HTTPS"></a>HTTP &amp; HTTPS</h2><h3 id="HTTP的安全性隐患"><a href="#HTTP的安全性隐患" class="headerlink" title="HTTP的安全性隐患"></a>HTTP的安全性隐患</h3><p>HTTP的安全性隐患主要体现在以下几点：</p><ol><li>通信使用明文（不加密），内容可能会被窃听</li><li>不验证通信方的身份，因此有可能遭遇伪装</li><li>无法证明报文的完整性，所以有可能已遭篡改</li></ol><p>下面我们将针对这三点隐患进行深入讨论。</p><h3 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h3><p>TCP/IP是可能被窃听的网络。按TCP/IP协议的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。  </p><p>所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节会遭到恶意窥视行为。</p><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><p>可以通过加密来防止窃听，加密的对象又可以分为对通信加密和对通信内容加密。</p><h5 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h5><p>可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，建立安全通信线路。</p><p>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP即为HTTPS。</p><p><img src="/2019/08/13/漫谈HTTPS/ssl通道.jpg" alt=""></p><h5 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h5><p>由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。在这种情况下，客户端需要对HTTP报文进行加密处理后再发送请求。</p><p><img src="/2019/08/13/漫谈HTTPS/报文加密.jpg" alt=""></p><p>对内容进行加密存在的问题是：</p><ol><li>客户端和服务器必须同时具备加密和解密机制。</li><li>加密只针对报文主题，无法对报文首部进行加密。</li><li>该方式不同于SSL将整个通信线路加密处理，所以内容仍有被篡改的风险。</li></ol><h3 id="不验证通信方的身份"><a href="#不验证通信方的身份" class="headerlink" title="不验证通信方的身份"></a>不验证通信方的身份</h3><p>HTTP协议中的请求和响应不会对通信方的身份进行确认。</p><p><img src="/2019/08/13/漫谈HTTPS/无身份校验.jpg" alt=""></p><p>HTTP协议的实现本身非常简单，不论是谁发送的请求都会返回响应，不会去确认通信方。</p><h4 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h4><p>虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方身份。</p><p><img src="/2019/08/13/漫谈HTTPS/SSL证书.jpg" alt=""></p><p>通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄漏的危险性。</p><h3 id="无法验证报文完整性，可能已遭篡改"><a href="#无法验证报文完整性，可能已遭篡改" class="headerlink" title="无法验证报文完整性，可能已遭篡改"></a>无法验证报文完整性，可能已遭篡改</h3><p>所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。  </p><p>由于HTTP协议无法证明通信的报文完整性，因此即使请求或响应的内容遭到篡改，也没有办法获悉。</p><p><img src="/2019/08/13/漫谈HTTPS/中间人攻击.jpg" alt=""></p><p>像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。</p><p>仅靠HTTP确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。为了有效防止这些弊端，有必要使用HTTPS。SSL提供认证和加密处理及摘要功能。即HTTP+加密+认证+完整保护=HTTPS。</p><h2 id="SSL-amp-HTTPS"><a href="#SSL-amp-HTTPS" class="headerlink" title="SSL &amp; HTTPS"></a>SSL &amp; HTTPS</h2><p>上面提到，HTTPS的加密、认证、完整性保护都是由SSL提供的。SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的协议（SMTP、Telnet等）均可以配合使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。下面我们一起来看一下SSL是如何保障通信安全的。</p><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h3><p>近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密算法可以大致分为两类：</p><ul><li>对称加密：加密解密用的是同样的密钥。</li><li>非对称加密：加密解密用的是不同的密钥。 </li></ul><p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>由于对称加密，加密、解密使用的是相同的密钥，所以对称加密的核心在于如何将密钥安全的转交给对方。在互联网上个转发密钥时，如果通信被监听那么密钥就会落入攻击者之手，同时也就失去了加密的意义。另外密钥接收者还得设法安全地保管接收到的密钥。</p><p><img src="/2019/08/13/漫谈HTTPS/对称加密被攻击.jpg" alt=""></p><p>从另一个角度看如果密钥可以安全的转交，那么数据也就可以安全的发送。</p><p><img src="/2019/08/13/漫谈HTTPS/数据安全发送.jpg" alt=""></p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密使用一对密钥。一把叫做私有密钥（私钥），一把叫做公开密钥（公钥）。顾名思义私有密钥不能让任何人知道，而公开密钥可以被所有人获取。</p><p>使用非对称加密，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p><p>另外，要根据密文和公开密钥，恢复到信息原文是异常困难的，这是因为解密过程就是在对离散对数进行求值。</p><p><img src="/2019/08/13/漫谈HTTPS/非对称加密.jpg" alt=""></p><h4 id="HTTPS采用混合加密的方式"><a href="#HTTPS采用混合加密的方式" class="headerlink" title="HTTPS采用混合加密的方式"></a>HTTPS采用混合加密的方式</h4><p>HTTPS采用对称加密和非对称加密两者并用的混合加密机制。即，使用非对称加密进行安全的对称加密密钥交换后，使用对称加密发送HTTP报文信息。</p><p><img src="/2019/08/13/漫谈HTTPS/SSLHTTP加密.jpg" alt=""></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>非对称加密方式还是存在一些问题。那就是无法证明公开密钥本身就是货真价实的公开密钥。为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关办法的公开密钥证书。</p><p>首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份后，会对<br>已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。  </p><p>服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端。以进行公开密钥加密方式通信。</p><p>接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字认证机构。二，服务器的公开密钥是值得信赖的。  </p><p>此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交时一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。  </p><p><img src="/2019/08/13/漫谈HTTPS/认证.jpg" alt=""></p><h2 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h2><p>为了更好地理解HTTPS，我们来观察一下HTTPS的通信步骤。</p><p><img src="/2019/08/13/漫谈HTTPS/HTTPS通信.jpg" alt=""></p><ol><li>客户端通过发送Client Hello报文开始SSL通信。报文中包含客户端支持的SSL的指定版本、加密组件列表。</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>之后服务器发送Certifiicate报文。报文中包含公开密钥证书。</li><li>服务器发送Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分结束。</li><li>SSL第一次握手结束之后，客户端以Client Key Exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。该报文已用步骤3中的公开密钥进行加密。</li><li>接着客户端继续发送Change Cipher Spec报文。该报文会提示服务器，在此报文之后的通信会采用Pre-master secret密钥加密。</li><li>客户端发送Finished报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能成功，要以服务器是否能够正确解密该报文作为判定标准。</li><li>服务器同样发送Change Cipher Spec报文。</li><li>服务器同样发送Finished报文。</li><li>服务器和客户端的Finished报文交换完毕后，SSL连接建立完成。从此处开始进行应用层协议的通信，即发送HTTP请求。</li><li>应用层协议通信，即发送HTTP请求。</li><li>最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，这步之后再发送TCP FIN报文来关闭与TCP的通信。</li></ol><h2 id="SSL和TSL"><a href="#SSL和TSL" class="headerlink" title="SSL和TSL"></a>SSL和TSL</h2><p>HTTPS使用SSL和TLS这两个协议。SSL协议最初是由浏览器开发商网景通信公司率先倡导的，开发过SSL3.0之前的版本。目前主导权已移到IETF的手中。</p><p>IETF以SSL3.0为基准，后又制定了TLS1.0、TLS1.1和TLS1.2。TLS是以SSL为原型开发的协议，有时会统一称该协议为SSL。当前主流版本是SSL3.0和TLS1.0。</p><h2 id="HTTPS存在的问题"><a href="#HTTPS存在的问题" class="headerlink" title="HTTPS存在的问题"></a>HTTPS存在的问题</h2><p>HTTPS也存在一些问题，那就是当使用SSL时，它的处理速度会变慢。</p><p><img src="/2019/08/13/漫谈HTTPS/HTTPS慢.jpg" alt=""></p><p>HTTPS比HTTP要慢2到100倍</p><p>SSL的慢分两种。一种是指通信慢。另一种是指由于消耗大量CPU及内存资源，导致处理速度变慢。  </p><p>和使用HTTP相比，网络负载可能会变慢2到100倍。除去和TCP连接、发送HTTP请求、响应外，还必须进行SSL通信，因此整体上处理通信量不可避免会增加。  </p><p>另一点是SSL必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起HTTP会更多地消耗服务器和客户端的硬件资源，导致负载增强。  </p><p>针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL通信专用硬件，相对软件来讲，能够提高数倍SSL的计算速度。仅在SSL处理时发挥SSL加速器的功效，以分担负载。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hypertext Transfer Protocol Secure (HTTPS)是对于HTTP的拓展，用于解决在计算机通信过程中的安全性问题。  &lt;/p&gt;
&lt;p&gt;HTTPS并非是应用层的一种新协议，只是将HTTP通信接口部分用SSL（Secure Socket Laye
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>虚拟内存管理</title>
    <link href="http://yoursite.com/2019/07/31/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/31/虚拟内存管理/</id>
    <published>2019-07-31T05:52:31.000Z</published>
    <updated>2019-07-31T09:51:08.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟内存简述"><a href="#虚拟内存简述" class="headerlink" title="虚拟内存简述"></a>虚拟内存简述</h2><p> 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分被暂时存储在外部磁盘存储器上。</p><p>如图： </p><p><img src="/2019/07/31/虚拟内存管理/VirtualMem01.png" alt=""></p><a id="more"></a><p>与没有使用虚拟内存技术的系统相比，虚拟内存的优势主要体现在以下几点：</p><ul><li>它将主存看成是一个存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。</li><li>它为所有进程提供了一致的地址空间,简化了内存管理。</li><li>它保护了每个进程的地址空间不被其他进程破坏。</li></ul><p>使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。OS X 和 iOS都提供了虚拟内存管理系统。本文中我们将深入探讨iOS OS X 下的虚拟内存管理系统。</p><h2 id="虚拟内存寻址操作"><a href="#虚拟内存寻址操作" class="headerlink" title="虚拟内存寻址操作"></a>虚拟内存寻址操作</h2><p>我们先来看一下物理内存的寻址操作：</p><h3 id="物理地址寻址操作"><a href="#物理地址寻址操作" class="headerlink" title="物理地址寻址操作"></a>物理地址寻址操作</h3><p>下图展示了物理寻址操作下从4字节处开始读取4个字节。</p><p><img src="/2019/07/31/虚拟内存管理/656644-88af406f0dcc3d44.png" alt=""></p><p>CPU 在执行这条指令的时候，生成一个有效物理地址，通过内存总线，把这个物理地址传递给主存，主存取出从物理地址4处开始的 4 个字节字，然后将它返回给 CPU，CPU 将它存放在一个寄存器里。早期使用物理寻址的系统通常都比较简单，比如数字信号处理器，计算器等嵌入式设备。</p><h3 id="虚拟地址寻址操作"><a href="#虚拟地址寻址操作" class="headerlink" title="虚拟地址寻址操作"></a>虚拟地址寻址操作</h3><p>对于虚拟内存地址的寻址操作，处理器及其内存管理单元（MMU）维护了一个页表，将程序的逻辑地址空间中的页面映射到计算机RAM中的硬件地址。当程序代码访问存储器中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件存储地址。此转换是自动改发生的，对正在运行的应用程序是透明的。<br>之后，再进行物理地址寻址操作即可。</p><p><img src="/2019/07/31/虚拟内存管理/656644-23f0b90ff47ff865.png" alt=""></p><h2 id="分页（Paging）"><a href="#分页（Paging）" class="headerlink" title="分页（Paging）"></a>分页（Paging）</h2><p>为了更好的利用和管理计算机内存资源，有效利用碎片内存，操作系统引入了<a href="https://www.zhihu.com/question/50796850" target="_blank" rel="noopener">内存分页</a>的概念。在分页的概念下，内存的换入换出是以页为单位了。</p><p>那么为什么我们可以把运行中程序的某一页换出到磁盘？  </p><p>答案是程序的空间局部性：当一个程序运行时，在某个时间段，它只是频繁的用到了一小部分数据。所以我们可以将程序暂时用不到的数据、代码换出到磁盘。  </p><p>在OS X 和早期版本的iOS中，虚拟内存页面和物理内存页面大小均为4kb。基于A7和A8处理器的系统 虚拟内存分页大小为16kb，物理内存大小分页为4kb。A9及以上的处理器 虚拟内存和物理内存分页大小均为16kb。</p><h2 id="虚拟内存的核心"><a href="#虚拟内存的核心" class="headerlink" title="虚拟内存的核心"></a>虚拟内存的核心</h2><p>在继续深入之前我们一起来看一张WWDC 2012上的一张PPT，熟悉一下iOS/OS X虚拟内存的核心概念。</p><p><img src="/2019/07/31/虚拟内存管理/virtuualMemoory.png" alt=""></p><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>首先是Region，如果每次需要内存时都通过系统调用内核来分配几KB的内存代价是非常高昂的，所以操作系统将虚拟内存分为不同的Region，如上所示ImageIO Region、Malloc Region。这样，分配内存时只需从Region中分配即可。</p><h3 id="VM-Object"><a href="#VM-Object" class="headerlink" title="VM Object"></a>VM Object</h3><p>每一个Region都会关联一个VM Object 内核通过VM Object 来管理Region中对应的虚拟内存页。Region中的虚拟内存页除可以映射到物理内存中，还可以映射到后备存储或文件系统中的内存映射文件。VM Object中包含一个pager，通过pager来管理虚拟内存页与后备存储的映射或与内存映射文件的映射。</p><p>the default pager： 管理后备存储和虚拟内存页面的映射，并在需要时将这些数据加载进入内存。<br>the vnode pager：The vnode pager使用分页机制直接向文件提供窗口。这个机制允许您读取和写入文件的某些部分，就像它们位于内存中一样。</p><table><thead><tr><th>字段</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>Resident pages</td><td style="text-align:center">Region中当前驻留在物理内存中的内存页列表</td></tr><tr><td>Size</td><td style="text-align:center">Region的大小，以字节为单位。</td></tr><tr><td>Pager</td><td style="text-align:center">负责跟踪和处理Region中在后备存储空间（或文件）中的页面</td></tr><tr><td>Shadow</td><td style="text-align:center">用于优化copy-on-write机制</td></tr><tr><td>Copy</td><td style="text-align:center">用于优化copy-on-write机制</td></tr><tr><td>Attributes</td><td style="text-align:center">标志指示各种实现细节的状态。</td></tr></tbody></table><p>如果vm 对象涉及copy-on-write (vm_copy) 操作, shadow和copy字段可能指向其他vm对象。否则这两个字段都为null。</p><h3 id="Resident-Memory"><a href="#Resident-Memory" class="headerlink" title="Resident Memory"></a>Resident Memory</h3><p>当前驻留在物理内存中的虚拟内存，与之对应的是当前未驻留在物理内存中的虚拟内存nonresident Memory。</p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>虚拟内存管理系统的核心是对内存页的管理：虚拟内存页和物理内存页的映射、Page Fault、Paging Out、Paging In等。</p><h3 id="Page-fault"><a href="#Page-fault" class="headerlink" title="Page fault"></a>Page fault</h3><p>就程序而言，其逻辑地址空间始终可用。但是，如果应用程序访问当前不再物理RAM中的内存页的地址，就会发生page fault。当page fault 触发后，虚拟内存系统会通过page-fault handler来响应。page-fault handler 停止当前程序正在执行的代码，找到空闲的物理内存页，从磁盘加载包含所需数据的页面，更新页面表，然后将控制返回到程序的代码，程序就可以正常执行。</p><p>磁盘抖动都会对性能产生负面影响。因为它迫使系统花费大量的时间来读写磁盘。从后备存储中读取页面会比直接从RAM读取要慢得多。如果系统必须先将页面写入磁盘才能从磁盘中读取另一个页面，则性能影响会更大。</p><h3 id="Page-Lists"><a href="#Page-Lists" class="headerlink" title="Page Lists"></a>Page Lists</h3><p>内核维护了三个系统范围内的物理内存页列表：</p><ul><li>active list ：维护了当前映射在内存中并且最近被访问过的页面</li><li>inactive list ：维护了当前映射在内存中但是最近没有被访问过的内存页面，这些页面包含有效数据，可以随时从内存中删除。</li><li>free list ： 维护了当前空闲的物理内存页。这些页面可以供任何需要它们的进程使用。</li></ul><p>当空闲列表上的页数低于阈值时，pager会尝试平衡队列。它通过从非活动列表中提取页面来完成此操作。如果最近访问过某个页面，则会重新激活该页面并将其放置在活动列表的末尾。在OS X中，<br>如果inactive list中的内存页存储的数据并没有被写入后备存储内存中，在释放该内存页将其置入free list之前必须将该内存页存储的数据page out到后备存储内存中。（在iOS中对于非活跃内存的清理，必须由应用程序自己来操作）</p><p>当应用程序不再访问某一内存页，内核将该内存页从active list移动至inactive list。当page fault 发生时，内存将内存页从inactive list 移动至 active list。当虚拟内存页换出内衬时，对应的物理内存页将被移至free list。同样，当进程显示的是放过内存时，内核将相关内存页移动至free list。</p><h3 id="Paging-Out"><a href="#Paging-Out" class="headerlink" title="Paging Out"></a>Paging Out</h3><p>OS X下，如果在free list 的内存页低于一个指定的阈值，内核通过将非活动页面交换到磁盘来回收物理内存页面。为此：内核需遍历所有在物理内存中的活跃内存列表和非活跃内存列表：</p><ol><li>如果active list中的内存页最近没有被访问，该内存页将被移动至非活动内存页。</li><li>如果inactive list 中的内存页最近没有被访问，内核找到页面对应的VM obj。</li><li>如果该VM obj之前没有进行过page操作，内核创建为其创建一个pager obj。</li><li>VM obj 的 pager 尝试将该页面写至后备内存中。</li><li>如果pager第四步操作成功，内核释放该页面所对应的物理内存，将该内存页从inactive list 移至free list。</li></ol><p>在iOS平台下，内核不会将页面写入后备存储。当可用内存量低于计算阈值时，内存会先将clear memory 移动至磁盘，并且还可能发出memory warning。</p><h3 id="Paging-In"><a href="#Paging-In" class="headerlink" title="Paging In"></a>Paging In</h3><p>当操作系统访问到没有被映射到物理内存页的虚拟内存页时会发生memory access fault。 发生内存访问错误时会触发Paging In process。</p><p>有两种类型的memory access fault：</p><ol><li>soft fault： 当引用地址的页面驻留在物理内存中但未映射到此进程的地址空间时，会触发soft fault。</li><li>hard fault： 当引用地址的页面没有驻留在物理内存中（存储介质为后备存储空间或文件），会触发hard fault。这就是通常所说的page fault。</li></ol><p>发生任何类型的memory access fault时，内核将为访问Region找到对应的VM obj。然后内核遍历VM obj对象的常驻页面列表。如果所需页面位于常驻页面列表中，则内核会触发soft fault，否则触发hard fault。</p><p>对于 soft faults： 内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将该页面标记为活跃。如果涉及到写操作，页面同样会被标记为已修改，后续该页面需要释放时会将其写入后备存储。</p><p>对于hard faults： 根据VM object对象pager类型的不同页面映射在后备存储或磁盘文件上。pager将页面映射到物理内存上，并修改页面映射信息。和soft faults一样，如果涉及到写操作，该内存页将被标记为已修改。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="">About the Virtual Memory System</a><br><a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">虚拟内存</a><br><a href="https://www.zhihu.com/question/50796850" target="_blank" rel="noopener">内存分页</a><br><a href="https://developer.apple.com/videos/play/wwdc2012/242/" target="_blank" rel="noopener">iOS App Performance: Memory</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;虚拟内存简述&quot;&gt;&lt;a href=&quot;#虚拟内存简述&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存简述&quot;&gt;&lt;/a&gt;虚拟内存简述&lt;/h2&gt;&lt;p&gt; 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分割成多个物理内存碎片，还有部分被暂时存储在外部磁盘存储器上。&lt;/p&gt;
&lt;p&gt;如图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/07/31/虚拟内存管理/VirtualMem01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Optimizing Storage in Your App</title>
    <link href="http://yoursite.com/2019/07/18/Optimizing-Storage-in-Your-App/"/>
    <id>http://yoursite.com/2019/07/18/Optimizing-Storage-in-Your-App/</id>
    <published>2019-07-18T11:14:07.000Z</published>
    <updated>2019-07-19T06:35:23.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>类似于设备的CPU和内存，存储空间同样是有限的资源。优化app对存储空间的使用，对app的耗电量、手机电池寿命、app包体大小、良好的手机运行都是大有裨益。</p><p>今天的优化对于app存储空间的优化将从图像资源、磁盘同步、数据文件序列化、SQLite 几个角度展开。</p><a id="more"></a><h2 id="图片资源-（image-assets）"><a href="#图片资源-（image-assets）" class="headerlink" title="图片资源 （image assets）"></a>图片资源 （image assets）</h2><p>随着屏幕尺寸变大，图片资源的大小也相应的在增加。我们可以通过两种简单的方式来降低图片资源对存储空间的占用。使用HEIC格式的图片和使用Asset Catalogs来管理图片。</p><h3 id="HEIC"><a href="#HEIC" class="headerlink" title="HEIC"></a>HEIC</h3><p>HEIC，有时也被称为HEIF，是JPEG的更有效和更强大的替代品。</p><p>同等图片质量下的HEIC文件要比JPEG文件小上50%左右。更小的文件体积伴随着各种各样的优势：</p><ul><li>更低的磁盘占用。</li><li>更快的网络传输速度。</li><li>更快的从磁盘加载或保存到磁盘。</li></ul><p>HEIC还提供了许多JPEG不具备的功能。</p><ul><li>存储包含深度和视差信息的辅助图像功能</li><li>支持alpha通道</li><li>支持无损压缩</li><li>支持将多个图像存储在单个容器中</li></ul><p>iOS从iOS11开始支持HEIC，macOS从macOS High Sierra开始支持HEIC。</p><h3 id="Asset-Catalogs"><a href="#Asset-Catalogs" class="headerlink" title="Asset Catalogs"></a>Asset Catalogs</h3><p>另一个降低app占用空间的方式是使用Asset Catalogs管理图片资源。</p><p>Asset Catalogs提供了一种非常便捷的方法来管理同一图像的多个分辨率图片资源，让多设备的适配变的非常容易。</p><h4 id="storage优化"><a href="#storage优化" class="headerlink" title="storage优化"></a>storage优化</h4><p>通过Asset Catalogs来管理图片资源我们将获得以下关于storage方面的优化：</p><ul><li><p>通过Asset Catalogs可以实现对图片资源的<br><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/" target="_blank" rel="noopener">按需加载</a>，这样在用户使用到这些资源之前无需下载。  </p></li><li><p>由于Asset Catalogs，以统一的优化后的格式来存储所有图像资源，而不是以单个文件的方式。通过Asset Catalogs来管理图片资源，将占用更低的存储空间。</p></li><li><p>App Store还使用Asset Catalogs中的元数据来帮助支持iOS应用的app slicing（仅向设备传送与之相关的资源（取决于屏幕分辨率，架构等等））。这样，当客户从商店下载您的应用时，他们只获得他们的特定设备所需的资源，这使得下载包的体积更小，用户可以更快的用起来你的app。</p></li></ul><p>通过Asset Catalogs来管理图片资源我们将获得以下关于性能方面的优化：</p><ul><li>由于Asset Catalogs保存我们的图像资源的优化格式，图像可以更快地加载。这对于app的启动时间尤为有用。</li><li>Asset Catalogs也使得采用基于GPU的压缩变得非常容易。默认情况下，此压缩是无损的，但可以使用有损图像选项。</li></ul><p>HEIC和Asset Catalogs是非常简单有效的方案来优化app的存储空间占用。如果您尚未将HEIC和Asset Catalogs 应用于你的app，我们强烈建议你考虑使用它们。</p><h2 id="一个写文件的例子"><a href="#一个写文件的例子" class="headerlink" title="一个写文件的例子"></a>一个写文件的例子</h2><p>假设我们的应用程序维护了一个plist文件，用于记录app上一次的启动时间。app每次启动时，我们读取plist文件，更新启动时间，将更新后的plist文件写入磁盘。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/ PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">&lt;key&gt;last_app_launch&lt;/key&gt;</span><br><span class="line">&lt;date&gt;2019-06-07T07:26:49Z&lt;/date&gt; &lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure><p>如果我们用File Activity instrument对这一过程进行监测，我们可以看到这个过程产生了：</p><ul><li>一次读操作</li><li>三次写操作 </li><li>一次fsync()操作</li></ul><h2 id="文件系统元数据（file-system-metadata）"><a href="#文件系统元数据（file-system-metadata）" class="headerlink" title="文件系统元数据（file system metadata）"></a>文件系统元数据（file system metadata）</h2><p>一次读很容易理解，但是既然我们只做了一次写操作，那么为何会产生三次写操作呢？fsync()又是什么呢？我们继续往下看。</p><h3 id="file-system-metadata"><a href="#file-system-metadata" class="headerlink" title="file system metadata"></a>file system metadata</h3><p>那么我们一次写plist文件为何会产生三次写操作呢？答案是：file system metadata! </p><p>file system metadata 是文件系统管理文件所必须的数据信息，这些信息会包含：  </p><ol><li>文件名称</li><li>文件大小</li><li>文件位置</li><li>编辑日期、创建日期等日期信息</li><li>等其他信息</li></ol><p>在以下场景下会触发对于file system metadata的写I/O</p><ol><li>创建文件</li><li>删除文件</li><li>文件重命名</li><li>更新文件</li><li>和其他文件系统操作</li></ol><h4 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h4><p>为了进一步理解file system metadata，让我们一起来看看当我们将240 byte大小的NSDictionary文件写入磁盘时APFS(Apple File System)所必须执行的操作。</p><ul><li>更新file system tree</li></ul><p>首先APFS需要更新file system tree中的某一个节点，来完成对file system tree的更新。  </p><p>由于APFS copy on write的特性，我们没有办法直接更新file system tree中的节点，我们需要创建一个待更新节点的拷贝节点。新的拷贝节点会持有一个递增的（或者至少唯一的）transaction ID，我们根据transaction ID来区分拷贝节点和原始节点。同时正式这种唯一的transaction ID使得APFS可以支持snapshots等高级功能。</p><ul><li>更新object map</li></ul><p>在更新file system tree之后，APFS需要更新object map，以便映射到新的节。</p><p>所以，为了完成对249 byte的NSDictionary文件的写磁盘操作，APFS需先进行两次写操作来更新file system metadata。<br>一共将产生8K的写I/O，4K更新file system tree，4K更新object map。</p><ul><li>将NSDictiionary写入磁盘</li></ul><p>最后，我们仍然需要对文件本身进行写操作，iOS设备写入磁盘的最小单位是4KB，即使文件本身的大小只有240 byte，依然会产生4K的写I/O。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，为了存储240 byte的NSDictiionary，我们执行了三次写操作，将12K的数据写入磁盘，效率约为2%。</p><p>该示例不仅向我们展示了APFS跟踪管理文件所需要做的工作，还强调了将少量数据存储在文件系统上的单个文件上的成本很高。</p><h2 id="磁盘同步"><a href="#磁盘同步" class="headerlink" title="磁盘同步"></a>磁盘同步</h2><p>在管理数据位置时，我们希望将数据保存在最接近CPU的位置以获得最佳的性能，我们还希望确保在需要时将数据同步到磁盘上。fsync()就是磁盘同步的命令之一。</p><h3 id="数据存放的位置"><a href="#数据存放的位置" class="headerlink" title="数据存放的位置"></a>数据存放的位置</h3><p>我们来看一下数据会存放在哪些位置。</p><h4 id="OS-cache"><a href="#OS-cache" class="headerlink" title="OS cache"></a>OS cache</h4><p>这是我们希望保存数据的位置，在OS cache中存放数据可以获得最大性能。对OS cache的读写操作可以为 逻辑I/O。OS cache的存储是由内存支持的，因此逻辑I/O可以非常快的完成。通常把频繁使用和修改的数据放入OS cache中。  </p><h4 id="Disk-cache"><a href="#Disk-cache" class="headerlink" title="Disk cache"></a>Disk cache</h4><p>磁盘缓存，提供了一个内存池，当保存在内存池中的数据达到一个程度时，便会将数据保存到磁盘上。这样实际减少了CPU透过I/O操作磁盘的次数，提升了磁盘I/O的效率。</p><h4 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h4><p>即为磁盘，对于iOS设备和大多数的Mac，这是NAND。</p><h3 id="磁盘同步命令"><a href="#磁盘同步命令" class="headerlink" title="磁盘同步命令"></a>磁盘同步命令</h3><h4 id="fsync"><a href="#fsync" class="headerlink" title="fsync()"></a>fsync()</h4><p>fsync()操作，将数据从OS cache 移动至 disk cache，然而它不会确保disk cache中的数据立刻写入permanent storage，同样不会确保数据写入磁盘的顺序。 </p><p>fsync()是相对昂贵的操作应该避免滥用，当数据在OS cache中，我们可以快速的操作内存中的数据。fsync()后数据将被保存至disk cache。</p><p>操作系统会定时的做fsync()操作，我们应该尽量避免手动触发该操作。</p><h4 id="F-FULLFSYNC"><a href="#F-FULLFSYNC" class="headerlink" title="F_FULLFSYNC"></a>F_FULLFSYNC</h4><p>F_FULLFSYNC可以实现将OS cache中的数据移动至permanent storage，该操作同样会导致disk cache 中的数据立刻移动至permanent storage。  </p><p>F_FULLFSYNC操作是昂贵的，因为待写入数据可能是很大的数据量，F_FULLFSYNC可能耗费大量的时间。最后，操作系统会周期性的为我们执行此操作，我们同样应该尽量避免手动出发该操作。  </p><p>如果使用F_FULLFSYNC的主要原因是为了确保I/O 顺序，一个更优秀的替代方案是F_BARRIERFSYNC。</p><h4 id="F-BARRIERFSYNC"><a href="#F-BARRIERFSYNC" class="headerlink" title="F_BARRIERFSYNC"></a>F_BARRIERFSYNC</h4><p>F_BARRIERFSYNC可以确保I/O顺序。</p><p>F_BARRIERFSYNC可以理解为一个带“barrier”的fsync()。F_BARRIERFSYNC会确保在所有执行F_BARRIERFSYNC之前的I/O操作完成后再执行F_BARRIERFSYNC，并在执行F_BARRIERFSYNC之后再去执行F_BARRIERFSYNC()之后插入的I/O操作。</p><p>因此，它比F_FULLFSYNC性能好太多，因为我们无需将磁盘缓存中的所有数据推送到permanent storage。</p><h2 id="序列化数据文件（Serialized-data-files）"><a href="#序列化数据文件（Serialized-data-files）" class="headerlink" title="序列化数据文件（Serialized data files）"></a>序列化数据文件（Serialized data files）</h2><p>plist、XML、Json这些文件，使用方便、非常容易解析。它们是存储不经常修改的数据的良好载体。然而，所有的这些易用性都是对其他性能的取舍。</p><p>任何时候我们对这类文件进行更改，整个文件都必须被重新序列化并重新写入磁盘。同时由于任何更改都必须更换整个文件，对这类文件的更改总是会设计到上面提到的file system metadata的变更。</p><p>通过File Activity instrument检测我们可以看到简单的四行代码 创建、读取、修改plist文件会导致12个独立的I/O操作。我们每次调用NSDictoinary的写文件方法以原子的方式写入文件时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically;)</span><br></pre></td></tr></table></figure><p>操作都以fsync()结束。这意味着所有对plist文件的操作都会被推送到磁盘上，我们无法享受到OS cache 带来的便捷性。</p><p>对于大量的数据或对数据有较多的存取操作 不建议使用序列化数据文件，Sqlite 是一个很好的选择。</p><h2 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h2><p>SQLite是一个很大的课题，我们从connections、journaling、transactions、文件大小和隐私、以及部分索引和子链接几个方面来聊一下。而在这之前，首先，我们应该明白SQLite的健壮性保障并不是免费的。</p><h3 id="connections"><a href="#connections" class="headerlink" title="connections"></a>connections</h3><p>打开和关闭数据库可能会导致一些昂贵的操作，例如一致性检查、日志恢复和日志checkingpoing (同步WAL文件和数据库文件)等。</p><p>所以我们建议尽可能长时间保持数据库打开，并仅在必要时关闭连接。</p><p>对于一个多线程进程，pool connections 使得只要有一个线程仍需要数据库，数据库就可以保持打开的状态。有助于降低频繁打开关闭数据库的成本。</p><h3 id="journaling"><a href="#journaling" class="headerlink" title="journaling"></a>journaling</h3><p>Delete mode journaling 是默认的日志模式，但是通常情况下它不一定是效率最高的日志模式。我们更建议使用WAL Mode Journaling来代替。</p><h4 id="Delete-mode-journaling"><a href="#Delete-mode-journaling" class="headerlink" title="Delete mode journaling"></a>Delete mode journaling</h4><p>一起来看一下Delete mode journaling 是如何工作的：假设我们有一个数据库，我们想修改其中的四个页面。</p><ul><li>首先我们将待修改的四个页面复制到日志文件中。</li><li>然后我们修改数据库中待修改的四个页面。</li><li>数据库修改完成后删除日志文件。</li></ul><p>我们回过头来看一下我们需要付出的成本：</p><ul><li>我们实际上修改了两倍于待修改页面的数量。</li><li>我们必须承担管理这个临时日志文件所带来的文件系统的开销。</li></ul><h4 id="WAL-Mode-Journaling"><a href="#WAL-Mode-Journaling" class="headerlink" title="WAL Mode Journaling"></a>WAL Mode Journaling</h4><p>SQLite提供了一种更有效的替代方案Write Ahead Log或WAL Mode Journaling。对比于Delete mode journaling模式，Write Ahead Log有以下几点优势：</p><ul><li>将对同一page的多次修改合并为一次写入操作。</li><li>更少的写入意味着更少的使用barriers</li><li>支持多个读者和一个写者</li><li>支持snapshots</li></ul><p>我们再来看一下上面的例子在WAL Mode Journaling 下是如何工作的：</p><p>WAL Mode Journaling模式下不会直接在数据库中修改页面，而是直接写入Write Ahead Log文件，并且后续的其他事务也会被添加到Write Ahead Log中，Write Ahead Log文件变得足够大时会触发checkpoint操作。这样，在Delete mode journaling 模式下的可能被多次修改的页面，同一页面的所有更改只需要在checkpoint时修改一次即可。</p><p>当checkpint完成后，只需对WAL文件头简单的处理就可以继续复用。从而降低了文件系统维护此预写日志文件的成本。</p><p>对于多数的SQLite使用场景，我们可以看到WAL模式是效率更高的模式。强烈推荐使用WAL模式，WAL模式下的SQLite管理会得到巨大的性能提升。</p><h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p>关于事物的概念这里不再表述，这里只说明和磁盘I/O相关的一点：尽量在一个事务中执行多个语句。</p><p>在同一个事物中执行多个INSERT、UPDATE、DELETE语句可以为SQLite提供更多的信息以获得更高效的操作。在同一事物中由多个语句多次更改的的页面只会被磁盘写一次。</p><p>假设，我们在三个不同的事物里对同一个页面分别执行INSERT、UPDATE、DELETE操作，那么数据库的这个页面将会被磁盘写三次。</p><p>所以我们可以通过在同一个事务里来对多个操作进行组合，以提升磁盘I/O效率。</p><h3 id="File-Size-and-Privacy"><a href="#File-Size-and-Privacy" class="headerlink" title="File Size and Privacy"></a>File Size and Privacy</h3><h4 id="避免使用VACUUM"><a href="#避免使用VACUUM" class="headerlink" title="避免使用VACUUM"></a>避免使用VACUUM</h4><p>VACUMM是一种非常慢点内存和I/O密集型操作。</p><p>假设我们有一个数据库，我们执行VACUMM操作来删除掉数据库中所有的空闲页面。会发生什么？</p><ol><li>创建日志文件。</li><li>将数据库中所有有效数据的页面拷贝到日志文件。</li><li>将数据库截断为日志文件的大小，并且将日志中的所有数据重新插入数据库。</li><li>最后，丢弃日志文件。</li></ol><p>所以，我们看到VACUMM非常昂贵，数据库中所有的有效数据必须至少写入两次，一次写入日志文件，然后再次写入数据库。</p><h4 id="auto-vacuum-INCREMENTAL"><a href="#auto-vacuum-INCREMENTAL" class="headerlink" title="auto_vacuum=INCREMENTAL"></a>auto_vacuum=INCREMENTAL</h4><p>再一次，有一个更优的替代方案可以供我们选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PRAGMA schema.auto_vacuum=INCREMENTAL;</span><br><span class="line">PRAGMA schema.incremental_vacuum=(N); </span><br><span class="line">// ’N’ is the number pages to be vacuumed</span><br></pre></td></tr></table></figure><p>一起来看一下auto_vacuum=INCREMENTAL的工作原理，在这个例子里我们将抽出两个空闲的页面。</p><ul><li>创建Write Ahead Log</li><li>将数据库末尾的两个页面迁移到Write Ahead Log</li><li>在数据库重新平衡期间对任何页面的修改都会记入Write Ahead Log</li><li>check point：当Write Ahead Log 到达check point时，数据库文件本身会被截断，我们从数据库末尾迁移的页面将被放入之前的空闲页面，并更新任何其他修改的页面</li></ul><p>auto_vacuum=INCREMENTAL下，我们不必对数据库中所有的数据做移入、移除操作，我们只需修改数据库中的一小部分页面即可。</p><h3 id="Partial-indexes"><a href="#Partial-indexes" class="headerlink" title="Partial indexes"></a>Partial indexes</h3><p>在正常的索引中，表中所有的数据都会创建索引。而<a href="https://www.sqlite.org/partialindex.html" target="_blank" rel="noopener">Partial indexes</a>只针对表中部分满足条件的元素创建索引。</p><p>索引有助于更快的执行查询操作，但是会对数据库的写入操作产生性能影响。合理的使用Partial indexes可以在享受索引带来的更快查询操作的同时降低对数据库写入操作性能的影响。</p><p>可以通过在普通CREATE INDEX语句的末尾添加WHERE子句来创建部分索引。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX ex1 ON tab1(a,b) WHERE a=5 OR b=6;</span><br></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.sqlite.org/partialindex.html" target="_blank" rel="noopener">Partial indexes</a></p><p><a href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/" target="_blank" rel="noopener">按需加载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;类似于设备的CPU和内存，存储空间同样是有限的资源。优化app对存储空间的使用，对app的耗电量、手机电池寿命、app包体大小、良好的手机运行都是大有裨益。&lt;/p&gt;
&lt;p&gt;今天的优化对于app存储空间的优化将从图像资源、磁盘同步、数据文件序列化、SQLite 几个角度展开。&lt;/p&gt;
    
    </summary>
    
      <category term="WWDC" scheme="http://yoursite.com/categories/WWDC/"/>
    
    
      <category term="WWDC" scheme="http://yoursite.com/tags/WWDC/"/>
    
      <category term="SQLite" scheme="http://yoursite.com/tags/SQLite/"/>
    
  </entry>
  
  <entry>
    <title>object_getClass(obj) VC [OBJ class]</title>
    <link href="http://yoursite.com/2019/07/15/object-getClass-obj-VC-OBJ-class/"/>
    <id>http://yoursite.com/2019/07/15/object-getClass-obj-VC-OBJ-class/</id>
    <published>2019-07-15T10:21:39.000Z</published>
    <updated>2019-07-15T10:45:21.715Z</updated>
    
    <content type="html"><![CDATA[<p>阅读RAC源码时，卡在了 RACSwizzleClass 方法。在 RACSwizzleClass 方法的实现中对self.class 和  object_getClass(self)的返回值进行了比较。what？object_getClass的返回值和class方法的返回值会不一致？感觉非常奇怪，由此进行了一番探索。为了方便理解，这里会先讲一下OC类、元类相关的基础概念。</p><h3 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h3><p>  作为面向对象的核心概念–每一个对象都有一个类。在OC中有isa指针（指向其所属类）的结构体都可以视为一个对象（所以block也是一个对象）。</p><p>  事实上，OC中id的定义也是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="OC的消息机制"><a href="#OC的消息机制" class="headerlink" title="OC的消息机制"></a>OC的消息机制</h4><p>  消息机制是OC的核心机制，OC中类保存了对象的方法列表、变量列表、super_class等信息，OC中向对象发送一条消息，runtime会根据对象isa指针在类中存储的方法列表及继承体系中寻找并调用相应方法。</p><h3 id="类也是一个对象"><a href="#类也是一个对象" class="headerlink" title="类也是一个对象"></a>类也是一个对象</h3><p>大家应该都了解，OC中类也是一个对象。例如，我们可以给类发送一条消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSString stringFromNumber:@3]</span><br></pre></td></tr></table></figure><p>  同样，OC的类定义中包含isa指针</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>那么类中的isa指针指向什么？</p><h4 id="类对象的类—元类"><a href="#类对象的类—元类" class="headerlink" title="类对象的类—元类"></a>类对象的类—元类</h4><p>   如上类定义中isa指针指向的类即为元类。元类是类对象的类，在元类中会保存类对象的一些信息如类方法列表。简单来说：</p><ul><li>向一个对象发送一条消息，runtime会在对象类的方法列表中检索调用方法。</li><li>向一个类发送一条消息，runtime会在类的元类的方法列表中检索调用方法。</li></ul><h3 id="OC类结构关系图解"><a href="#OC类结构关系图解" class="headerlink" title="OC类结构关系图解"></a>OC类结构关系图解</h3><p>   从上述类定义中可以看出元类也是一个”Class”,所以元类也是一个对象，所以元类也有一个isa指针，元类也有一个类。关系有点复杂，这里引用一个经典的类结构关系图解。</p><p>   <img src="/2019/07/15/object-getClass-obj-VC-OBJ-class/OC类结构关系图解.png" alt=""></p><p>横向看就是isa指针的指向，实例的isa指向类、类的isa指向元类，这里需要注意的是元类isa指针统一指向纵向（继承关系）上的根元类。而根元类的isa指针指向自己。  </p><p>纵向看superclass指针很容易理解，就是按照继承关系向上指的，一直到继承链的最上方，值得说的是Root class（class）的superclass指向是nil，Root class（meta）的superclass指向它的Root class （class），这个注意一下。</p><h3 id="从底层实现看-object-getClass-和-class-的区别"><a href="#从底层实现看-object-getClass-和-class-的区别" class="headerlink" title="从底层实现看 object_getClass 和 class 的区别"></a>从底层实现看 object_getClass 和 class 的区别</h3><p>object_getClass的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    if (obj) return obj-&gt;getIsa();</span><br><span class="line">    else return Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NSObject中实例方法class和类方法class的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (Class)class &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object_getClass就是类结构关系图解中的横向关系，循着isa指针返回对象真实的类。  </p><p>实例方法class底层返回object_getClass执行结果，而类方法class直接返回自身。也就是说通常情况下，对于一个实例对象aObj，object_getClass(aObj)与[aObj class]的返回结果是一致的（注意，这里用了通常，有些情况下对实例对象调用两个方法会返回不一致的结果，如RAC后续会讨论）。对于一个aClass对象object_getClass(aClass)返回的是aClass的元类，而[aClass class] 返回的是aClass自身。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>聊了很多理论，是时候写段代码验证一下了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self test];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)test&#123;</span><br><span class="line"></span><br><span class="line">    Car * car = [Car new];</span><br><span class="line">    </span><br><span class="line">    Class currentClass = object_getClass(car);</span><br><span class="line">    for (int i = 1; i &lt; 5; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        NSString * className = [NSString stringWithCString:object_getClassName(currentClass) encoding:NSASCIIStringEncoding];</span><br><span class="line">        NSLog(@&quot;Following the isa pointer %d times gives %@ %p&quot;, i, className ,currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;----------------------------------------------------&quot;);</span><br><span class="line">    </span><br><span class="line">    Class lyingClass = [car class];</span><br><span class="line">    for (int i = 1; i &lt; 5; i ++) &#123;</span><br><span class="line">        NSString * className = [NSString stringWithCString:object_getClassName(lyingClass) encoding:NSASCIIStringEncoding];</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Following the class %d times gives %@ %p&quot;, i, className ,lyingClass);</span><br><span class="line">        </span><br><span class="line">        currentClass = [lyingClass class];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] Following the isa pointer 1 times gives Car 0x10ec0cfe8</span><br><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] Following the isa pointer 2 times gives NSObject 0x10ec0cfc0</span><br><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] Following the isa pointer 3 times gives NSObject 0x10f5a6e38</span><br><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] Following the isa pointer 4 times gives NSObject 0x10f5a6e38</span><br><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] ----------------------------------------------------</span><br><span class="line">2017-09-01 09:23:35.787 Class_objc[77821:2323046] Following the class 1 times gives Car 0x10ec0cfe8</span><br><span class="line">2017-09-01 09:23:35.788 Class_objc[77821:2323046] Following the class 2 times gives Car 0x10ec0cfe8</span><br><span class="line">2017-09-01 09:23:35.788 Class_objc[77821:2323046] Following the class 3 times gives Car 0x10ec0cfe8</span><br><span class="line">2017-09-01 09:23:35.788 Class_objc[77821:2323046] Following the class 4 times gives Car 0x10ec0cfe8</span><br></pre></td></tr></table></figure><p> 下图对上述调用做了简单分析，同时也验证了上面得出的结论:</p><p> <img src="/2019/07/15/object-getClass-obj-VC-OBJ-class/类结构关系调用图.jpeg" alt=""></p><p> 注意：这里有两个NSObject对象元类和根元类，孤陋寡闻的我一直以为OC中类对象是单例，所以一个类只有一个类对象。</p><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>实例对象object_getClass与class返回结果不一致的情况:<br>前面提到默认情况下实例对象class的是通过object_getClass实现的，通常情况下二者的返回值是一致的。某些情况下实例对象的class方法会被重写导致二者返回值不一致，如KVO。KVO是通过<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" target="_blank" rel="noopener">isa swizzle</a>实现的，同时还会重写class方法返回isa swizzle之前的类对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读RAC源码时，卡在了 RACSwizzleClass 方法。在 RACSwizzleClass 方法的实现中对self.class 和  object_getClass(self)的返回值进行了比较。what？object_getClass的返回值和class方法的返回值会不一致？感觉非常奇怪，由此进行了一番探索。为了方便理解，这里会先讲一下OC类、元类相关的基础概念。&lt;/p&gt;
&lt;h3 id=&quot;什么是对象？&quot;&gt;&lt;a href=&quot;#什么是对象？&quot; class=&quot;headerlink&quot; title=&quot;什么是对象？&quot;&gt;&lt;/a&gt;什么是对象？&lt;/h3&gt;&lt;p&gt;  作为面向对象的核心概念–每一个对象都有一个类。在OC中有isa指针（指向其所属类）的结构体都可以视为一个对象（所以block也是一个对象）。&lt;/p&gt;
&lt;p&gt;  事实上，OC中id的定义也是这样的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/// Represents an instance of a class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/// A pointer to an instance of a class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_object *id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="源码阅读" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS Memory Deep Dive</title>
    <link href="http://yoursite.com/2019/07/15/iOS-Memory-Deep-Dive/"/>
    <id>http://yoursite.com/2019/07/15/iOS-Memory-Deep-Dive/</id>
    <published>2019-07-15T09:22:38.000Z</published>
    <updated>2019-07-15T09:31:50.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么控制内存占用？"><a href="#为什么控制内存占用？" class="headerlink" title="为什么控制内存占用？"></a>为什么控制内存占用？</h3><p>简单的回答是：为了更好的用户体验。减少app的内存占用，几乎一切都会变得更好，可以获得更快的app启动速度，更快的响应速度，自己的app甚至其他开发者的app可以在后台停留更长的时间等等。</p><h3 id="内存占用的分类"><a href="#内存占用的分类" class="headerlink" title="内存占用的分类"></a>内存占用的分类</h3><p>app的内存占用可以分为三类：clean 部分，dirty 部分，compressed部分。在iOS我们讨论app内存占用时，我们真正关心的水dirty 部分和compressed 部分。</p><p>内存是生而“不”平等的，系统以内存页的方式来管理内存。内存页的大小通常是16KB（在不同的处理器和操作系统下，会有不同），内存页又可以被归类为clean page 和 dirty page。一份数据可以占用多个内存页同样的一个内存页也可以存储多份数据。内存页的大小乘以app所占用内存页的数量就是app的内存占用。</p><a id="more"></a><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>通过一个栗子来直观的看一下clean page 和 dirty page。</p><p>分配一个含有20000个整数的数组，系统会分配给我六个内存页。最初分配时：这些页面时clean page。当我向数据缓冲区开始写数据时，例如，如果我写入到这个数组的第一个位置，这时。第一个内存页就会变成dirty page。类似的如果我写入到了缓冲区的最后一个位置，那最后一页就会变成dirty page。请注意中间的四个页依然时clean page，因为系统并没有将数据写入。</p><h4 id="内存映射文件（memory-mapped-files）"><a href="#内存映射文件（memory-mapped-files）" class="headerlink" title="内存映射文件（memory-mapped files）"></a>内存映射文件（memory-mapped files）</h4><p>另一个有趣的例子是内存映射文件：即为被加载到内存中的磁盘文件。</p><p>如果这个文件是只读文件，那这些内存页将永远是clean page。内核会合理的控制这些内存页的换入和换出操作。</p><p>举个栗子，对于一张50KB的JPEG文件，映射在内存中会占用四个内存页，而第四个内存页是没有被完全占满的。未被占用的部分还可以用来做其他的事情。这种情况下的内存有一些微妙，而前三个页面依然是clean page。可以由内核来合理的控制换入换出操作。</p><h4 id="clean-page-amp-dirty-page"><a href="#clean-page-amp-dirty-page" class="headerlink" title="clean page &amp; dirty page"></a>clean page &amp; dirty page</h4><p>我们再回过头看一下clean page 和 dirty page。</p><p>clean page：简单来说，存储的是可以被换出的数据。比如上面提到的内存映射文件（Image.jpg、Blob.data、Training.model）。再比如Frameworks，每一个framework都含有DATA CONST section。DATA CONST section的数据是典型的可换出数据，但是如果通过runtime做了类似swizzling的操作，这部分数据将是不可换出数据。</p><p>dirty page：dirty page 存储的是所有被app执行过写操作的数据。在iOS中这些页面是不可被换出的（OSX上可以换出到备用存储空间）。这些数据可以是在生命周期内创建的对象（Views、Array、Cache等），也可以是解码后到图片缓冲区。同时它也可以是Frameworks，Framework的DATA Section 和 DATA Dirty Section都是存放在dirty page内。</p><h4 id="compressed-memory"><a href="#compressed-memory" class="headerlink" title="compressed memory"></a>compressed memory</h4><p>刚刚有提到，不同于OSX，iOS下dirty page是不可被换出的。相反，iOS在iOS7引入了内存压缩器（memory compressor），来为我们的app提供更多的可用内存。</p><p>内存压缩器对最近未访问过的内存进行压缩，这样为app创造出更多可用的内存空间。但是，在app访问被压缩数据时，必须先对这些数据进行解压操作。</p><p>一起看一个栗子：</p><p>一个用于缓存的字典：占用了三个内存页，假设一段时间内该字典没有被访问，且系统需要更多的内存，系统就可以把它压缩到一个内存页中。在再次访问该字典时，会对其进行相应的解压操作。</p><h4 id="Memory-warning-amp-compress-memory"><a href="#Memory-warning-amp-compress-memory" class="headerlink" title="Memory warning &amp; compress memory"></a>Memory warning &amp; compress memory</h4><p>app并不总是引起内存警告的原因：例子，低内存的手机上接到一个电话，可能会触发一个内存警告。压缩器使内存释放变得复杂，由于压缩内容实际上我们使用了比实际内存更多的内存。</p><p>回到上一小节的字典缓存的例子：</p><p>通常，在收到内存警告时，我们会对缓存的内存进行释放。既然我在访问这个字典，那么首先需要将字典进行解压（即由一个内存页占用恢复为三个内存页占用），我门反而占用了更多的内存，在内存受限的环境中我们显然不希望这样的事情发生。而且，很有可能我们做了很多操作释放了大多数的缓存数据，可能我们的工作只是让字典的内存占用变为了一个内存页，我们做了很多的操作只是让字典缓存回到了被压缩前的样子（只占用一个内存页）。所以在收到内存警告时我们一定要小心处理。</p><h5 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h5><p>为了避免CPU重复工作我们引入了缓存，但是过多的缓存会导致内存的耗尽，这个在平时开发过程中需要注意平衡。</p><p>比起字典更建议使用NSCache来进行缓存操作。主要有两点：</p><ul><li>NSCache是线程安全的。</li><li>由于NSCache分配内存的方式，它实际上是可清除的，在内存受限的环境中可以工作得更好。</li></ul><h3 id="内存-amp-Image"><a href="#内存-amp-Image" class="headerlink" title="内存 &amp; Image"></a>内存 &amp; Image</h3><p>我们最后一起来聊一下iOS中内存占用最大的对象—图像！</p><p>关于图像，我们最需要了解的是：图像内存的占用与图像的尺寸有关而不是与它的文件大小有关。</p><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>我有一张590KB的图像想把它做为ipa的壁纸，它的尺寸是2048 px<em> 1536px 。那么它实际会使用多少内存呢？ 10MB！ 2048 </em>1536 * 4byte per pixel。</p><p>为什么图像会占用如此大的内存？iOS中渲染图像需要经过三步：load -&gt; decode -&gt; render。</p><ul><li>load： 590kb的图像被加载到内存中。</li><li>decode： 图片被转换为GPU可读取的格式，此时文件大小增加到了10MB。</li><li>render：GPU将图片渲染到屏幕上。</li></ul><h4 id="图片的存储格式-amp-内存占用"><a href="#图片的存储格式-amp-内存占用" class="headerlink" title="图片的存储格式 &amp; 内存占用"></a>图片的存储格式 &amp; 内存占用</h4><p>不同的图像存储格式对应不同的内存占用</p><table><thead><tr><th>格式</th><th style="text-align:center">大小（每像素）</th></tr></thead><tbody><tr><td>SRGB</td><td style="text-align:center">4 bytes</td></tr><tr><td>wide format</td><td style="text-align:center">4 bytes</td></tr><tr><td>alpha 8</td><td style="text-align:center">1 bytes</td></tr></tbody></table><p>可以看到，alpha 8格式的内存占用是SRGB格式的25%,不同的图像格式可以应用于不同的场景，合理的选择图像格式非常重要这可以帮助我们更合理的使用内存。</p><p>那么我们应该如何合理的选择格式？最好的答案是交给系统来选择！</p><h5 id="使用UIGraphicsIMageRender-代替-UIGraphicsBeginImageCOntextWithOptions"><a href="#使用UIGraphicsIMageRender-代替-UIGraphicsBeginImageCOntextWithOptions" class="headerlink" title="使用UIGraphicsIMageRender 代替 UIGraphicsBeginImageCOntextWithOptions"></a>使用UIGraphicsIMageRender 代替 UIGraphicsBeginImageCOntextWithOptions</h5><p>使用 UIGraphicsBeginImageCOntextWithOptions 生成的图片，每个像素总是4个字节SRGB格式。建议使用UIGraphicsImageRenderer，这个方法是从iOS 10引入，在iOS 12上会自动选择最佳的图像格式。</p><h4 id="对图片的向下采样"><a href="#对图片的向下采样" class="headerlink" title="对图片的向下采样"></a>对图片的向下采样</h4><p>当你缩小一幅图像的时候，会按照取平均值的办法把多个像素点变成一个像素点，这个过程称为下采样（Downsampling）。</p><p>UIImage在设置和调整大小的时候，需要将原始图像加压到内存中，然后对内部坐标空间做一系列转换，整个过程会消耗很多资源。我们可以使用ImageIO，它可以直接读取图像大小和元数据信息，不会带来额外的内存开销。 ImageIO使用Streaming API，这样我们只需为生成的图像使用一些dirty memory。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存是有限的共享资源，在日常开发中应该更合理谨慎的使用内存。日常开发过程中应该关注Xcode等debug工具等产出的内存报告。同时，在内存使用上一些很小的细节可以产生对内存产生很大的影响，如：图片处理，app进入后台时的内存释放等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么控制内存占用？&quot;&gt;&lt;a href=&quot;#为什么控制内存占用？&quot; class=&quot;headerlink&quot; title=&quot;为什么控制内存占用？&quot;&gt;&lt;/a&gt;为什么控制内存占用？&lt;/h3&gt;&lt;p&gt;简单的回答是：为了更好的用户体验。减少app的内存占用，几乎一切都会变得更好，可以获得更快的app启动速度，更快的响应速度，自己的app甚至其他开发者的app可以在后台停留更长的时间等等。&lt;/p&gt;
&lt;h3 id=&quot;内存占用的分类&quot;&gt;&lt;a href=&quot;#内存占用的分类&quot; class=&quot;headerlink&quot; title=&quot;内存占用的分类&quot;&gt;&lt;/a&gt;内存占用的分类&lt;/h3&gt;&lt;p&gt;app的内存占用可以分为三类：clean 部分，dirty 部分，compressed部分。在iOS我们讨论app内存占用时，我们真正关心的水dirty 部分和compressed 部分。&lt;/p&gt;
&lt;p&gt;内存是生而“不”平等的，系统以内存页的方式来管理内存。内存页的大小通常是16KB（在不同的处理器和操作系统下，会有不同），内存页又可以被归类为clean page 和 dirty page。一份数据可以占用多个内存页同样的一个内存页也可以存储多份数据。内存页的大小乘以app所占用内存页的数量就是app的内存占用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="WWDC" scheme="http://yoursite.com/tags/WWDC/"/>
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>根治顽疾：Keep客户端 In-App Purchase 掉单踩坑指南</title>
    <link href="http://yoursite.com/2019/03/10/%E6%A0%B9%E6%B2%BB%E9%A1%BD%E7%96%BE%EF%BC%9AKeep%E5%AE%A2%E6%88%B7%E7%AB%AF-In-App-Purchase-%E6%8E%89%E5%8D%95%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/</id>
    <published>2019-03-10T05:49:00.000Z</published>
    <updated>2019-03-10T06:13:09.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>In-App Purchase（以下简称IAP）是苹果为开发者提供的应用内购服务。Keep于17年初接入In-App Purchase，功能上线后暴漏出严重的丢单问题，丢单概率大概在百分之一。丢单问题在多人多次优化后仍未能解决，成为Keep客户端的顽疾。直至最近的两次优化彻底根治了丢单问题。本文中笔者将循着Keep客户端解决IAP掉单问题的两次优化之旅跟大家分享排查问题的思路以及最终的方案。</p><a id="more"></a><h2 id="历史问题"><a href="#历史问题" class="headerlink" title="历史问题"></a>历史问题</h2><p>由于IAP本身设计问题及开发者不恰当使用API导致IAP掉单是一个较为普遍的内购问题。同时，网上存在各种没有数据支撑的所谓的“解决方案”及各种“一站式解决掉单”的标题党，会对开发者产生一定的误导。盲目的引入这些方案在没有解决问题的同时平白增加了代码的复杂度。甚至有一些开发者表示IAP漏单是无法避免的，只能通过客服的介入来进行补单。</p><p>在之前的几次排查过程中，由于网上信息的误导，盲目接入了几种网上流传的解决方案。</p><ul><li>本地化存储 ：在收到IAP支付成功回调后，将业务订单号、receipt信息持久化，在app启动时遍历本地存储列表触发补单逻辑。</li><li>网络异常重试：app校验receipt信息htttp请求失败时，会触发重试逻辑，连续重试10次。</li></ul><p>盲目主要指的是，方案本身没有可靠的数据支撑，RD对于接入方案的效果没有预期，缺乏适当的技术埋点追踪接入后的效果。 </p><p>事实上，这两种方案并不能解决掉单问题，且都存在很大的问题：</p><ul><li>本地化存储：完全是无效的冗余逻辑，平白增加代码复杂度。</li><li>网络异常重试：由于缺乏恰当的实现，并不能对补单提供有力的保障。</li></ul><p>我们将通过与第一次优化方案的对比来详细阐述这两种方案所存在的问题。</p><h2 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h2><p>在翻阅IAP相关文档及明确了Keep客户端中存在的历史问题后，明确了从两个角度进行优化：</p><ul><li>程序健壮性：提升程序健壮性避免由于网络、crash等导致的掉单。</li><li>补单实时性：在异常发生时，保障大部分用户实时快速完成补单。</li></ul><p>同时，增加IAP支付流程各个阶段的埋点。为上线后的问题排查及优化效果统计打下基础。</p><h3 id="程序健壮性"><a href="#程序健壮性" class="headerlink" title="程序健壮性"></a>程序健壮性</h3><p>我们将IAP流程简化为如下： </p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/iap_pay_w.png" alt=""></p><p>从流程上来看，由于客户端导致的掉单有两种可能：</p><ol><li>步骤一：用户支付成功，Apple回调客户端通信失败。</li><li>步骤二：Apple回调客户端后，客户端与server通信失败。</li></ol><p>所以提升程序健壮性要从这两种掉单case入手。</p><h4 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h4><p>事实上，对于以上两种掉单case，Apple已经为我们提供了合理的解决方案。</p><p>IAP中每一次支付行为都被抽象成一个事务（SKPaymentTransaction），只有事务被正常完结（调用finishTransaction:）本次支付行为才算完成。在每一次app启动时，通过调用addTransactionObserver:就会触发之前所有未完结的事务。详见：支付队列观察者 。所以，由于事务机制的存在，我们只需做到以下两点就可以避免掉单：</p><ol><li>对于每一个支付事务，在确保服务端处理完后再结束（finishTransaction:）该事务。</li><li>App启动时，注册支付队列观察者（addTransactionObserver:）并添加相应补单逻辑。</li></ol><p>依赖于Apple提供的事务机制显然比本地化存储方案更加可靠，主要体现在以下几点：</p><ol><li>本地化存储只能解决“客户端与server通信失败”的掉单场景。</li><li>本地化存储的数据会随着用户设备更换、app删除重装而丢失而Apple的事务机制不会。</li></ol><p>可以看到，本地化存储解决的掉单场景是Apple所提供支付队列观察者能解决场景的子集。</p><p>所以第一个优化点在于：依靠Apple的事务机制，同时删除冗余的本地化存储方案。 </p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>我们追踪了最近一个月内所有用户支付成功的订单中，通过Apple提供的事务机制恢复的订单。得到如下结论：通过事务机制恢复的订单占总支付成功订单的4.78‰。即，通过第一次优化我们将掉单率降低了4.78‰。</p><h3 id="补单实时性"><a href="#补单实时性" class="headerlink" title="补单实时性"></a>补单实时性</h3><p>事务机制有一个明显的弊端：补单逻辑只有在app重启时才能触发。 重启app对于用户来说是一个很重的操作。我们希望添加某种机制更实时的为用户进行补单，于是我们引入了“网络异常重试逻辑”以提升补单效率，做为事务机制的一个补充。</p><h4 id="网络异常重试"><a href="#网络异常重试" class="headerlink" title="网络异常重试"></a>网络异常重试</h4><p>网络异常重试，主要是为了避免在付款成功后，用户网络状况发生变化（如，乘坐地铁进入隧道）导致与server通信失败的及时重试逻辑。</p><p>网络异常重试，主要是为了避免在付款成功后，用户网络状况发生变化（如，乘坐地铁进入隧道）导致与server通信失败的及时重试逻辑。</p><p>该方案本身没有太大问题，在较低的接入成本与影响面下可以很大程度的提升补单的实时性，是app启动时事务机制补单逻辑的一个很好的补充。不过，需要恰当的实现才能达到最优的效果。</p><p>之前Keep的实现方案是：初始化一个计数器，在网络请求失败的回调内累加计数器并触发重试逻辑，直至重试10次后放弃重试。</p><p>在实际测试过程中在断网的状况下，发出去的网络请求会立刻拿到失败回调，10次重试请求会在1s内发完。所以该方案能达到的效果被大打折扣。</p><p>解决方案当然是拉长重试间隔，另外，由于用户网络恢复的可能是随着时间逐渐递减的，为了避免频繁的重试我们不妨依次延长每一次重试的间隔。Keep目前的方案是以斐波那契数列来做为每一次重试的间隔，即10次重试的间隔分别是：</p><ul><li>1，1，2，3，5，8，13，21，34，55 </li></ul><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>下表是包含首次校验receipt失败（checkOrder_Failed）在内的，触发网络异常重试逻辑的埋点：</p><p>PS：以下数据没有考虑在重试过程中app异常关闭或用户手动关闭app</p><table><thead><tr><th>事件</th><th>次数</th></tr></thead><tbody><tr><td>checkOrder_Failed</td><td>332</td></tr><tr><td>checkOrder_Failed_Retry_1</td><td>166</td></tr><tr><td>checkOrder_Failed_Retry_2</td><td>127</td></tr><tr><td>checkOrder_Failed_Retry_3</td><td>122</td></tr><tr><td>checkOrder_Failed_Retry_4</td><td>103</td></tr><tr><td>checkOrder_Failed_Retry_5</td><td>85</td></tr><tr><td>checkOrder_Failed_Retry_6</td><td>69</td></tr><tr><td>checkOrder_Failed_Retry_7</td><td>52</td></tr><tr><td>checkOrder_Failed_Retry_8</td><td>34</td></tr><tr><td>checkOrder_Failed_Retry_9</td><td>23</td></tr><tr><td>checkOrder_Failed_Retry_10</td><td>15</td></tr></tbody></table><p>在所有首次校验（checkOrder_Failed）失败的332笔订单下，经过10次重试（checkOrder_Failed_Retry_10）后只有15笔订单需要用户重启app来触发补单逻辑。 这样在大概两分半的时间内，通过10次重试，我们追回了95.5%的失败用户为补单的实时性提供了有力的保障。</p><h3 id="本地化存储-amp-补单实时性？"><a href="#本地化存储-amp-补单实时性？" class="headerlink" title="本地化存储 &amp; 补单实时性？"></a>本地化存储 &amp; 补单实时性？</h3><p>通过本地化存储我们可以在更多的时机来触发补单逻辑以提升补单实时性。如：网络切换、app前后台切换。这里需要权衡的点是：</p><ul><li>本地化存储、网络切换，app前后台切换逻辑会影响到百分之百的用户（包括非付费用户），同时会有一定的开发维护成本。</li><li>在加入恰当的网络异常重试逻辑后，网络切换、app前后台切换的补单逻辑能帮助到的用户只有IAP付费用户的万分之几。</li></ul><p>当我们把影响范围的基数放在所有日活用户上后，这种方案的收益比可能只有几十/几百万分之一。所以，Keep目前并没有接入这种方案，补单逻辑只是依赖Apple在app启动时的事务机制。 </p><h2 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h2><p>第一次优化上线不久：客服再次反馈IAP支付掉单问题。而且由于业务膨胀式的发展，虽然优化掉了约千分之五的掉单case每天掉单的数量反而在上升。 </p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>收拾了一下心情，继续整理了接下来的工作思路：</p><ol><li>通过埋点及用户的反馈信息分析用户掉单原因。</li><li>收集信息撰写TSI联系Apple寻求技术支持。</li><li>与同行进行沟通，如何解决掉单问题。</li></ol><p>得到了如下的信息反馈：</p><ol><li>对于反馈用户的订单号，通过埋点查看走到了支付失败的回调中。</li><li>TSI得到的反馈是：在收到用户支付成功请求后一定会对客户端下发支付成功的回调，且在我们没有调用（finishTransaction:）结束该事务的情况下，会持续在每一次app启动时调用支付成功回调。</li><li>在与国内两个直播平台的员工进行沟通后：得到的反馈是，的确有丢单的状况。多次排查无果后，主要措施是由人工客服介入补单来处理。</li></ol><p>不难看出，对于1、2两条信息是矛盾的。不过，在后续的排查过程中还是选择了相信用户的诚信以及Apple的技术能力。站在另一个角度去审视自己的代码。 </p><h3 id="抽丝剥茧"><a href="#抽丝剥茧" class="headerlink" title="抽丝剥茧"></a>抽丝剥茧</h3><p>在选择相信用户和苹果的基础上，以Apple的事务机制来套有两点是可以肯定的：</p><ol><li>在用户支付成功后，Apple回调了支付成功的逻辑。</li><li>在处理该笔订单的过程中，客户端一定调用了（finishTransaction:）结束该事务。</li></ol><p>所以客户端的排查点就在于：在除了服务端处理完后，还有哪些地方调用了finishTransaction:？</p><p>终于，在转换思路后一个隐藏的bug浮出水面————在收到Apple支付成功回调后，客户端会首先校验业务OrderNo的合法性，如果orderNo为空，会直接调用（finishTransaction:）结束该事务，从而导致掉单！</p><h4 id="业务OrderNo"><a href="#业务OrderNo" class="headerlink" title="业务OrderNo"></a>业务OrderNo</h4><p>Keep的业务实现逻辑是，在用户发起购买时会生成对应的OrderNo，OrderNo将在整个购买流程中进行透传，直至用户支付成功后的receipt校验。且整个支付流程中在与Apple交互的过程中，通过Apple“提供”（注意这里的引号）的SKPayment的applicationUsername来传递。</p><p>Iap支付的订单流转逻辑：</p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/client_orderNo.png" alt=""></p><p>所以问题的症结在于，我们使用applicationUsername透传OrderNo合理么？</p><p>那么Apple对于applicationUsername定义是什么？</p><blockquote><p>Use this property to help the store detect irregular activity. For example, in a game, it would be unusual for dozens of different iTunes Store accounts to make purchases on behalf of the same in-game character.</p></blockquote><blockquote><p>The recommended implementation is to use a one-way hash of the user’s account name to calculate the value for this property.</p></blockquote><p>Apple提供applicationUsername，是为了防止用户作弊而不是用于透传业务信息的。所以，归根结底产生bug的原因还是我们开发者滥用API（目前网上依然有很多IAP相关的讨论、博客都是使用applicationUsername来透传业务信息）。</p><h3 id="复现及分析"><a href="#复现及分析" class="headerlink" title="复现及分析"></a>复现及分析</h3><p>在上述猜想的基础上，在线上环境下测试了一些边界情况成功复现了掉单case（必须为线上正式包，沙盒环境无法复现，testflight无法复现）。</p><h4 id="复现步骤："><a href="#复现步骤：" class="headerlink" title="复现步骤："></a>复现步骤：</h4><ol><li>itunes store 登入的appleId未绑定支付方式</li><li>发起支付</li><li>绑定支付方式并杀死keep app</li><li>在appStore完成完成支付</li><li>重启app</li></ol><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>在这种case下，在应用内我们收到的回调状态是这样的：</p><ol><li>Purchasing （Keep app 发起，携带OrderNo）</li><li>Failed（Keep app 发起，携带OrderNo）</li><li>用户绑定支付方式</li><li>Purchasing（AppStore 发起，不携带OrderNo）</li><li>Purchased（AppStore 发起，不携带OrderNo）</li></ol><p>用户分别在Keep、AppStore各发起了一次支付。</p><ul><li>Keep内发起的支付：创建了OrderNo，也完成了对于applicationUsername的赋值，但是由于用户没有绑定支付方式该笔订单以失败结束，所以我们会收到相应失败的回调。</li><li>AppStore内发起的支付：用户支付成功了，但是并没有创建OrderNo，也没有完成对于applicationUsername的赋值，所以在Apple回调支付成功后，没有解析到OrderNo。调用（finishTransaction:）结束该事务后产生掉单。</li></ul><h3 id="订单创建后置"><a href="#订单创建后置" class="headerlink" title="订单创建后置"></a>订单创建后置</h3><p>Keep目前采用的解决方案是，对于未生成OrderNo的订单，采用订单创建后置来处理：</p><h4 id="KeepClient"><a href="#KeepClient" class="headerlink" title="KeepClient"></a>KeepClient</h4><ul><li>客户端去掉OrderNo校验逻辑</li></ul><h4 id="KeepServer"><a href="#KeepServer" class="headerlink" title="KeepServer"></a>KeepServer</h4><ul><li>校验接口的OrderNo改为非必传参数</li><li>支付网关层校验成功后, 发送mq消息给业务方</li><li>业务方收到消息后进行模拟提单</li><li>交易中心完结订单</li><li>交易中心回调业务方接口</li><li>业务方发放权益</li></ul><p>KeepServer订单流转如下图(TradeCenter=交易中心 PayGateway=支付网关):</p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/server_order.png" alt=""></p><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p>同样我们以记一个月所有用户支付成功的订单为样本。通过订单创建后置恢复的订单占总支付成功订单的5.25‰。即，通过此次优化IAP掉单率降低了5.25‰，完美解决了客户端的掉单问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;In-App Purchase（以下简称IAP）是苹果为开发者提供的应用内购服务。Keep于17年初接入In-App Purchase，功能上线后暴漏出严重的丢单问题，丢单概率大概在百分之一。丢单问题在多人多次优化后仍未能解决，成为Keep客户端的顽疾。直至最近的两次优化彻底根治了丢单问题。本文中笔者将循着Keep客户端解决IAP掉单问题的两次优化之旅跟大家分享排查问题的思路以及最终的方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="业务实践 IAP" scheme="http://yoursite.com/tags/%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5-IAP/"/>
    
  </entry>
  
  <entry>
    <title>Work with compiler------premain启动优化</title>
    <link href="http://yoursite.com/2019/03/10/Work-with-compiler-premain%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/10/Work-with-compiler-premain启动优化/</id>
    <published>2019-03-10T05:44:45.000Z</published>
    <updated>2019-07-15T09:37:18.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>在Xcode中构建的程序，经由预处理、编译、汇编、链接将源文件（.m和.h文件）转变为Mach-O 二进制可执行文件。Mach-O 中代码被划分为不同的Segment，而每个Segment又包含多个Section。</p><p>Mach-O的架构：</p><p><img src="/2019/03/10/Work-with-compiler-premain启动优化/mach-o.png" alt=""></p><a id="more"></a><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>执行一个可执行文件时。虚拟内存系统会将Segment映射到进程的地址空间。在虚拟内存系统进行映射时，不同的Segment会以不同的参数（权限）被映射。常见的Segment有：</p><ul><li>__TEXT ：__TEXT段包含了可执行的代码。它们被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。</li><li>__DATA：程序数据段以可读写但不可执行的方式映射。（本文讨论的重点）。</li><li>__PAGEZERO:　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。</li><li>__LINKEDIT:　链接器使用的符号以及其他表。</li></ul><h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>Section 是具体有用的数据存放的地方，下表列出了<strong>DATA 和 </strong>TEXT下的Section：</p><p><img src="/2019/03/10/Work-with-compiler-premain启动优化/section_text.png" alt=""></p><p><img src="/2019/03/10/Work-with-compiler-premain启动优化/section_data.png" alt=""></p><h3 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h3><p>__attribute__是一种编译器指令，可以让编译器做更多地错误检查和代码优化，其中就包括大家常见的废弃掉方法、类或者变量的指令__attribute__ ((deprecated(“”)))。</p><p>__attribute__的一般语法形式是__attribute__关键字后面跟两个小括号，在小括号里是逗号分隔的选项。这里我们重点关注<a href="https://clang.llvm.org/docs/AttributeReference.html#section-gnu-section-declspec-allocate" target="_blank" rel="noopener">section() 函数</a>。</p><h4 id="section-函数"><a href="#section-函数" class="headerlink" title="section() 函数"></a>section() 函数</h4><p>前面提到__DATA段为可读写程序数据段，而section() 函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。在阅读runtime源码的过程中，可以发现苹果大量利用__attribute__和section()函数在编译器将数据写入__DATA段。</p><p>比如，下述代码编译器在__DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组，用于运行期category的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，我们也可以利用__attribute__和section()将数据提前写入__DATA段，以达到程序优化的目的（比如，去+load）。+load()提供了一个非常靠前的执行时机，在实际开发中很多基础库的初始化工作都集中在这个时机执行。而过重的+load()会拖慢程序的premain的加载时间，有了上述的理论基础我们可以在将相关初始化工作封装在函数内并在编译期将相关函数指针写入__DATA段，从而达到延迟加载的效果，节省启动时间。</p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>受够了理论基础，是时候敲一段代码了~ ，以下代码我们在__DATA段新增section __bwkcfunction__，并将func()的函数指针写入__bwkcfunction__中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (* BWKCFunction) (void);</span><br><span class="line"></span><br><span class="line">void func (void)&#123;</span><br><span class="line">    printf(&quot;hello world in c fun&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  main ()&#123;</span><br><span class="line">    __attribute__((used,section(&quot;__DATA&quot;&quot;,&quot;&quot;__bwkcfunction__&quot;))) static const BWKCFunction cfunc = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们通过命令行编译该代码生成可执行文件a.out（a.out 是clang的默认命名）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang test_attribute.c</span><br></pre></td></tr></table></figure><p>最后通过命令行看一下我们的成果吧~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun size -x -l -m a.out </span><br><span class="line"></span><br><span class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</span><br><span class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</span><br><span class="line">    Section __text: 0x26 (addr 0x100000f50 offset 3920)</span><br><span class="line">    Section __stubs: 0x6 (addr 0x100000f76 offset 3958)</span><br><span class="line">    Section __stub_helper: 0x1a (addr 0x100000f7c offset 3964)</span><br><span class="line">    Section __cstring: 0x16 (addr 0x100000f96 offset 3990)</span><br><span class="line">    Section __unwind_info: 0x48 (addr 0x100000fac offset 4012)</span><br><span class="line">total 0xa4</span><br><span class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</span><br><span class="line">    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</span><br><span class="line">    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</span><br><span class="line">    Section __bwkcfunction__: 0x8 (addr 0x100001018 offset 4120)</span><br><span class="line">total 0x20</span><br><span class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</span><br><span class="line">total 0x100003000</span><br></pre></td></tr></table></figure><p>可以看到，在<em>DATA段，我们成功插入了\</em>_bwkcfunction__ section，且该section的大小为8字节（一个c语言指针的大小）。然后我们就可以在程序运行的过程中在需要的时候取出对应的函数指针，从而实现懒加载~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mach-O&quot;&gt;&lt;a href=&quot;#Mach-O&quot; class=&quot;headerlink&quot; title=&quot;Mach-O&quot;&gt;&lt;/a&gt;Mach-O&lt;/h3&gt;&lt;p&gt;在Xcode中构建的程序，经由预处理、编译、汇编、链接将源文件（.m和.h文件）转变为Mach-O 二进制可执行文件。Mach-O 中代码被划分为不同的Segment，而每个Segment又包含多个Section。&lt;/p&gt;
&lt;p&gt;Mach-O的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/10/Work-with-compiler-premain启动优化/mach-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa简介</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/</id>
    <published>2019-03-10T05:42:27.000Z</published>
    <updated>2019-03-10T05:44:22.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>是一个将函数响应式编程范例带入Objective-C的开源库。由<a href="https://github.com/joshaber" target="_blank" rel="noopener">Josh Abernathy</a>和<a href="https://github.com/jspahrsummers" target="_blank" rel="noopener">Justin Spahr-Summers</a>在对<a href="https://mac.github.com/" target="_blank" rel="noopener">GitHub for Mac</a>的开发过程中产生的副产物。RAC富含cocoa框架多种组件，提供基于时间变化的数据流的组合和变换。</p><a id="more"></a><h3 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h3><p>函数响应式编程是思考软件将输入转化为输出在时间上的持续过程的一种方式。它糅合了函数式编程和响应式编程的特点，满足函数式编程的一些特性，将时间轴上的离散事件通过响应式编程的数据流向下传播的一种编程范式。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/frp.png" alt=""></p><p>先来看一下什么是函数式编程/响应式编程。</p><h3 id="函数式编程（FP）"><a href="#函数式编程（FP）" class="headerlink" title="函数式编程（FP）"></a>函数式编程（FP）</h3><p>函数式编程是一种编程范式，它将电脑运算视为数学上的函数计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p><p>在之前的一篇文章里对FP做了更详尽的剖析，这里就不多做解读。（强烈建议阅读继续阅读之前阅读该篇文章）。</p><h3 id="响应式编程-RP"><a href="#响应式编程-RP" class="headerlink" title="响应式编程 (RP)"></a>响应式编程 (RP)</h3><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态数据流，而相关计算模型会自动将变化的值通过数据流进行传播。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><blockquote><p>命令式编程环境中<br>a ＝ b ＋ c<br>赋值之后b或c的值变化后，a的值不会跟着变化<br>而在响应式编程中，a的值会随着b或c的更新而更新。</p></blockquote><p>Excel就是响应式编程的另一个例子。对数据进行求和或求均值操作，包含公式结果的单元格的值会根据其他单元格的值的变化而变化。</p><p>iOS开发中的Autolayout也是响应式编程的一个例子。当父View的位置发生变化，根据相互之间的关系Constraint，子View的frame也会随之变化。</p><h3 id="为什么使用FRP"><a href="#为什么使用FRP" class="headerlink" title="为什么使用FRP"></a>为什么使用FRP</h3><p>函数式响应编程提高了代码抽象层次，所以我们可以只关注定义了业务逻辑的那些相互依赖的事件，而非纠结于大量的实现细节。FRP的代码往往会更加简明。</p><p>特别是在开发现在这些有着大量与数据事件相关的 UI events 的高互动性 Webapps、手机 apps 的时候，FRP 的优势就更加明显。10年前，网页的交互就只是提交一个很长的表单到后端，而在前端只产生简单的渲染。Apps 就表现得更加的实时了：修改一个表单域就能自动地把修改后的值保存到后端，为一些内容”点赞”时，会实时的反应到其它在线用户那里等等。</p><p>现在的 Apps 有着大量各种各样的实时 Events，以给用户提供一个交互性较高的体验。我们需要工具去应对这个变化，而函数响应式编程就是一个答案。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>示例引用于：<a href="https://zhuanlan.zhihu.com/p/27678951" target="_blank" rel="noopener">响应式编程介绍</a></p><p>假设我们想要得到一个包含”双击”事件的Stream。为了使它更有趣，假设我们想要这个Stream要同时考虑三击，或更加宽泛，连击。想象一下在传统的命令式编程中应该怎样实现。我敢打赌代码会像一团乱麻，并且会使用一些变量保存状态，同时也有一些计算时间间隔的代码。</p><p>而在响应式编程中，这个功能的实现就非常简单。事实上，这逻辑只有四行代码。但现在我们不管这些代码。用图表的方式思考是理解怎样构建Stream的最好方法。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/Click_Stream.png" alt=""></p><p>灰色的方框是用来转换 Stream 函数的。</p><ul><li>首先，简而言之，我们把连续 250 ms 内的 Click 都积累到一个列表中（就是 buffer(stream.throttle(250ms) 做的事),结果是一个列表的 Stream。</li><li>然后我们使用 map() 把每个列表映射为一个整数，即它的长度。</li><li>最终，我们使用 filter(x &gt;= 2) 把整数 1 给过滤掉。就这样，3 个操作就生成了我们想要的 Stream。</li><li>然后我们就可以订阅(“监听”)这个 Stream，并以我们所希望的方式作出反应。</li></ul><p>我希望你能感受到这个示例的优美之处。这个示例只是冰山一角：你可以把同样的操作应用到不同种类的 Stream 上，例如，一个 API 响应的 Stream；另一方面，还有很多其它可用的函数。</p><h3 id="基于时间变化的数据流"><a href="#基于时间变化的数据流" class="headerlink" title="基于时间变化的数据流"></a>基于时间变化的数据流</h3><p>前面提到，RAC提供基于时间变化的数据流的组合和变化，那么什么是基于时间变化的数据流？</p><h4 id="连续数据流-amp-离散数据流"><a href="#连续数据流-amp-离散数据流" class="headerlink" title="连续数据流 &amp; 离散数据流"></a>连续数据流 &amp; 离散数据流</h4><p>数组就是一个最简单的数据流，数组内的值是连续的。而基于时间变化的数据流在一个事件范围内以离散形式存在。如鼠标的点击事件，我们将点击鼠标的事件采集起来就能够得到一个基于时间变化的数据流。如图：</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_1.png" alt=""></p><h4 id="多维数组-amp-多维数据流"><a href="#多维数组-amp-多维数据流" class="headerlink" title="多维数组 &amp; 多维数据流"></a>多维数组 &amp; 多维数据流</h4><p>C语言中数组内的元素可以是数组形成多维数组。相似的数据流内元素也可以是一个数据流形成多维数据流，如图：</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_2.png" alt=""></p><h3 id="数据流的操作"><a href="#数据流的操作" class="headerlink" title="数据流的操作"></a>数据流的操作</h3><p>RAC提供了对数据流的组合和变换，我们可以对数据流进行一定的操作得到新的流如：</p><ul><li>对值操作得到新的流</li><li>对值的数量进行操作得到新的流</li><li>对维度操作得到新的流</li><li>对时间间隔进行操作得到新的流</li></ul><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_operation.png" alt=""></p><p>除此之外我们还可以对多个流进行合并、变换等操作</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_merge.png" alt=""></p><h3 id="RAC的核心组件"><a href="#RAC的核心组件" class="headerlink" title="RAC的核心组件"></a>RAC的核心组件</h3><p>这里对RAC的核心组件做简要介绍，在后续的学习过程中会做更深入整理</p><h4 id="RACSteam"><a href="#RACSteam" class="headerlink" title="RACSteam"></a>RACSteam</h4><p>RACSteam是RAC对数据流的抽象，提供了一些抽象的接口，其功能主要体现在其两个子类RACSignal（离散数据流）和RACSequence（连续数据流）。</p><p>我们从两个角度分析一个RACSignal 和 RACSequence</p><h5 id="Data-vs-Event"><a href="#Data-vs-Event" class="headerlink" title="Data vs Event"></a>Data vs Event</h5><p>RACSequence：处理的是数据，表示一个序列，里面存放的是一系列的数据，类似数组。<br>RACSignal：处理的是事件，值事件、错误事件、终止事件。</p><h5 id="pullDriver-vs-pushDriver"><a href="#pullDriver-vs-pushDriver" class="headerlink" title="pullDriver vs pushDriver"></a>pullDriver vs pushDriver</h5><p>RACSignal的数据驱动类型是pushDriver;那么什么是pushDriver？</p><ul><li>从值的创建角度：pushDriver意味着信号的值在创建时没有被定义，并可能在稍后的时间里产生信号的值。例如：网络请求或任何用户输入。</li><li>从值的传递角度：每当产生新的信号都会，信号源就会给订阅者发送数据。对于数据调取者是被动接受的。  </li></ul><p>RACSequence的数据驱动类型是pullDriver;那么什么是pullDriver？</p><ul><li>从值的创建角度：pullDriver意味着信号的值在创建的时候就被定义。例如：数组里的值。</li><li>从值的传递角度：任何时间想要拿到数据调取者都可以从数据流里拉取数据。整个时间控制掌握在调取者手中。  </li></ul><p>pushDriver可以理解为看电视，pullDriver可以理解为看书。</p><h4 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h4><p>RACSubscriber对象是RACSignal的订阅者，负责处理RACSignal传出的数据。RACSubscriber对象初始化的时候回传入的nextBlock、 errorBlock、completeBlock分别处理RACSignal的值事件、错误事件、终止事件。</p><h4 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h4><p>RACSubscriber在对事件进行订阅时会返回RACDisposable对象，可以通过RACDisposable来终止对信号的订阅。</p><h4 id="RACScheduler"><a href="#RACScheduler" class="headerlink" title="RACScheduler"></a>RACScheduler</h4><p>RACScheduler底层是RAC对GCD的封装，是RAC中负责任务调度的调度器。 RACScheduler通过对GCD封装让并发编程与RAC高度整合。使RAC的使用者更畅快的沉浸在FRP的世界里。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://zhuanlan.zhihu.com/p/27678951" target="_blank" rel="noopener">响应式编程介绍</a><br><a href="https://www.zhihu.com/question/26079335/answer/32084850" target="_blank" rel="noopener">函数式响应型编程(Functional Reactive Programming)会在什么问题上有优势?</a><br> <a href="https://stackoverflow.com/questions/28952900/what-is-the-difference-between-racsequence-and-racsignal" target="_blank" rel="noopener">What is the difference between RACSequence and RACSignal</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactiveCocoa&lt;/a&gt;是一个将函数响应式编程范例带入Objective-C的开源库。由&lt;a href=&quot;https://github.com/joshaber&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Josh Abernathy&lt;/a&gt;和&lt;a href=&quot;https://github.com/jspahrsummers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Justin Spahr-Summers&lt;/a&gt;在对&lt;a href=&quot;https://mac.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub for Mac&lt;/a&gt;的开发过程中产生的副产物。RAC富含cocoa框架多种组件，提供基于时间变化的数据流的组合和变换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa高阶操作</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/</id>
    <published>2019-03-10T05:40:33.000Z</published>
    <updated>2019-03-10T05:42:01.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>延续上一篇ReactiveCocoa操作详解,本篇笔者围绕针对RAC信号的维度变换（升阶、降阶）进行深入探究，同时在文章结尾给出Functor、Applicatives和Monad的概念。</p><a id="more"></a><h3 id="升阶-amp-降阶"><a href="#升阶-amp-降阶" class="headerlink" title="升阶 &amp; 降阶"></a>升阶 &amp; 降阶</h3><p>在ReactiveCocoa简介中，笔者提到类似C语言中的多维数组,RAC中同样存在多维信号的概念。多维信号发送的每一个值都是一个信号，为方便后续交流笔者将其称为“值信号”。本篇中以大写英文字母“A、B、C”表示值信号，以阿拉伯数字“1、2、3”表示普通值。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/up-down.png" alt=""></p><h3 id="高阶信号"><a href="#高阶信号" class="headerlink" title="高阶信号"></a>高阶信号</h3><h4 id="高阶信号的创建"><a href="#高阶信号的创建" class="headerlink" title="高阶信号的创建"></a>高阶信号的创建</h4><p>通过return创建一个返回信号的信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal return:@1];</span><br><span class="line">RACSignal *signalHighOrder = [RACSignal return:signal];</span><br></pre></td></tr></table></figure><p>通过map变换返回一个信号，达到对信号升阶的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *anotherSignal = [signal map:^id(id value) &#123;</span><br><span class="line">return [RACSignal return:value];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="高阶信号的订阅"><a href="#高阶信号的订阅" class="headerlink" title="高阶信号的订阅"></a>高阶信号的订阅</h4><p>通过嵌套订阅拿到真正的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[highOrderSignal subscribeNext:^(RACSignal *aSignal) &#123;</span><br><span class="line">[aSignal subscribeNext:^(id x) &#123;</span><br><span class="line">// get real value here.</span><br><span class="line">&#125;];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><h3 id="降阶操作"><a href="#降阶操作" class="headerlink" title="降阶操作"></a>降阶操作</h3><p>通过map升阶将值转换为值信号，在实际应用中最终还是需要获得值。RAC为我们提供了多种降阶操作以满足不同的场景。</p><h4 id="SwitchToLatest"><a href="#SwitchToLatest" class="headerlink" title="SwitchToLatest"></a>SwitchToLatest</h4><p>switchToLatest操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。switchToLatest将原信号输出的最新的值信号的next事件和error事件作为新信号的next时间和error事件输出。</p><ul><li>Next事件：输出原信号输出的最新值信号的next事件。</li><li>Error事件：输出原信号输出的最新值信号的error事件、同时会在原信号输出error事件。</li><li>Completed事件：取原信号的completed事件和原信号的最后一个值信号的completed事件的在时间维度上较晚发出者。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/switchTolatest.png" alt=""></p><h5 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h5><p>为突出信号A、B、C在时间维度发送事件的先后顺序，这里使用RACSignal的子类代替RACSubject。RACSubject与RACSignal稍有不同，在后续冷热信号中会详细探讨。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject * signalA = [RACSubject subject];</span><br><span class="line">RACSubject * signalB = [RACSubject subject];</span><br><span class="line">RACSubject * signalC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals switchToLatest] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 3 5 7 8</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@1];</span><br><span class="line">[signalOfSignals sendNext:signalB];</span><br><span class="line"></span><br><span class="line">[signalA sendNext:@2];</span><br><span class="line">[signalB sendNext:@3];</span><br><span class="line">[signalA sendNext:@4];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalC];</span><br><span class="line">[signalA sendCompleted];</span><br><span class="line">[signalC sendNext:@5];</span><br><span class="line">[signalB sendNext:@6];</span><br><span class="line">[signalB sendCompleted];</span><br><span class="line">[signalOfSignals sendCompleted];</span><br><span class="line">[signalC sendNext:@7];</span><br><span class="line">[signalC sendNext:@8];</span><br><span class="line">[signalC sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="If-then-else"><a href="#If-then-else" class="headerlink" title="If:then:else"></a>If:then:else</h4><p>If:then:else操作基于boolSignal发送的最新值，在tureSignal、falseSignal之间切换。<br>要求boolSignal的值必须为NSNumber类型，且boolSignal、tureSignal、falseSignal均不为nil。<br>If:then:else操作其实是一个语法糖，底层使用switchToLatest实现。</p><ul><li>Next事件：boolSignal发送ture，输出tureSignal信号的next事件；boolSignal发送false，输出falseSignal信号的next事件。</li><li>Error事件：boolSignal发送ture，输出tureSignal信号的error事件；boolSignal发送false，输出falseSignal信号的error事件。</li><li>Completed事件：当boolSignal与当前选中信号都发送completed事件后，发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/if-then-else.png" alt=""></p><h5 id="Coding-1"><a href="#Coding-1" class="headerlink" title="Coding"></a>Coding</h5><p>为突出时间概念同样使用RACSubject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * boolSignal = [RACSubject subject];</span><br><span class="line">RACSubject * signalTure = [RACSubject subject];</span><br><span class="line">RACSubject * signalFalse = [RACSubject subject];</span><br><span class="line">RACSignal * resultSignal = [RACSignal if:boolSignal then:signalTure else:signalFalse];</span><br><span class="line"></span><br><span class="line">[resultSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 2 c d 5 6 g h</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@YES];</span><br><span class="line">[signalTure sendNext:@1];</span><br><span class="line">[signalTure sendNext:@2];</span><br><span class="line">[signalFalse sendNext:@&quot;a&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;b&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@NO];</span><br><span class="line">[signalTure sendNext:@3];</span><br><span class="line">[signalTure sendNext:@4];</span><br><span class="line">[signalFalse sendNext:@&quot;c&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;d&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@YES];</span><br><span class="line">[signalTure sendNext:@5];</span><br><span class="line">[signalTure sendNext:@6];</span><br><span class="line">[signalFalse sendNext:@&quot;e&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;f&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@NO];</span><br><span class="line">[signalTure sendNext:@7];</span><br><span class="line">[signalTure sendNext:@8];</span><br><span class="line">[signalFalse sendNext:@&quot;g&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;h&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendCompleted];</span><br><span class="line">[signalFalse sendCompleted];</span><br><span class="line">[signalTure sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><p>concat操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。<br>链接原信号发送的所有值信号,注意与ReactiveCocoa操作详解concat:相区分 。</p><ul><li>Next事件：依次发送值信号的next事件，在当前订阅值信号发送completed事件后，开始发送下一个值信号的next事件。</li><li>Error事件：输出值信号的error事件，同时会在原信号输出error事件。</li><li>Completed事件：原信号和当前订阅值信号均发送completed事件后，输出completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/concat1.png" alt=""></p><h5 id="Coding-2"><a href="#Coding-2" class="headerlink" title="Coding"></a>Coding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signalOfSignals = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    RACSignal * signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">        [subscriber sendNext:@4];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal * signalB = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;a&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;b&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;c&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;d&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] deliverOn:[RACScheduler scheduler]] ;</span><br><span class="line">    </span><br><span class="line">    [subscriber sendNext:signalA];</span><br><span class="line">    [subscriber sendNext:signalB];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals concat] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 2 3 4 a b c d </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h5><p>利用concat实现1秒延时信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = @[@1, @3, @7, @9, @8].rac_sequence.signal;</span><br><span class="line">RACSignal *timerSignal = [[signal map:^id(id value) &#123;</span><br><span class="line"> return [[RACSignal return:value] delay:1];</span><br><span class="line">  &#125;] concat];</span><br></pre></td></tr></table></figure><h4 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h4><p>flatten操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。<br>对原信号进行降阶操作，对原信号输出的值信号输出的所有next事件、error事件作为新信号的事件按时间顺序依次输出。</p><ul><li>Next事件：按时间顺序依次输出原信号的值信号的next事件。</li><li>Error事件：输出原信号的值信号的error事件。</li><li>Completed事件：在所有信号均输出completed事件后输出completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/Flatten.png" alt=""></p><h5 id="Coding-3"><a href="#Coding-3" class="headerlink" title="Coding"></a>Coding</h5><p>为突出时间概念同样使用RACSubject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject * signalA = [RACSubject subject];</span><br><span class="line">RACSubject * signalB = [RACSubject subject];</span><br><span class="line">RACSubject * signalC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals flatten] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 3 5 7 8</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@1];</span><br><span class="line">[signalOfSignals sendNext:signalB];</span><br><span class="line"></span><br><span class="line">[signalA sendNext:@2];</span><br><span class="line">[signalB sendNext:@3];</span><br><span class="line">[signalA sendNext:@4];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalC];</span><br><span class="line">[signalA sendCompleted];</span><br><span class="line">[signalC sendNext:@5];</span><br><span class="line">[signalB sendNext:@6];</span><br><span class="line">[signalB sendCompleted];</span><br><span class="line">[signalOfSignals sendCompleted];</span><br><span class="line">[signalC sendNext:@7];</span><br><span class="line">[signalC sendNext:@8];</span><br><span class="line">[signalC sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="FlattenMap"><a href="#FlattenMap" class="headerlink" title="FlattenMap"></a>FlattenMap</h4><p>不止局限于RAC（例如：RxJava），flattenMap在整个函数式编程中也是一个重要的概念。以字面理解flattenMap是flatten操作和map操作的结合，事实上也的确如此。</p><h5 id="Flatten-amp-amp-Map"><a href="#Flatten-amp-amp-Map" class="headerlink" title="Flatten &amp;&amp; Map"></a>Flatten &amp;&amp; Map</h5><p>flattenMap的本质是map然后flatten：它首先利用map将值映射为信号（升阶），然后利用flatten进行降阶。这里只是说明功能，flattenMap的实现并不是通过调用map+flatten实现的。实质上flattenMap的map是通过在block生成中间信号M，flatten是在内部对中间信号进行订阅实现的。后续会对RAC源码进行更深入探究，这里只说明功能。</p><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>考虑将一个无效值转换为error事件，不止局限于理论在实际开发中我们也经常碰到这样的需求。</p><h6 id="Flatten-amp-amp-Map组合实现"><a href="#Flatten-amp-amp-Map组合实现" class="headerlink" title="Flatten &amp;&amp; Map组合实现"></a>Flatten &amp;&amp; Map组合实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = @[@1,@2,@3,@0].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">RACSignal * mappedSignal = [[signal map:^id(NSNumber * value) &#123;</span><br><span class="line">    if (value.integerValue == 0) &#123;</span><br><span class="line">        return [RACSignal error:[NSError errorWithDomain:@&quot;bosskai.com&quot; code:-1 userInfo:nil]];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]flatten] ;</span><br><span class="line"></span><br><span class="line">[mappedSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x); // output 1 2 3</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error); // Error Domain=bosskai.com Code=-1 &quot;(null)&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h6 id="FlattenMap实现"><a href="#FlattenMap实现" class="headerlink" title="FlattenMap实现"></a>FlattenMap实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = @[@1,@2,@3,@0].rac_sequence.signal;</span><br><span class="line"> </span><br><span class="line"> RACSignal * mappedSignal = [signal flattenMap:^RACStream *(NSNumber * value) &#123;</span><br><span class="line">     if (value.integerValue == 0) &#123;</span><br><span class="line">         return [RACSignal error:[NSError errorWithDomain:@&quot;booskai.com&quot; code:-1 userInfo:nil]];</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         return [RACSignal return:value];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> [mappedSignal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); // output 1 2 3</span><br><span class="line"> &#125; error:^(NSError *error) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,error); // Error Domain=bosskai.com Code=-1 &quot;(null)&quot;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><p>实际开发中其实有很多类似的需求，FlattenMap也提供了完美的支持。利用FlattenMap可以轻松的完成信号间的转换，而且FlattenMap是支持串行异步操作的。那么为什么说FlattenMap在函数是编程中也是一个重要的概念呢？因为FlattenMap满足Monad。</p><h3 id="Functor、Applicatives和Monad"><a href="#Functor、Applicatives和Monad" class="headerlink" title="Functor、Applicatives和Monad"></a>Functor、Applicatives和Monad</h3><p>Functor、Applicatives和Monad是函数式编程汇总三个非常重要的术语。计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：Functor、Applicatives和Monad。</p><p>本篇中笔者从结论出发让大家有一个大概的印象，在之后的一篇post中会从swift出发为大家做详细剖析。我们可以将Functor、Applicatives和Monad理解为协议，协议内容为满足某种操作。</p><p>Functor： 应用一个函数到封装后的对象，如RAC中的map。<br>Applicatives：应用一个封装后的函数到一个封装后的对象。RAC并未提供对Applicatives的支持。<br>Monad：应用一个返回封装后的对象的函数到一个封装后的对象。RAC中的flattenMap。</p><p>封装后的对象我们可以理解为，RAC中的Signal、swift中的Optional。有点绕~，先有个概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;延续上一篇ReactiveCocoa操作详解,本篇笔者围绕针对RAC信号的维度变换（升阶、降阶）进行深入探究，同时在文章结尾给出Functor、Applicatives和Monad的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa操作详解</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/</id>
    <published>2019-03-10T05:37:39.000Z</published>
    <updated>2019-03-10T05:40:08.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在之前的一篇Post中对函数响应式编程和RAC做了简单剖析,强烈建议没看过的同学猛戳链接。</p><p>ReactiveCocoa的核心是RACSignal类代表的信号。信号会产生一个事件流，事件有三种类型next、completed、error，一个信号源可以发送任意数量的next时间，直到该信号结束（completed）或因错误（error）而关闭。通过对信号的订阅可以获得不同事件的回调。使用这个简单的事件流模型，通过对信号的变换、组合操作，我们可以处理日常iOS开发中的按钮点击、网络请求响应、KVO或用户位置变化等各种事件类型。</p><p>本篇我们会围绕RACSignal的基本使用及各类操作做详细探究。</p><a id="more"></a><h3 id="RACSignal的创建"><a href="#RACSignal的创建" class="headerlink" title="RACSignal的创建"></a>RACSignal的创建</h3><p>RAC中我们可以通过以下几种方式获得一个信号。</p><h4 id="单元信号"><a href="#单元信号" class="headerlink" title="单元信号"></a>单元信号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal1 = [RACSignal return:@&quot;some Value&quot;];</span><br><span class="line">  RACSignal * signal2 = [RACSignal error:[NSError new]];</span><br><span class="line">  RACSignal * signal3 = [RACSignal empty];</span><br><span class="line">  RACSignal * signal4 = [RACSignal never];</span><br></pre></td></tr></table></figure><h4 id="动态信号"><a href="#动态信号" class="headerlink" title="动态信号"></a>动态信号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal5 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       [subscriber sendNext:@1];</span><br><span class="line">       [subscriber sendNext:@2];</span><br><span class="line">       [subscriber sendError:[NSError new]];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接"><a href="#Cocoa桥接" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIButton  * btn = [UIButton new];</span><br><span class="line">   RACSignal * signal6 = [btn rac_signalForSelector:@selector(setFrame:)];</span><br><span class="line">   RACSignal * signal7 = [btn rac_signalForControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">   RACSignal * signal8 = [btn rac_willDeallocSignal];</span><br><span class="line">   RACSignal * signal9 = RACObserve(btn, backgroundColor);</span><br></pre></td></tr></table></figure><h4 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal10 = [signal1 map:^id(NSString * value) &#123;</span><br><span class="line">      return [value substringFromIndex:1];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h4 id="序列转换"><a href="#序列转换" class="headerlink" title="序列转换"></a>序列转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACSequence * sequence = [RACSequence return:@1];</span><br><span class="line">   RACSignal * signal11 = sequence.signal;</span><br></pre></td></tr></table></figure><h3 id="信号的订阅方式"><a href="#信号的订阅方式" class="headerlink" title="信号的订阅方式"></a>信号的订阅方式</h3><h4 id="订阅方法"><a href="#订阅方法" class="headerlink" title="订阅方法"></a>订阅方法</h4><p>RAC的作者煞费苦心的为我们提供了对一个信号的next、error、completed三种事件的排列组合的订阅方法，这里列举一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[signal11 subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;next value is %@&quot;,x);</span><br><span class="line">   &#125; error:^(NSError *error) &#123;</span><br><span class="line">       NSLog(@&quot;Ops! Get some error:%@&quot;,error);</span><br><span class="line">   &#125; completed:^&#123;</span><br><span class="line">       NSLog(@&quot;It finished success&quot;);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(btn, backgroundColor)  = [RACSignal return:[UIColor redColor]];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接-1"><a href="#Cocoa桥接-1" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[btn rac_liftSelector:@selector(convertRect:toView:) withSignals:signal1, signal2,nil];</span><br></pre></td></tr></table></figure><h3 id="RACSignal各类操作"><a href="#RACSignal各类操作" class="headerlink" title="RACSignal各类操作"></a>RACSignal各类操作</h3><p>引用一张上一篇Post中的图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/stream_operation.png" alt=""></p><p>本篇文章主要围绕对值操作、对数量操作、对时间间隔操作及多个信号间的组合变换做深入探究，对维度的操作的探究会放在后续的文章中。</p><p>在深入下去之前，需要先了解一下RACTuple，RAC中很多操作都会用到或产生RACTuple。</p><h4 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h4><p>RACTuple（元组类）是RAC中的集合类，其底层实现是对NSArray的封装。RACTuple有以下特点：</p><ul><li>遵循NSFastEnumeration协议（可用for in枚举）</li><li>遵循NSCopy协议</li><li>遵循NSCoding协议</li><li>实现了objectAtIndexedSubscript:方法（可用下标访问元素）</li><li>可把NSNull.null转为RACTupleNil.tupleNil</li><li>封装了一系列遍历的集合操作方法</li></ul><h5 id="RACTuple的简单使用方式："><a href="#RACTuple的简单使用方式：" class="headerlink" title="RACTuple的简单使用方式："></a>RACTuple的简单使用方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//普通创建 </span><br><span class="line"> RACTuple *tuple1 = [RACTuple tupleWithObjects:@1, @2, @3, nil];</span><br><span class="line"> RACTuple *tuple2 = [RACTuple tupleWithObjectsFromArray:@[@1, @2, @3]];</span><br><span class="line"> RACTuple *tuple3 = [[RACTuple alloc] init]; </span><br><span class="line"></span><br><span class="line">//宏创建</span><br><span class="line"> RACTuple *tuple4 = RACTuplePack(@1, @2, @3, @4); </span><br><span class="line"></span><br><span class="line">//解包(等号前面是参数定义，后面是已存在的Tuple，参数个数需要跟Tuple元素相同）</span><br><span class="line"> RACTupleUnpack(NSNumber * value1, NSNumber * value2, NSNumber * value3, NSNumber * value4) = tuple4; </span><br><span class="line"></span><br><span class="line">//元素访问方式</span><br><span class="line"> NSLog(@&quot;%@&quot;, [tuple4 objectAtIndex:1]); NSLog(@&quot;%@&quot;, tuple4[1]);</span><br></pre></td></tr></table></figure><h3 id="RACSignal的操作"><a href="#RACSignal的操作" class="headerlink" title="RACSignal的操作"></a>RACSignal的操作</h3><p>对于信号操作、变化后得到的结果会从Next事件、Error事件、Completed事件三个角度并结合相应图例给出，不会对其底层实现做深入探究。</p><h4 id="对值操作"><a href="#对值操作" class="headerlink" title="对值操作"></a>对值操作</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Next事件：新信号的值由原信号值经过映射得出。（映射由传入block给出）<br>Error事件：透传原信号error事件。<br>Completed事件：透传原信号completed事件。</p><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Map.png" alt=""></p><h5 id="MapReplace"><a href="#MapReplace" class="headerlink" title="MapReplace"></a>MapReplace</h5><ul><li>Next事件：原信号的值会被转换成一串相同的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例<br><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/MapReplace.png" alt=""></p><h5 id="ReduceEach"><a href="#ReduceEach" class="headerlink" title="ReduceEach"></a>ReduceEach</h5><p>ReduceEach操作要求原信号的值必须是一个元组（RACTuple）。</p><ul><li>Next事件：对原信号发送的元组进行解包，利用解包后的值作为block的入参经过映射得出新的值。（映射由block给出）。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ReduceEach.png" alt=""></p><h5 id="ReduceApply"><a href="#ReduceApply" class="headerlink" title="ReduceApply"></a>ReduceApply</h5><p>ReduceApply其功能类似于ReduceEach。不过这里和ReduceEach不同的是，源信号产生的每个元组（每个值）的第0个元素必须是一个block，后面n个元素为block的入参，第0位的block有几个入参，后面就需要有几个元素，多余的元素为无效元素。</p><ul><li>Next事件：对原信号发送的元组进行解包，以元组的第0个元素为block，其余元素为入参得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ReduceApply.png" alt=""></p><h6 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h6><p>不是很好理解，这里给出相应代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">      </span><br><span class="line">      id block = ^id(NSNumber * first,NSNumber * second)&#123;</span><br><span class="line">          return @(first.integerValue + second.integerValue);</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      [subscriber sendNext:RACTuplePack(block,@1,@2,@5)];</span><br><span class="line">      return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  RACSignal * signalB = [signalA reduceApply];</span><br><span class="line">  </span><br><span class="line">  [signalB subscribeNext:^(id x) &#123;</span><br><span class="line">      NSLog(@&quot;%@&quot;,x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>上例代码中block只有两个入参，所以只会取1，2计算得出新值3，tuple内的元素5为无效元素。</p><h5 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h5><p>not操作要求源信号产生的每个值都是NSNumber类型。新信号的值由原信号值的布尔值取非得出。</p><ul><li>Next事件：由原信号值的布尔值取非得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Not.png" alt=""></p><h5 id="And"><a href="#And" class="headerlink" title="And"></a>And</h5><p>and操作要求源信号产生的每个值都是元组类型且元组内的每一个元素都必须是NSNumber类型。and操作会创建一个新的信号，新信号的值由元组内各元素的布尔值求与得出。</p><ul><li>Next事件：由源信号发送的元组内各元素的布尔值求与得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/and.png" alt=""></p><h5 id="Or"><a href="#Or" class="headerlink" title="Or"></a>Or</h5><p>or操作与and操作类似，不同的是新信号的值由元组内各元素的布尔值求或得出。这里不做展开讨论。</p><h5 id="Materialize"><a href="#Materialize" class="headerlink" title="Materialize"></a>Materialize</h5><p>materialize操作会创建一个新信号，新信号的值为将原信号的值包装为RACEvent类型。</p><ul><li>Next事件：由原信号的值包装为RACEvent类型得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><p>materialize操作通过源码更容易理解。通过对原信号的订阅，将原信号的值、error、complete包装成RACEvent类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)materialize &#123;</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">return [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithValue:x]];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithError:error]];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendNext:RACEvent.completedEvent];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -materialize&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dematerialize"><a href="#Dematerialize" class="headerlink" title="Dematerialize"></a>Dematerialize</h5><p>Dematerialize是materialize的逆操作,新信号的值为将原信号值（RACEvent类型）还原为正常的值信号。</p><ul><li>Next事件：由原信号的值(RACEvent类型)还原得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>同样通过源码来看dematerialize操作。通过bind函数对原信号进行变换。新信号会根据event.eventType进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)dematerialize &#123;</span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^(RACEvent *event, BOOL *stop) &#123;</span><br><span class="line">switch (event.eventType) &#123;</span><br><span class="line">case RACEventTypeCompleted:</span><br><span class="line">*stop = YES;</span><br><span class="line">return [RACSignal empty];</span><br><span class="line"></span><br><span class="line">case RACEventTypeError:</span><br><span class="line">*stop = YES;</span><br><span class="line">return [RACSignal error:event.error];</span><br><span class="line"></span><br><span class="line">case RACEventTypeNext:</span><br><span class="line">return [RACSignal return:event.value];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -dematerialize&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数量操作"><a href="#数量操作" class="headerlink" title="数量操作"></a>数量操作</h4><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>将原信号的值进行过滤后，符合条件的值会做为新信号的值返回，否则原信号的值会被吞掉。</p><ul><li>Next事件：对原信号发送的值进行过滤后得出。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Filter.png" alt=""></p><h5 id="Ignore"><a href="#Ignore" class="headerlink" title="Ignore"></a>Ignore</h5><p>ignore的底层实现是对Filter的封装。对原信号的值进行校验，与传入值相等的值会被吞掉，其他值会作为新信号的值返回。这里的相等为满足 “==” 操作符 或 “isEqual” 操作符。</p><ul><li>Next事件：对原信号发送的值进行过滤后得出。</li><li>Error事件：透传原信号error事件。</li></ul><p>Completed事件：透传原信号completed事件。</p><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ignore.png" alt=""></p><h5 id="IgnoreValues"><a href="#IgnoreValues" class="headerlink" title="IgnoreValues"></a>IgnoreValues</h5><p>ignoreValues的底层实现同样是对Filter的封装。创建一个忽略所有原有信号值的信号。即新信号不会发送任何next事件。这里不做展开讨论。</p><h5 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h5><p>distinctUntilChanged操作会对接收到的原信号的值与原信号上一次发送的值做校验，如果相等则忽略该值，只有和原信号上一次发送的值不同才会做为新信号的值进行传递。这里的相等同样是指满足 “==” 操作符 或 “isEqual” 操作符。</p><ul><li>Next事件：对原信号的值与上一次的值做校验，当前值与上一次值不一致时做为新信号的值发送。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/DistinctUntilChanged.png" alt=""></p><h5 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h5><p>take操作的入参为取原信号的前X个值，做为新信号的值返回，忽略原信号前x值以后的值。</p><ul><li>Next事件：取原信号的前x个值作为新信号的值，忽略其他值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/take.png" alt=""></p><h5 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h5><p>skip操作和take操作是补集关系。take是取原信号的前count个信号值，而skip是从原信号的第count + 1个信号值开始取值做为新信号的值返回。这里不做展开讨论。</p><h5 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h5><p>takeLast和take用法一样，不过他取的是原信号的最后x个值。需要注意的是：takeLast一定要调用sendCompleted，告诉他发送完成了，这样才能取到最后几个值，这里也就不对其进行展开了。</p><h5 id="TakeUntilBlock"><a href="#TakeUntilBlock" class="headerlink" title="TakeUntilBlock"></a>TakeUntilBlock</h5><p>根据传入的block做为校验条件。新信号透传原信号发送的值直至原信号发送的值满足校验条件，此时新信号停止发送值。</p><ul><li>Next事件：取原信号的值作为新信号的值直至满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/takeUntilBlock.png" alt=""></p><h5 id="SkipUntilBlock"><a href="#SkipUntilBlock" class="headerlink" title="SkipUntilBlock"></a>SkipUntilBlock</h5><p>根据传入的block做为校验条件。新信号忽略原信号发送的值直至原信号发送的值满足校验条件，此时新信号开始透传原信号发送的值。</p><ul><li>Next事件：忽略原信号发送的值直至原信号发送的值满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/skipUntilBlock.png" alt=""></p><h5 id="SkipWhileBlock"><a href="#SkipWhileBlock" class="headerlink" title="SkipWhileBlock"></a>SkipWhileBlock</h5><p>根据传入的block做为校验条件。新信号忽略原信号发送的值直至发送的值不满足校验条件。此时新信号开始透传原信号发送的值。</p><ul><li>Next事件：忽略原信号发送的值直至原信号发送的值不满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/skipWhileBlock.png" alt=""></p><h5 id="Any"><a href="#Any" class="headerlink" title="Any:"></a>Any:</h5><p>Any:操作根据传入block作为校验条件。如果原信号发送的值中有任何满足校验条件的值新信号发送@1（yes）。 如原信号中无任何满足校验条件的值，在原信号调用sendCompleted后，新信号发送@0（no）。<br>注意：使用Any:操作原信号必须调用sendCompleted，否则在所有值都校验失败的情况下新信号不会发送@0（no）.</p><ul><li>Next事件：原信号所发送的值中有任何值满足校验条件发送@1（yes），否则发送 @0（no）。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例<br>校验失败</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Any-faild.png" alt=""></p><p>校验成功</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/any-success.png" alt=""></p><h5 id="Any-1"><a href="#Any-1" class="headerlink" title="Any"></a>Any</h5><p>当原信号发送任何值，新信号就会发送@1（yes）。Any操作也需要原信号调用sendCompleted，否则在原信号不发送任何值的情况下，新信号不会发送@0（no），这里就不做展开了。</p><h5 id="All"><a href="#All" class="headerlink" title="All:"></a>All:</h5><p>All:操作以传入blcok作为校验条件，当原信号发送的任何值都满足校验条件时，新信号会发送@1（yes），否则新信号发送@0（no）。All:同样需要原信号调用sendCompleted。比较容易理解，也就不再展开。</p><p>#####StartWith<br>startWIth操作，利用contact（后续会提到）在透传原信号发送的值之前插入一个初始值。</p><ul><li>Next事件：在原信号发送的值之前插入一个初始值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/startWith.png" alt=""></p><h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p>在原信号发送completed事件后，持续重复发送原信号的值。</p><ul><li>Next事件：在原信号发送completed之前，发送原信号的值。 在原信号发送completed事件后，持续重复发送原信号的值。</li><li>Error事件：透传原信号error事件。不再重复发送原信号的值。</li><li>Completed事件：无completed事件。</li></ul><p>图例<br>原信号未发送error、completed</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_no_error-completed.png" alt=""></p><p>原信号发送error</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_send_error.png" alt=""></p><p>原信号发送completed</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_send_completed.png" alt=""></p><h5 id="Retry"><a href="#Retry" class="headerlink" title="Retry:"></a>Retry:</h5><p>透传原信号发送的值,在原信号出现error的时候，重试x次（重复订阅原信号x次），如果依旧error那么就会停止重试。</p><ul><li>Next事件: 发送原信号的值,在原信号发送error后，重试x次。</li><li>Error事件：在原信号发送error后，重试x次。如果依旧错误传递error。</li><li>Completed事件：透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/retry.png" alt=""></p><h5 id="Retry-1"><a href="#Retry-1" class="headerlink" title="Retry"></a>Retry</h5><p>retry为无限重试操作。底层为调用retry:实现，此时的入参为0。这里不做展开讨论。</p><h5 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h5><ul><li>Next事件: 将原信号的值收集起来，保存在NSMutableArray中，做为新信号的值。在原信号发送completed事件后发送该值。</li><li>Error事件：在原信号发送error后，丢弃所有值并传递error事件。</li><li>Completed事件：收到原信号的completed事件后发送收集起来的值并透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/collect.png" alt=""></p><p>ScanWithStart:reduce:</p><ul><li>Next事件: 以第一个入参为初始值，原信号每发送一个值以reduceBlock的策略为递推计算结果，计算结果作为新信号的值立刻发送。</li><li>Error事件：透传error事件。</li><li>Completed事件：透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ScanWithStart-reduce-.png" alt=""></p><p>#####AggregateWithStart:reduce:<br>本质为调用scanWithStart:reduce:操作和takeLast组合实现。</p><ul><li>Next事件: 以第一个入参为初始值，原信号每发送一个值以reduceBlock的策略为递推计算结果，在原信号发送sendCompleted后，新信号发送递推所得计算结果。</li><li>Error事件：透传error事件、丢弃计算结果。</li><li>Completed事件：发送计算结果并透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Aggregate.png" alt=""></p><h5 id="AggregateWithStartFactory-reduce"><a href="#AggregateWithStartFactory-reduce" class="headerlink" title="AggregateWithStartFactory: reduce:"></a>AggregateWithStartFactory: reduce:</h5><p>startFactory :aggregateWithStartFactory 本质为调用 aggregateWithStart实现，startFactory代码块的计算结果会作为start的入参传入aggregateWithStart。这里不做进一步展开。</p><h5 id="AggregateWithStart-reduceWithIndex"><a href="#AggregateWithStart-reduceWithIndex" class="headerlink" title="AggregateWithStart:reduceWithIndex:"></a>AggregateWithStart:reduceWithIndex:</h5><p>在aggregateWithStart:reduce: 的基础上，每次reduceBlock的递推都会带上统计当前递推次数的index。底层实现aggregateWithStart:reduce:为调用aggregateWithStart:reduceWithIndex:时忽略index参数。不做展开讨论。</p><h5 id="ScanWithStart-reduceWithIndex"><a href="#ScanWithStart-reduceWithIndex" class="headerlink" title="ScanWithStart:reduceWithIndex:"></a>ScanWithStart:reduceWithIndex:</h5><p>功能上与scanWithStart:reduce:类似，同样在reduceBlock会携带当前递推次数的index。scanWithStart:reduce:的底层实现同样为调用scanWithStart:reduceWithIndex:时忽略block内的index入参。同样不做展开讨论。</p><h4 id="对时间间隔操作"><a href="#对时间间隔操作" class="headerlink" title="对时间间隔操作"></a>对时间间隔操作</h4><h5 id="Delay"><a href="#Delay" class="headerlink" title="Delay:"></a>Delay:</h5><p>Delay:操作对原信号的next事件和completed事件延时发送，比较容易理解这里不做展开讨论。</p><ul><li>Next事件: 对原信号的值延迟x秒发送。</li><li>Error事件：立即透传error事件。</li><li>Completed事件：对于原信号的Completed事件延迟x秒发送。</li></ul><h5 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle:"></a>Throttle:</h5><p>throttle:通常用于搜索输入框，在用户享受实时更新搜索数据的同时减轻服务端压力。这里简单的Coding不能很形象说明，就不再编写代码。</p><ul><li>Next事件: 原信号在x秒内无新的值产生，新信号发送该值。</li><li>Error事件：透传error事件，如果之前有未发送next事件丢弃该事件（不再发送）。</li><li>Completed事件：新信号立刻透传该事件，如果之前有未发送next事件的值立即发送该值。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/throttle.png" alt=""></p><h5 id="Throttle-valuesPassingTest"><a href="#Throttle-valuesPassingTest" class="headerlink" title="Throttle:valuesPassingTest:"></a>Throttle:valuesPassingTest:</h5><p>在throttle：的基础上加入校验操作。</p><ul><li>Next事件: 对原信号发送的值进行校验，校验失败丢弃该值。校验成功，若原信号在x秒内无新的校验成功的next值产生，新信号发送该值。</li><li>Error事件：透传error事件，如果之前有未发送next事件的值丢弃该值（不再发送）。</li><li>Completed事件：新信号立刻透传该事件，如果之前有未发送校验成功的next事件的值立即发送该值。</li></ul><h5 id="BufferWithTime-onScheduler"><a href="#BufferWithTime-onScheduler" class="headerlink" title="BufferWithTime:onScheduler"></a>BufferWithTime:onScheduler</h5><ul><li>Next事件: 缓冲原信号未来一段时间内发送的next事件，将所有值包装成RACTuple返回。</li><li>Error事件：透传error事件，丢弃缓冲池内的值。</li><li>Completed事件：将缓冲池内的next事件立即发送后，立即透传completed事件。</li></ul><h4 id="多信号的组合、变换"><a href="#多信号的组合、变换" class="headerlink" title="多信号的组合、变换"></a>多信号的组合、变换</h4><h5 id="Concat"><a href="#Concat" class="headerlink" title="Concat:"></a>Concat:</h5><p>对A、B两个信号进行链接，A发送completed事件后开始发送B信号的事件。</p><ul><li>Next事件：透传A信号的值，A信号发送completed事件后开始透传B信号的值。</li><li>Error事件：A、B任一信号发出error事件后透传该事件，且不再进行拼接操作。</li><li>Completed事件：B信号发送completed事件后，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Concat.png" alt=""></p><p>concat操作不会改变原有信号值的发送线程。</p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge:"></a>Merge:</h5><p>将A、B两个信号进行合并。</p><ul><li>Next事件：按时间顺序透传A、B两信号的next事件。</li><li>Error事件：A、B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A、B两信号，均发送completed事件后，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Merge.png" alt=""></p><p>merge操作不会改变原有信号值的发送线程。</p><h5 id="Zip"><a href="#Zip" class="headerlink" title="Zip:"></a>Zip:</h5><p>将A、B两信号发送的值压缩为一个元组。每个流的第一个值将被合并、然后是第二个、第三个，直到一个流被终止。</p><ul><li>Next事件：在A、B两信号都发送next事件后，将next事件携带值合并成一个元组作。新信号以该元组为值发送next事件。</li><li>Error事件：A、B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A、B两信号，任意信号发送completed，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Zip.png" alt=""></p><p>Zip操作新信号发送事件的线程与触发线程一致。</p><h4 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest:"></a>CombineLatest:</h4><ul><li>Next事件：将来自A/B两信号的最新值组合成一个RACTuples，A、B任何一个信号发送值（如果另一个信号曾经发送过值）都会产生一个RACTuple并传递下去。</li><li>Error事件：A/B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A/B两信号，任意信号发送completed事件，透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/CombineLatest.png" alt=""></p><p>CombineLatest操作新信号发送事件的线程与触发线程一致。</p><h3 id="斐波那契数列信号"><a href="#斐波那契数列信号" class="headerlink" title="斐波那契数列信号"></a>斐波那契数列信号</h3><p>在之前的一篇Post里提示出提到我们可以用函数式编程表示一个无限的数据结构如斐波那契数列、无限递增的数据结构。<br>那么在RAC中应该如何来做呢？</p><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *repeat1 = [[RACSignal return:@1] repeat];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [repeat1 scanWithStart:RACTuplePack(@1, @1) reduce:^id(RACTuple *running, id _) &#123;</span><br><span class="line">    NSNumber * next = @([running.first integerValue] + [running.second integerValue]);</span><br><span class="line">    return RACTuplePack(running.second, next);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalB subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="无限递增的数据结构"><a href="#无限递增的数据结构" class="headerlink" title="无限递增的数据结构"></a>无限递增的数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *repeat1 = [[RACSignal return:@1] repeat];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [repeat1 scanWithStart:@0 reduce:^id(NSNumber * running, NSNumber * next) &#123;</span><br><span class="line">    return @(running.integerValue + next.integerValue);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalB subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>To be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在之前的一篇Post中对函数响应式编程和RAC做了简单剖析,强烈建议没看过的同学猛戳链接。&lt;/p&gt;
&lt;p&gt;ReactiveCocoa的核心是RACSignal类代表的信号。信号会产生一个事件流，事件有三种类型next、completed、error，一个信号源可以发送任意数量的next时间，直到该信号结束（completed）或因错误（error）而关闭。通过对信号的订阅可以获得不同事件的回调。使用这个简单的事件流模型，通过对信号的变换、组合操作，我们可以处理日常iOS开发中的按钮点击、网络请求响应、KVO或用户位置变化等各种事件类型。&lt;/p&gt;
&lt;p&gt;本篇我们会围绕RACSignal的基本使用及各类操作做详细探究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------Functor、Applicatives和Monad</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-Functor%E3%80%81Applicatives%E5%92%8CMonad/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-Functor、Applicatives和Monad/</id>
    <published>2019-03-10T05:35:58.000Z</published>
    <updated>2019-03-10T05:37:01.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：函数式编程中的Functor、Applicatives和Monad。</p><p>Functor、Applicatives和Monad的概念源自范畴论。本篇笔者从Swift的Optional入手阐述Functor、Applicatives和Monad在函数式编程中的概念。对比于OC，swift提供了对函数式编程更好的支持。</p><a id="more"></a><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Apple在WWDC 2014开发者大会上发布了用于Mac OS X和iOS编程的新一代编程语言Swift。Optional（可选值）为Swift中一个重要的概念。</p><h3 id="Optional-封装后的值"><a href="#Optional-封装后的值" class="headerlink" title="Optional-封装后的值"></a>Optional-封装后的值</h3><p>Optional数据类型事实上就是封装后的值，即对值及其上下文环境进行封装的结果。</p><p>Optional的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Optional类型的值，为空的时候就是.none,不为空的时候就是.some。当我们将一个函数应用于Optional，不同上下文（.some或.none）我们将得到不同的结果。函数式编程中Functor、Applicatives和Monad的概念就是基于对封装后的值进行操作。</p><p>函数式编程中将值与上下文进行封装，对封装后的值进行操作可以集中于我们想要完成的事情，省去了异常分支（.none）的判断、嵌套。这样的代码具有更高的可读性，也更不易出错。如在RAC中对RACSignal发送的map、filter操作的过程中，我们将精力集中在next事件上，error、completed事件的传递处理都封装在RACSignal中。</p><h3 id="MyOptional"><a href="#MyOptional" class="headerlink" title="MyOptional"></a>MyOptional</h3><p>Swift的Optional只满足函数式编程中的Functor,Monad，并不满足Applicatives的概念。笔者在ReactiveCocoa高阶操作中给出了Functor、Applicatives和Monad概念定义。本篇中笔者用Swift实现满足Functor、Applicatives和Monad概念的MyOptional对这些概念进一步阐述。</p><h4 id="MyOptional定义"><a href="#MyOptional定义" class="headerlink" title="MyOptional定义"></a>MyOptional定义</h4><p>类似Optional 给出简单定义 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum MyOperation &lt;T&gt; &#123;</span><br><span class="line">    case some(T)</span><br><span class="line">    case none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将Functor、Applicatives和Monad理解为一种协议，遵循该协议实现对应的方法，即为满足Functor、Applicatives和Monad。</p><h4 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h4><blockquote><p>Functor:应用一个函数到封装后的对象。</p></blockquote><p>添加map函数，应用函数到MyOptional对象，使MyOptional满足Functor。</p><h5 id="map实现"><a href="#map实现" class="headerlink" title="map实现"></a>map实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension MyOptional&#123;</span><br><span class="line">    //应用一个函数到MyOptional</span><br><span class="line">    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; MyOptional&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .some(a):</span><br><span class="line">            return MyOptional&lt;U&gt;.some(f(a))</span><br><span class="line">            </span><br><span class="line">        case .none:</span><br><span class="line">            return MyOptional&lt;U&gt;.none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map使用"><a href="#map使用" class="headerlink" title="map使用"></a>map使用</h5><p>通过map方法，应用plusTree到MyOptional对象，同时在plusTree中我们只关注想要执行的操作，.none的异常分支被封装在MyOptional的map实现中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func plusTree(addend:Int) -&gt; Int &#123;</span><br><span class="line">  return  addend + 3</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">let some = MyOptional.some(2).map(f: plusTree)</span><br><span class="line">let none = MyOptional&lt;Int&gt;.none.map(f: plusTree)</span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><h4 id="Applicatives"><a href="#Applicatives" class="headerlink" title="Applicatives"></a>Applicatives</h4><blockquote><p>Applicatives:应用一个封装后的方法到一个封装后的对象。</p></blockquote><p>函数式编程中函数是一等公民，我们可以将值与其上下文进行封装，同样我们也可以将函数与其上下文进行封装。</p><p>添加apply函数，应用函数到MyOptional对象，使MyOptional满足Applicatives。</p><h5 id="apply实现"><a href="#apply实现" class="headerlink" title="apply实现"></a>apply实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension MyOperation&#123;</span><br><span class="line">    //应用一个封装过的函数到MyOperation</span><br><span class="line">    func apply&lt;U&gt;(f:(MyOperation&lt;(T)-&gt;U&gt;))-&gt; MyOperation&lt;U&gt; &#123;</span><br><span class="line">        switch f &#123;</span><br><span class="line">        case let .some(someF):</span><br><span class="line">            return self.map(f: someF)</span><br><span class="line">        case .none:</span><br><span class="line">            return .none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="apply使用"><a href="#apply使用" class="headerlink" title="apply使用"></a>apply使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func plusTree(addend:Int) -&gt; Int &#123;</span><br><span class="line">   return  addend + 3</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">let funcSome = MyOptional.some(plusTree)</span><br><span class="line">let funcNone = MyOptional&lt;(Int)-&gt;Int&gt;.none</span><br><span class="line">        </span><br><span class="line">let some = MyOptional.some(2).apply(f: funcSome)</span><br><span class="line">let none = MyOptional.some(2).apply(f: funcNone) </span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><p>将plusTree和 MyOptional&lt;(Int)-&gt;Int&gt;.none封装为MyOption，并通过apply进行调用。</p><h4 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h4><blockquote><p>Monad：应用一个返回封装后的对象的方法到一个封装后的对象。</p></blockquote><p>添加flatMap函数，应用一个返回封装后的对象的函数到一个封装后的对象。使MyOptional满足Monad。</p><h5 id="flatMap实现"><a href="#flatMap实现" class="headerlink" title="flatMap实现"></a>flatMap实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension MyOptional&#123;</span><br><span class="line"></span><br><span class="line">    //应用一个返回MyOptional的函数到MyOptional</span><br><span class="line">    func flatMap&lt;U&gt;(f: (T) -&gt; MyOptional&lt;U&gt;) -&gt; MyOptional&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .some(a):</span><br><span class="line">            return f(a)</span><br><span class="line">        case .none:</span><br><span class="line">            return .none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="flatMap使用"><a href="#flatMap使用" class="headerlink" title="flatMap使用"></a>flatMap使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//返回MyOptional的函数</span><br><span class="line">func plusTree(addend:Int) -&gt; MyOptional &lt;Int&gt; &#123;</span><br><span class="line">  return  MyOptional&lt;Int&gt;.some(addend + 3)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">let some = MyOptional.some(2).flatMap(f: plusTree)</span><br><span class="line">let none = MyOptional&lt;Int&gt;.none.flatMap(f: plusTree)</span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><p>至此，通过添加map、apply、flatMap函数，MyOptional分别“遵循Functor、Applicative、Monad协议”。我们可以称MyOptional是Functor/Applicative/Monad。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>一个 Functor 就是一种实现了 Functor typeclass（协议） 的数据类型；</li><li>一个 Applicative 就是一种实现了 Applicative typeclass（协议） 的数据类型；</li><li>一个 Monad 就是一种实现了 Monad typeclass（协议）的数据类型。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="noopener">Swift Functors, Applicatives, and Monads in Pictures</a><br><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="noopener">Functors, Applicative Functors and Monoids</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：函数式编程中的Functor、Applicatives和Monad。&lt;/p&gt;
&lt;p&gt;Functor、Applicatives和Monad的概念源自范畴论。本篇笔者从Swift的Optional入手阐述Functor、Applicatives和Monad在函数式编程中的概念。对比于OC，swift提供了对函数式编程更好的支持。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------冷信号vs热信号</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-%E5%86%B7%E4%BF%A1%E5%8F%B7vs%E7%83%AD%E4%BF%A1%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-冷信号vs热信号/</id>
    <published>2019-03-10T05:34:26.000Z</published>
    <updated>2019-03-10T05:35:22.437Z</updated>
    
    <content type="html"><![CDATA[<p>冷热信号的概念是源自于源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：</p><blockquote><ol><li>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。</li><li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。 </li></ol></blockquote><p>冷热信号分别对应RAC中的RACSignal和RACSubject，RACSubject是RACSignal的子类。本文中笔者将从示例代码引入RACSignal（冷信号）在实际应用中的问题及RACSubject（热信号）的使用，通过剖析RACSubject的源码，阐述冷热信号的概念及RACSubject的实现。</p><a id="more"></a><h3 id="懒惰的RACSignal"><a href="#懒惰的RACSignal" class="headerlink" title="懒惰的RACSignal"></a>懒惰的RACSignal</h3><p>笔者函数式编程提到了惰性求值的概念:</p><blockquote><p>惰性求值（尽可能延迟表达式求值），表达式不会在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p></blockquote><p>RACSignal就是惰性求值的。RACSignal的didSubscribe block只有在RACSignal被订阅的时候才会被执行，而且每次订阅RACSignal都会执行一遍didSubscribe block。也正是这个特性赋予了RACSignal冷信号的特点。同时，RACSignal的这些特点也导致了其在实际应用中的一些问题。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>一起看以下示例代码</p><h5 id="示例一：RACSignal-amp-副作用"><a href="#示例一：RACSignal-amp-副作用" class="headerlink" title="示例一：RACSignal &amp; 副作用"></a>示例一：RACSignal &amp; 副作用</h5><p>以下代码在didSubscribe中引入副作用”i += 1“，通过Output可以看出这种情况下对同一个信号多次订阅拿到不同的值，这显然是我们不想看到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    i += 1;</span><br><span class="line">    [subscriber sendNext:@(i)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber1---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber2---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber3---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-04 18:53:38.660673+0800 RACDemo[98599:6473410] subscriber1---recived---1</span><br><span class="line">2018-03-04 18:53:38.661029+0800 RACDemo[98599:6473410] subscriber2---recived---2</span><br><span class="line">2018-03-04 18:53:38.661184+0800 RACDemo[98599:6473410] subscriber3---recived---3</span><br></pre></td></tr></table></figure><h4 id="RACSignal-amp-时间"><a href="#RACSignal-amp-时间" class="headerlink" title="RACSignal &amp; 时间"></a>RACSignal &amp; 时间</h4><p>以下代码signal以1秒的间隔依次发送1，2，3。subscriber1立即订阅signal（signal未发送任何值之前），subscribe2在3.1秒后（signal将所有值发送完毕后）订阅signal。在不同时间订同一信号获取的结果是一样的。通过Output可以看出在任意时间点订阅signal，signal都会以1秒的间隔依次发送1，2，3。很多情况下，这同样不是我们想看到的，subscribe2只关心signal在3.1秒之后发送的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">    &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscribe1----recieve-%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:3.1 schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;subscribe2----recieve-%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><p>注意时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-03-04 18:58:21.864222+0800 RACDemo[98639:6481792] subscribe1----recieve-1</span><br><span class="line">2018-03-04 18:58:22.863358+0800 RACDemo[98639:6481792] subscribe1----recieve-2</span><br><span class="line">2018-03-04 18:58:23.963592+0800 RACDemo[98639:6481792] subscribe1----recieve-3</span><br><span class="line">2018-03-04 18:58:24.967656+0800 RACDemo[98639:6481792] subscribe2----recieve-1</span><br><span class="line">2018-03-04 18:58:25.964144+0800 RACDemo[98639:6481792] subscribe2----recieve-2</span><br><span class="line">2018-03-04 18:58:26.967526+0800 RACDemo[98639:6481792] subscribe2----recieve-3</span><br></pre></td></tr></table></figure><p>结合在懒惰的RACSignal中提到RACSignal的特点。不难理解，示例一、示例二所展示的结果正式由于RACSignal的惰性求值及每次订阅重复调用didSubscribe block导致的。</p><h3 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h3><p>我们对示例二的代码进行一个小的改动,创建热信号subject,subject订阅signal，subscriber订阅subject不再直接订阅signal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">    &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject * subject = [RACSubject subject];</span><br><span class="line">[signal subscribe:subject];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subject subscriber1----recieve-%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:3.1 schedule:^&#123;</span><br><span class="line">    [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;subject subscriber2----recieve-%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><p>一起来看看发生了啥，立即订阅的subscriber1收到了所有值，而3.1秒之后订阅的subscribe2没有收到任何值。RACSubject就是RAC中的热信号，subject字面意思是“主题”。RACSubject是与时间强相关的。在事件发生时，只有已经订阅该主题的subscriber才会被通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-05 13:30:38.591185+0800 RACDemo[11918:7623749] subject subscriber1----recieve-1</span><br><span class="line">2018-03-05 13:30:39.590616+0800 RACDemo[11918:7623749] subject subscriber1----recieve-2</span><br><span class="line">2018-03-05 13:30:40.689946+0800 RACDemo[11918:7623749] subject subscriber1----recieve-3</span><br></pre></td></tr></table></figure><h3 id="RACSubject的实现"><a href="#RACSubject的实现" class="headerlink" title="RACSubject的实现"></a>RACSubject的实现</h3><p>我们通过分析RACSubject的源码来探究热信号的概念。</p><p>RACSubject是RACSignal的子类。相比于RACSignal丰富的头文件，RACSubject对外的接口并没有提供太多方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface RACSubject : RACSignal &lt;RACSubscriber&gt;</span><br><span class="line">+ (instancetype)subject;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>RACSubject的特性主要由subscribers订阅者数组和RACSubscriber协议提供。</p><h4 id="subscribers订阅者数组"><a href="#subscribers订阅者数组" class="headerlink" title="subscribers订阅者数组"></a>subscribers订阅者数组</h4><p>RACSubject维护了一个订阅者数组，每当有新的订阅者产生，都会将传入的 id 对象加入数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">        subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">        NSMutableArray *subscribers = self.subscribers;</span><br><span class="line">        @synchronized (subscribers) &#123;</span><br><span class="line">                [subscribers addObject:subscriber];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                @synchronized (subscribers) &#123;</span><br><span class="line">                        NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">                                return obj == subscriber;</span><br><span class="line">                        &#125;];</span><br><span class="line"></span><br><span class="line">                        if (index != NSNotFound) [subscribers removeObjectAtIndex:index];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;]];</span><br><span class="line"></span><br><span class="line">        return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅的过程分为三个部分：</p><ol><li>初始化一个 RACPassthroughSubscriber 实例；</li><li>将subscriber加入RACSubject持有的数组中；</li><li>创建一个RACDisposable对象，在当前subscriber销毁时，将自身从数组中移除。</li></ol><p>订阅者数组，为RACSubject提供了一对多的能力。事件发生时RACSubject通过实现RACSubscriber协议提供的方法，遍历subscribers数组逐个发送消息。</p><h4 id="RACSubscriber协议"><a href="#RACSubscriber协议" class="headerlink" title="RACSubscriber协议"></a>RACSubscriber协议</h4><p>RACSubscriber协议为RACSubject提供了在创建成功后向订阅者继续发送消息的能力，RACSignal只能通过创建信号的didSubscribe block遵循该协议的subscriber发送消息。所以我们可以说，RACSignal是不可变的，RACSubject是可变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol RACSubscriber &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(nullable id)value;</span><br><span class="line">- (void)sendError:(nullable NSError *)error;</span><br><span class="line">- (void)sendCompleted;</span><br><span class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendError:(NSError *)error &#123;</span><br><span class="line">        [self.disposable dispose];</span><br><span class="line"></span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendCompleted &#123;</span><br><span class="line">        [self.disposable dispose];</span><br><span class="line"></span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSubject实现相对简单。类似于通知，通过维护订阅者数组在事件发生后为所有订阅者发送消息。在具体的编码过程中加入了一些锁用以避免线程竞争。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，结合Hot Observable和Cold Observable。我们不难理解，冷信号就好像看录像，热信号就好像是看直播。</p><blockquote><p>冷信号（看录像）<br>不可变：RACSignal创建后，将要发送的消息就是固定的。（录像录制完成后内容就是固定的）<br>一对一：当有不同的订阅者，RACSignal会重复发送所有消息。(为每一个观看者重复播放录像)<br>被动的：只有订阅者订阅的时候，才会发送消息。（没有人要求观看时不会播放录像）</p></blockquote><blockquote><p>热信号（看直播）<br>可变：RACSubject创建后，可以持续添加新事件。（直播总会有新的事情发生）<br>一对多：所有订阅者共享同一个RACSubject。（只有一个主播）<br>主动的：无论是否有订阅者，都会发送新事件。（有没有人看主播都会播）</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号</a></p><p><a href="https://spin.atomicobject.com/2014/06/29/replay-replaylast-replaylazily/" target="_blank" rel="noopener">Comparing replay, replayLast, and replayLazily</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冷热信号的概念是源自于源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。&lt;/li&gt;
&lt;li&gt;Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;冷热信号分别对应RAC中的RACSignal和RACSubject，RACSubject是RACSignal的子类。本文中笔者将从示例代码引入RACSignal（冷信号）在实际应用中的问题及RACSubject（热信号）的使用，通过剖析RACSubject的源码，阐述冷热信号的概念及RACSubject的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------函数式编程初探</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-函数式编程初探/</id>
    <published>2019-03-10T05:31:54.000Z</published>
    <updated>2019-03-10T05:33:11.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactiveCocoa——函数式编程初探"><a href="#ReactiveCocoa——函数式编程初探" class="headerlink" title="ReactiveCocoa——函数式编程初探"></a>ReactiveCocoa——函数式编程初探</h2><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程、函数式编程、逻辑式编程，常见的面向对象编程是一种命令式编程。</p><h4 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h4><blockquote><p>命令式编程是面向计算机硬件的抽象，有变量（对应存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），命令式程序就是一个冯诺依曼的指令序列。</p></blockquote><h4 id="函数式编程（FP）"><a href="#函数式编程（FP）" class="headerlink" title="函数式编程（FP）"></a>函数式编程（FP）</h4><blockquote><p>函数式编程是面向数学的抽象， 将计算描述为一种表达式求值， 函数式程序就是一个表达式。</p></blockquote><p>函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖于其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。</p><p>由于函数式编程是面向数学的抽象，更接近人的语言。函数式编程更关注结果，相对的命令式编程关注解决问题的步骤。使用函数式编程，代码会比较简洁，也容易被理解。</p><a id="more"></a><h3 id="函数式编程的本质"><a href="#函数式编程的本质" class="headerlink" title="函数式编程的本质"></a>函数式编程的本质</h3><h4 id="一等公民"><a href="#一等公民" class="headerlink" title="一等公民"></a>一等公民</h4><p>函数式编程中，函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>函数式编程中高阶函数是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>高阶函数范例：<br>这是一个Python script的例子，其中函式g()有一引数以及回传一函数.这个例子会打印100 ( g(f,7)= (7+3)×(7+3) ).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x + 3</span><br><span class="line"></span><br><span class="line">def g(function, x):</span><br><span class="line">    return function(x) * function(x)</span><br><span class="line"></span><br><span class="line">print g(f, 7)</span><br></pre></td></tr></table></figure><p>范例代码来自于：<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科</a></p><h4 id="不修改状态"><a href="#不修改状态" class="headerlink" title="不修改状态"></a>不修改状态</h4><blockquote><p>不变性是函数式编程的基石，面向对象的编程通过封装可变动的部分来构造能够让人读懂的代码，函数式编程则是通过最大程度地减少可变动的部分来构造出可让人读懂的代码。</p></blockquote><p>函数式编程语言中的变量不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。  </p><p>由于命令式编程语言也可以通过类似于函数指针的方式来实现高阶函数，函数式编程的优势主要是不可变性带来的。没有可变状态，函数就是引用透明、没有副作用的，也是线程安全的。</p><h4 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h4><p>引用透明，指的是函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数，即如果提供同样的输入，那么函数总是返回同样的结果。</p><h4 id="无“副作用”"><a href="#无“副作用”" class="headerlink" title="无“副作用”"></a>无“副作用”</h4><p>副作用，指的是函数内部与外部互动，产生预算以外的其他结果。（最典型的情况是修改全局变量的值）。<br>函数式编程强调无“副作用”，意味着函数要保持独立，所有功能就是计算返回一个新的值，没有其他行为，即，纯函数。</p><h4 id="更易调试"><a href="#更易调试" class="headerlink" title="更易调试"></a>更易调试</h4><p>函数不依赖外部状态也不修改外部状态，函数调用的结果不依赖调用的时间和位置，这样写的代码更容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p><h4 id="易于并发编程"><a href="#易于并发编程" class="headerlink" title="易于并发编程"></a>易于并发编程</h4><p>不可变性带来的另一个好处是：函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。<br>除此之外，就算某个函数式程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = somewhatLongOperation1();</span><br><span class="line">String s2 = somewhatLongOperation2();</span><br><span class="line">String s3 = concatenate(s1, s2);</span><br></pre></td></tr></table></figure><p>由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。  </p><p>多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。</p><h4 id="只用“表达式”，不用“语句”"><a href="#只用“表达式”，不用“语句”" class="headerlink" title="只用“表达式”，不用“语句”"></a>只用“表达式”，不用“语句”</h4><blockquote><p>严格意义上的函数式编程意味着不适用可变的变量，赋值，循环和其他命令式控制结构进行编程。</p></blockquote><p>“表达式”是一个单纯的运算过程，总是有返回值；“语句”是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>函数式编程的如条件语句、循环语句也不是命令式编程语言中的控制语句，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。</p><h4 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h4><blockquote><p>惰性求值（尽可能延迟表达式求值），表达式不会在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p></blockquote><p>由于函数是引用透明的以及函数式编程不像命令式编程那样关注执行步骤，这就为系统提供了优化函数式程序的空间，如惰性求值。惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至减少错误。</p><p>惰性求值有如下有点：</p><ul><li>首先，你可以用它们来创建无限序列这样一种数据类型。因为直到需要时才会计算值，这样就可以使用惰性集合模拟无限序列。例如存储一个Fibonacci数列数字的列表。</li><li>第二，减少了存储空间。因为在真正需要时才会发生计算。所以，节约了不必要的存储空间。</li><li>第三，减少计算量，产生更高效的代码。因为在真正需要时才会发生计算。例如，寻找数组中第一个符合某个条件的值。</li></ul><h3 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation Passing Style (CPS)"></a>Continuation Passing Style (CPS)</h3><h4 id="惰性求值的不足"><a href="#惰性求值的不足" class="headerlink" title="惰性求值的不足"></a>惰性求值的不足</h4><p>惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实生活中很多问题还是需要严格求值、严格的执行顺序的。比如下面例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Please enter your name&quot;);</span><br><span class="line">System.in.readLine();</span><br></pre></td></tr></table></figure><p>由于这两行代码并不存在依赖关系，在惰性语言中没人能保证第一行会在第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何事情，也就是说不能和外界交互了！<br>函数式编程中我们可以通过Continuation Passing Style 来保证代码按一定的顺序执行。</p><h4 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h4><p>CPS把函数调用完之后接下来要执行的代码通过闭包包裹并作为函数参数调用要执行的函数。方便理解我们先看一个例子</p><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = add(5, 10);</span><br><span class="line">int j = square(i);</span><br></pre></td></tr></table></figure><p>add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器不能打乱这段代码的执行顺序，因为第二个函数的执行依赖于第一个函数的执行结果。这段代码可以用CPS技术重写，这样一来add的返回值就不是传递给其调用者，而是直接传到square里去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int j = add(5, 10, square);</span><br></pre></td></tr></table></figure><p>在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。</p><p>同样我们以CPS技术重写上述IO代码，编译器就必须顺序执行了，因为重写后的代码建立了依赖关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Please enter your name: &quot;, System.in.readLine);</span><br></pre></td></tr></table></figure><h4 id="CPS-amp-传统函数调用"><a href="#CPS-amp-传统函数调用" class="headerlink" title="CPS &amp; 传统函数调用"></a>CPS &amp; 传统函数调用</h4><h5 id="传统函数调用"><a href="#传统函数调用" class="headerlink" title="传统函数调用"></a>传统函数调用</h5><p>传统函数调用的程序需要额外的函数调用栈才能运行。</p><p>栈里面存放的是参数还有一个供函数运行结束后返回的程序指针，以支持函数返回后程序的继续运行。</p><h5 id="CPS风格函数调用"><a href="#CPS风格函数调用" class="headerlink" title="CPS风格函数调用"></a>CPS风格函数调用</h5><p>用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。</p><p>在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！</p><p>在CPS风格下的函数式编程，函数就是一个管道（pipe）。这头进去一个值另一头出来一个新的值并进入下一个管道，没有其他作用。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://www.defmacro.org/2006/06/19/fp.html" target="_blank" rel="noopener">Functional Programming For The Rest of Us</a><br><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式编程思维</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ReactiveCocoa——函数式编程初探&quot;&gt;&lt;a href=&quot;#ReactiveCocoa——函数式编程初探&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa——函数式编程初探&quot;&gt;&lt;/a&gt;ReactiveCocoa——函数式编程初探&lt;/h2&gt;&lt;h3 id=&quot;编程范式&quot;&gt;&lt;a href=&quot;#编程范式&quot; class=&quot;headerlink&quot; title=&quot;编程范式&quot;&gt;&lt;/a&gt;编程范式&lt;/h3&gt;&lt;p&gt;函数式编程是一种编程范式，我们常见的编程范式有命令式编程、函数式编程、逻辑式编程，常见的面向对象编程是一种命令式编程。&lt;/p&gt;
&lt;h4 id=&quot;命令式编程&quot;&gt;&lt;a href=&quot;#命令式编程&quot; class=&quot;headerlink&quot; title=&quot;命令式编程&quot;&gt;&lt;/a&gt;命令式编程&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;命令式编程是面向计算机硬件的抽象，有变量（对应存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），命令式程序就是一个冯诺依曼的指令序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;函数式编程（FP）&quot;&gt;&lt;a href=&quot;#函数式编程（FP）&quot; class=&quot;headerlink&quot; title=&quot;函数式编程（FP）&quot;&gt;&lt;/a&gt;函数式编程（FP）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;函数式编程是面向数学的抽象， 将计算描述为一种表达式求值， 函数式程序就是一个表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖于其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。&lt;/p&gt;
&lt;p&gt;由于函数式编程是面向数学的抽象，更接近人的语言。函数式编程更关注结果，相对的命令式编程关注解决问题的步骤。使用函数式编程，代码会比较简洁，也容易被理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程安全------nonatomic与野指针不得不说的故事</title>
    <link href="http://yoursite.com/2019/03/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-nonatomic%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/</id>
    <published>2019-03-10T05:29:12.000Z</published>
    <updated>2019-03-10T05:30:57.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crash-操作系统的自我保护"><a href="#Crash-操作系统的自我保护" class="headerlink" title="Crash-操作系统的自我保护"></a>Crash-操作系统的自我保护</h3><p>当运行程序出现内存访问异常（访问野指针、数组越界）、内存不足（linux 下内存不足会出发oom_killer杀死当前进程）等异常情况，操作系统为自身的稳定运行会将异常程序KILL（Crash）掉以避免引起更大的问题。Crash是操作系统的一种自我保护机制，在程序Crash之前会收到操作系统发出的SIGSEGV、SIGKILL等信号。操作系统在发出这些指令之后会立即KILL掉异常应用程序。在日常的Crash清理中，通常会有茫茫多的SIGSEGV、SIGKILL Crash问题难以定位。</p><p>日常开发中另一类，难以定位的Crash将矛头指向了某些系统函数，如比较常见的objc_msgSend崩溃，我们将在 Foundation 与 UIKit 等的系统库中的方法称之为系统方法。作为一个乐观者，我们有理由相信系统方法和操作系统本身的稳定性。Crash的原因大概率（肯定）是我们自己代码出了问题，这些问题通常是由于欠妥的内存管理导致的。</p><a id="more"></a><h3 id="从一个-objc-msgSend-Crash开始"><a href="#从一个-objc-msgSend-Crash开始" class="headerlink" title="从一个 objc_msgSend Crash开始"></a>从一个 objc_msgSend Crash开始</h3><p>一起来看一个objc msgSend Crash的堆栈，该堆栈信息崩溃在了第6行,错误信息为:Thread 10:EXC BAD _ ACCESS( code =1,address=0x1a15cbeb8)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib`objc_msgSend:</span><br><span class="line">0x1903a01c0:  cmp    x0, #0</span><br><span class="line">0x1903a01c4:  b.le   0x1903a0230               ; objc_msgSend + 112</span><br><span class="line">0x1903a01c8:  ldr    x13, [x0, 0]</span><br><span class="line">0x1903a01cc:  and    x9, x13, #0x1fffffff8</span><br><span class="line">0x1903a01d0:  ldp    x10, x11, [x9, #16] // this line gives an error</span><br><span class="line">0x1903a01d4:  and    w12, w1, w11</span><br><span class="line">0x1903a01d8:  add    x12, x10, x12, lsl #</span><br></pre></td></tr></table></figure><p>可以肯定的是，问题绝不会是出现在objcmsgSend函数的实现上，objc msgSend可以说是OC的灵魂函数。如果这个函数存在漏洞那OC程序也就不太可能运行的起来了。关于objc msgSend这个函数，Apple已经提供了源码<a href="http://www.opensource.apple.com/source/objc4/objc4-647/runtime/Messengers.subproj/objc-msg-arm64.s" target="_blank" rel="noopener">arm64下的源码</a>，为了更高的效率objc msgSend是用汇编实现的。</p><p>结合objc_msgSend的源码我们可以分析以上崩溃信息每一行都做了啥：</p><ul><li><p>第二行 0x1903a01c0: cmp x0, #0</p><p>  检查iSA指针是否为nil或tagged pointer，arm64下苹果爸爸提出了提出了Tagged Pointer的概念，优化了NSNumber、NSDate存储和操作效率。简单来说就是Tagged Pointer对象的指针不再指向任何内存地址，而是被拆成两部分：一部分直接保存数据，另一部分作为特殊标记。所以这里需要对Tagged Pointer做判断。更多关于Tagged Pointer 猛戳深入理解Tagged Pointer</p></li><li><p>第三行 0x1903a01c4: b.le 0x1903a0230</p><p>  跳转操作，如果是tagged pointer 或 nil 跳转至0x1903a0230进行处理，我们这里显然不是程序会继续往下执行。</p></li><li><p>第四行 0x1903a01c8: ldr x13, [x0, 0]</p><p>  将对象的iSA指针，放入x13寄存器中。</p></li></ul><ul><li><p>第五行 0x1903a01cc: and x9, x13, #0x1fffffff8</p><p>  将类对象的真正指针存入x9寄存器，arm64下iSA指针除了存储类对象地址还存储了对象是否存在弱引用、是否正在销毁、对象的引用计数等信息，为取到真正的类对象地址，需将iSA指针同一个特定的立即数#0x1fffffff8进行AND操作</p></li><li><p>第六行 0x1903a01d0: ldp x10, x11, [x9, #16]</p><p>  将类对象存储的方法缓存列表的地址存入寄存器x10。在msgSend的过程中会先从类对象的mathod_cache_list中寻找相应的方法。（注意：程序在这里发生了Crash）。</p></li></ul><p>下图简单展示了上述汇编代码的调用过程：</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/msg_send_crash.png" alt=""></p><p>类对象的指针和方法缓存列表的偏移是一定的，假设我们拿到了正确的iSA指针，我们就可以通过这行代码得出正确的方法缓存列表的地址。在这里程序抛出了异常Crash掉了，那就可以肯定我们拿到了错误的iSA指针（野指针）。</p><p>通过分析，我们可以确定是我们程序内某些异常的内存操作导致了Crash，系统函数（objc_msgSend）却为我们背了锅。我们小心翼翼的使用weak、strong来管理内存，依旧无法避免内存问题，那么问题究竟出现在什么地方？</p><h3 id="危险的nonatomic"><a href="#危险的nonatomic" class="headerlink" title="危险的nonatomic"></a>危险的nonatomic</h3><p>在刚刚接触iOS开发的时候，我们被告知：系统会默认将属性声明为atomic，但atomic在保障get、set操作原子性的同时伤害了性能，所以我们要将属性声明为nonatomic。那么atomic到底在保护什么？里面又做了什么有害性能的操作？</p><h4 id="setter源码"><a href="#setter源码" class="headerlink" title="setter源码"></a>setter源码</h4><p>我们将目光汇集在runtime源码objc-accessors.mm文件的reallySetProperty函数中。通过阅读这个函数，可以很详细的了解到在atomic和nonatomic下不同的setter机制。为方便阅读，下述代码对reallySetProperty做了一定的简化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic)</span><br><span class="line">&#123;</span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;       </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，atomic 与 nonatomic 的差别在是否对 oldValue = slot; 与 slot = newValue; 两个赋值语句加了自旋锁。那么上面这两个问题的答案是显而易见的。atomic通过对写操作加入自旋锁保障了多线程情况下写操作的安全，同时导致了性能的损失。</p><h3 id="nonatomic可能产生的内存问题"><a href="#nonatomic可能产生的内存问题" class="headerlink" title="nonatomic可能产生的内存问题"></a>nonatomic可能产生的内存问题</h3><h4 id="多次release原始值"><a href="#多次release原始值" class="headerlink" title="多次release原始值"></a>多次release原始值</h4><p>下图展示了nonatomic下两个线程同时调用setter方法时的场景：</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/mutile_error_1.png" alt=""></p><p>很明显，如果不同时保证这两个赋值操作的原子性，必然有概率导致 *slot 中的原始值被 release 两次，而这样就会导致 Crash 的发生。因此，可以得出结论，多线程环境下对的nonatomic修饰的属性进行赋值操作有导致程序Crash的概率。</p><h4 id="错误release新创建的对象"><a href="#错误release新创建的对象" class="headerlink" title="错误release新创建的对象"></a>错误release新创建的对象</h4><p>仔细观察上图展示的问题，假设在thread 1释放obj1占用的内存后又立刻对其进行重新分配值newObj。此时，thread 2 的局部变量oldValue与newObj指向同一块内存空间。会有什么问题产生？wow！oldValue会对刚刚创建的newObj进行release操作！这就给程序带来了更大的不确定性，此时对于newObj的引用计数永远比指向newObj的强引用数少1。也就是在某些未知的情况下newObj就会被释放，导致内存错误。当然，也有可能导致上述的objc_msgSend问题。</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/mutil_error_2.png" alt=""></p><h3 id="atomic-万能药？"><a href="#atomic-万能药？" class="headerlink" title="atomic 万能药？"></a>atomic 万能药？</h3><p>那么，atomic是解决多线程内存管理问题的万能药么？答案是否定的。一起来看以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic,strong)NSArray * array;  </span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 1</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (i % 2) &#123;</span><br><span class="line">               self.array = @[@1,@2,@3];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               self.array = @[@1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 2</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (self.array.count == 3) &#123;</span><br><span class="line">               NSLog(@&quot;obj At Inde 2:%@&quot;,[self.array objectAtIndex:2]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>即使我们将array的内存管理语义设为atomic，同时在访问objectAtIndex:之前加上判断，Thread 2还是会Crash。原因是由于前后两行代码之间array所指向的内存区域被线程1修改了。</p><p>atomic通过加锁确保了对于属性setter、getter操作的原子性。setter、getter操作的是属性的指针值，对于属性指针所指向的内存地址并不能起到保护作用。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>关于多线程下的内存管理还有很多东西要讲，比如：</p><ul><li>memory barrier</li><li>为何标量类型可以用assign</li><li>Atomic Operations</li><li>函数式编程中纯函数的概念</li></ul><p>To Be Continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Crash-操作系统的自我保护&quot;&gt;&lt;a href=&quot;#Crash-操作系统的自我保护&quot; class=&quot;headerlink&quot; title=&quot;Crash-操作系统的自我保护&quot;&gt;&lt;/a&gt;Crash-操作系统的自我保护&lt;/h3&gt;&lt;p&gt;当运行程序出现内存访问异常（访问野指针、数组越界）、内存不足（linux 下内存不足会出发oom_killer杀死当前进程）等异常情况，操作系统为自身的稳定运行会将异常程序KILL（Crash）掉以避免引起更大的问题。Crash是操作系统的一种自我保护机制，在程序Crash之前会收到操作系统发出的SIGSEGV、SIGKILL等信号。操作系统在发出这些指令之后会立即KILL掉异常应用程序。在日常的Crash清理中，通常会有茫茫多的SIGSEGV、SIGKILL Crash问题难以定位。&lt;/p&gt;
&lt;p&gt;日常开发中另一类，难以定位的Crash将矛头指向了某些系统函数，如比较常见的objc_msgSend崩溃，我们将在 Foundation 与 UIKit 等的系统库中的方法称之为系统方法。作为一个乐观者，我们有理由相信系统方法和操作系统本身的稳定性。Crash的原因大概率（肯定）是我们自己代码出了问题，这些问题通常是由于欠妥的内存管理导致的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程 内存管理" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程安全------多线程下的内存管理</title>
    <link href="http://yoursite.com/2019/03/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/10/iOS多线程安全-多线程下的内存管理/</id>
    <published>2019-03-10T05:27:52.000Z</published>
    <updated>2019-03-10T05:28:48.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在继续深入之前一起来考虑几个问题：</p><ul><li>64/32位操作系统，64/32指的是什么？</li><li>OC中标量类型属性修饰符为什么是assign？</li><li>i++是原子操作么？</li><li>atomic保障了什么？</li></ul><a id="more"></a><h3 id="CPU的寻址操作"><a href="#CPU的寻址操作" class="headerlink" title="CPU的寻址操作"></a>CPU的寻址操作</h3><p>我们知道，CPU是通过地址总线寻址，然后通过数据总线存取数据的。</p><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>地址总线的位数决定CPU的寻址范围，若CPU的地址总线宽度是32位，那么CPU的寻址范围是4GB，所以最多支持4G内存。</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>数据总线的位数决定CPU单次通信能交换的信息数量。若数据总线宽度是32位，那么单次交换的信息量为4字节，64位的8字节。这也是为什么C语言中的指针64位下所占空间为8字节，32位下所占空间为4字节。</p><p>我们通常说的64位处理器/32位处理器指的是数据总线的宽度为64位/32位。</p><h4 id="多线程下的寻址操作"><a href="#多线程下的寻址操作" class="headerlink" title="多线程下的寻址操作"></a>多线程下的寻址操作</h4><p>多线程下的内存管理是一个复杂的课题，在继续深入之前，关于CPU多线程下的寻址操作我们需要明确几点：</p><ul><li>地址总线、数据总线都只有一根，所以寻址是串行操作，不存在多个线程同时寻址同一个地址。</li><li>64位下，对于标量类型int、double单次寻址就可以取出，对其存取我们可以理解为原子操作，是多线程安全的。</li><li>32位下单次寻址只可取出4个字节，这种情况下double需要两次寻址才可取出。这种情况下不是线程安全的。</li></ul><h3 id="属性-amp-内存"><a href="#属性-amp-内存" class="headerlink" title="属性&amp;内存"></a>属性&amp;内存</h3><p>以下代码我们为一个SomeObj对象声明了若干属性，并在SomeObj的初始化方法内打印各个实例变量在内存中的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//属性声明</span><br><span class="line"></span><br><span class="line">@property(nonatomic,assign) int int_value;</span><br><span class="line">@property(nonatomic,assign) double double_value;</span><br><span class="line">@property(nonatomic,assign) Rect rect_value;</span><br><span class="line">@property(nonatomic,strong) id obj_Pointer;</span><br><span class="line">@property(nonatomic,assign) int int_value2;</span><br><span class="line"></span><br><span class="line">//init方法</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;address for int value:%p&quot;,&amp;_int_value);</span><br><span class="line">        NSLog(@&quot;address for int value2:%p&quot;,&amp;_int_value2);</span><br><span class="line">        NSLog(@&quot;address for double value:%p&quot;,&amp;_double_value);</span><br><span class="line">        NSLog(@&quot;address for rect value:%p&quot;,&amp;_rect_value);</span><br><span class="line">        NSLog(@&quot;address for pointer value:%p&quot;,&amp;_obj_Pointer);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用init方法，打印各个实例变量的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2018-03-25 16:51:09.284092+0800 MemoryTest[22641:3042100] address for int value:0x600000241598</span><br><span class="line">2018-03-25 16:51:09.284201+0800 MemoryTest[22641:3042100] address for int value2:0x60000024159c</span><br><span class="line">2018-03-25 16:51:09.284286+0800 MemoryTest[22641:3042100] address for double value:0x6000002415a0</span><br><span class="line">2018-03-25 16:51:09.284363+0800 MemoryTest[22641:3042100] address for rect value:0x6000002415a8</span><br><span class="line">2018-03-25 16:51:09.284439+0800 MemoryTest[22641:3042100] address for pointer value:0x6000002415b0</span><br></pre></td></tr></table></figure><p>可以看到，在初始化对象时编译器会在类的内存空间内自动分配实例变量的内存，这些内存会随着对象的销毁而释放。从这个角度看，指针类型和标量类型并没有区别（事实当然不是这样）。需要注意的是这里分配的是指针本身所占的8个字节而不是指针所指向的对象。</p><p>我们可以将内存中存储的数据类型大致分为标量类型、指针的值、指针所指向的内存空间三类，接下来将围绕这三种情况进行展开，一些特殊类型如tagged pointer这里就不做讨论。</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>结合上面提到的，我们可以得出以下结论：</p><ul><li>由于CPU单次寻址就可取出标量类型，对于标量类型的存取操作天然是原子的、线程安全的。</li><li>由于标量类型的存取操作天然是原子的，所以在未重写标量属性的getter/setter方法的情况下getter/setter方法也是原子的。</li><li>标量类型的内存会随着类对象的销毁而释放，这也是为何对于标量类型的属性可以用assign修饰的原因。</li></ul><p>那么标量类型的数据在多线程下就高枕无忧了么？举个栗子，编程中最基本的操作之一是递增整数。这是一项非常普遍的任务，可以用几个等效的操作完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_int_value = 3;</span><br><span class="line"></span><br><span class="line">//等效的三种方式</span><br><span class="line">_int_value++;</span><br><span class="line">_int_value+=1;</span><br><span class="line">_int_value = _int_value + 1;</span><br></pre></td></tr></table></figure><p>然而，看起来像一个操作 - 递增整型变量 - 实际上包含三个不同的步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get _int_value (3)</span><br><span class="line">Perform Addition (3 + 1)</span><br><span class="line">Set _int_value (4)</span><br></pre></td></tr></table></figure><p>单线程下get-add-set这些操作是可以保障顺序执行的。在多线程情况下，就有可能产生线程安全问题。最经典的例子就是火车站多窗口售票系统，在操作余票的时候通过加锁保障线程安全。</p><h3 id="OSAtomic"><a href="#OSAtomic" class="headerlink" title="OSAtomic"></a>OSAtomic</h3><p>尽管，锁是同步两个线程的利器。不可否认的是，锁也是一种相对昂贵的操作。非阻塞性同步是解决多线程同步更优雅的方式。libkern/OSAtomic.h 提供了很多强大的多线程编程工具，虽然它是内核头文件的一部分，但它也可以用于内核和驱动程序编程之外。</p><p>我们将上例中提到的“_int_value++”以Atomic Operations改写后，该操作就是原子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSAtomicIncrement64(&amp;(_int_value));</span><br></pre></td></tr></table></figure><p>事实上，真正的情况还要更复杂：为了提高性能，现代CPU/编译器会按照输入数据和执行单元的可用性的顺序执行指令而不是程序中的原始顺序执行（乱序执行）。</p><h3 id="乱序执行-amp-内存屏障"><a href="#乱序执行-amp-内存屏障" class="headerlink" title="乱序执行 &amp; 内存屏障"></a>乱序执行 &amp; 内存屏障</h3><p>程序是工作在OS/编译器/物理硬件共同营造的虚拟环境中的。程序运行环境有一定的规则以确保程序稳定运行，不同的OS/编译器/CPU有各种不同的实现方式但是规则本身是不变的。</p><p>编译器和CPU在满足前面的规则的时候，总是玩各种小九九，在满足前面”承诺“的规则的前提下，（非有意地）破坏没有承诺的规则。</p><p>CPU：每个CPU都有自己的缓存，为提高数据读写速度，CPU会同自己的缓存交换数据而不是直接读写内存。<br>编译器：为充分利用寄存器和CPU流水线编译器可能会重排指令顺序。</p><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">c=a+b;</span><br><span class="line">printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c);</span><br></pre></td></tr></table></figure><p>上面这个程序序列，作用于程序运行环境的时候，环境规则能承诺的是计算c的时候，a肯定等于1，b肯定等于2。最后打印的时候，c肯定等于3。</p><p>但它没有承诺的是：</p><ul><li>a，b，c是内存上的地址（也可以是寄存器一类的东西）</li><li>a首先变成1，然后b才变成2</li><li>如果其他设备或者CPU修改这些内存地址，反应是什么</li><li>等等</li></ul><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>我们可以通过设置内存屏障来避免CPU/编译器类似的优化，内存屏障可以有两个作用：</p><ul><li>阻止屏障两侧的指令重排。</li><li>强制CPU直接读取内存（volatile）</li></ul><p>上述的libkern/OSAtomic.h同样提供了内存屏障版本的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSAtomicIncrement64Barrier(&amp;(_int_value));</span><br></pre></td></tr></table></figure><p>对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier。官方文档表述如下：</p><blockquote><p>Note: Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p></blockquote><p>GCD中有一个队列屏障的概念，dispatch_barrier_async()，可以轻易的实现安全的可变数组、可变字典（读写锁）。</p><h3 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h3><h4 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h4><p>以C语言来说，32位操作系统下指针的大小为4字节，64位操作下指针的大小为8字节。根据上面的理论，CPU单次寻址可以取出指针，所以指针的存取操作时原子的、线程安全的。</p><h4 id="OC指针"><a href="#OC指针" class="headerlink" title="OC指针"></a>OC指针</h4><p>那么以OC为例呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject* obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure><p>事实上，答案是否定的，或者说从ARC的角度来看答案是否定的。仅仅从指针赋值的角度来看上述操作的确是原子的，但是为支持ARC上述赋值操作会调用在runtime中引入相应的副作用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑：A、B、C三个线程几乎同时对obj进行赋值操作，可能会有什么问题？可能会对同一“prev”调用多次objc_release(prev);从而导致Crash。一个比较类似的Crash是（可能不那么类似）：如果多个线程同时设置UIImageView的image，很可能应用程序会崩溃，因为当前设置的图像可能会被释放两次。</p><p>同样的对于weak类型指针会调用相应的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_storeWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>显然OC中ARC下的指针赋值操作是非原子的。而OC也提供了atomic关键字来保障属性getter/setter操作的“原子性”，调用getter/setter方法同样会调用到runtime的相应方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到atomic 并没有真正保障getter/setter的原子性，而是通过加锁保障了不会对同一个oldValue 调用多次objc_release(oldValue);操作，从而保障了线程安全，同时也导致了性能的损耗。</p><h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h3><p>那么，atomic是解决多线程内存管理问题的万能药么？答案是否定的。一起来看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic,strong)NSArray * array;  </span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 1</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (i % 2) &#123;</span><br><span class="line">               self.array = @[@1,@2,@3];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               self.array = @[@1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 2</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (self.array.count == 3) &#123;</span><br><span class="line">               NSLog(@&quot;obj At Inde 2:%@&quot;,[self.array objectAtIndex:2]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>即使我们将array的内存管理语义设为atomic，同时在访问objectAtIndex:之前加上判断，Thread 2还是会Crash。原因是由于前后两行代码之间array所指向的内存区域被线程1修改了。</p><p>atomic通过加锁确保了对于属性setter、getter访问的线程安全问题。setter、getter操作的是属性的指针值，对于属性指针所指向的内存地址并不能起到保护作用。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>多线程是一个复杂的课题，从pThread、NSThread、GCD、NSOperation，API的选择、优劣到多线程开发面临的挑战竞态条件、死锁、线程饥饿、优先级反转，再到如何编写性能优异安全的多线程代码。</p><p>To be continue…</p><p>=</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在继续深入之前一起来考虑几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64/32位操作系统，64/32指的是什么？&lt;/li&gt;
&lt;li&gt;OC中标量类型属性修饰符为什么是assign？&lt;/li&gt;
&lt;li&gt;i++是原子操作么？&lt;/li&gt;
&lt;li&gt;atomic保障了什么？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="多线程 内存管理" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>源码解析------TMCache</title>
    <link href="http://yoursite.com/2019/03/10/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-TMCache/"/>
    <id>http://yoursite.com/2019/03/10/源码解析-TMCache/</id>
    <published>2019-03-10T05:25:32.000Z</published>
    <updated>2019-03-10T05:26:57.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码解析——TMCache"><a href="#源码解析——TMCache" class="headerlink" title="源码解析——TMCache"></a>源码解析——TMCache</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文为阅读TMCache源码后所产，TMCache由著名网站tumblr开发虽然目前已停止维护，源码中还是有很多值得借鉴的点。客户端缓存从硬件介质上来看，无非就是内存和磁盘两种。在TMCache中分别对应TMMemoryCache（内存级别缓存）、TMDiskCache（磁盘级别缓存）。通常来讲磁盘缓存由于涉及磁盘IO、文件编解码较内存缓存而言会更复杂一些。本文中笔者将循着TMCache的实现分析TMMemoryCache、TMDiskCache源码中一些平时开发中值得借鉴的点(红榜)及一些需要避免的点（黑榜）。</p><p>PS：为方便阅读、聚焦本文讨论的key点，本文中对所引入的TMCache源码进行不同程度的精简。</p><a id="more"></a><h3 id="TMMemoryCache"><a href="#TMMemoryCache" class="headerlink" title="TMMemoryCache"></a>TMMemoryCache</h3><p>TMMemoryCache提供了线程安全的同步/异步读写内存的API。对于内存缓存而言并行读、串行写是刚需（即读写锁），TMMemoryCache对于读写线程安全访问控制及异步转同步的实现值得借鉴。</p><h4 id="TMMemoryCache红榜之读写锁实现"><a href="#TMMemoryCache红榜之读写锁实现" class="headerlink" title="TMMemoryCache红榜之读写锁实现"></a>TMMemoryCache红榜之读写锁实现</h4><p>TMMemoryCache通过GCD并发队列及 <a href="https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async" target="_blank" rel="noopener">dispatch_barrier_async()</a>实现并发读、串行写的线程安全访问。</p><h5 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h5><p>一个比较关键的概念是：dispatch_barrier_async(),dispatch_barrier_async()是GCD提供的类似“内存屏障”的“队列屏障”。dispatch_barrier_async()在GCD并发队列的任务调度中起到一个栅栏的作用，dispatch_barrier_async()提交到队列里的任务会等待之前的任务执行完毕，再开始执行。且dispatch_barrier_async()提交到队列里的任务执行完毕后才会执行之后之后提交到队列里的任务。一图以蔽之：</p><p><img src="/2019/03/10/源码解析-TMCache/barrier_async.png" alt=""></p><p>TMMemoryCache中读写操作都是在一个 concurrent queue(并发队列)中, 通过 dispatch_barrier_async() 保障在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心。</p><h5 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h5><p>一起来看一下简化后的源码：</p><h6 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)objectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMMemoryCache *weakSelf = self;</span><br><span class="line">    dispatch_async(_queue, ^&#123;</span><br><span class="line">        TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        id object = [strongSelf-&gt;_dictionary objectForKey:key];</span><br><span class="line"></span><br><span class="line">        block(strongSelf, key, object);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMMemoryCache *weakSelf = self;</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line"></span><br><span class="line">        TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        [strongSelf-&gt;_dictionary setObject:object forKey:key];</span><br><span class="line"></span><br><span class="line">        if (block) &#123;</span><br><span class="line">            __weak TMMemoryCache *weakSelf = strongSelf;</span><br><span class="line">            dispatch_async(strongSelf-&gt;_queue, ^&#123;</span><br><span class="line">                TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">                if (strongSelf)</span><br><span class="line">                    block(strongSelf, key, object);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMMemoryCache红榜之异步转同步实现"><a href="#TMMemoryCache红榜之异步转同步实现" class="headerlink" title="TMMemoryCache红榜之异步转同步实现"></a>TMMemoryCache红榜之异步转同步实现</h4><p>TMMemoryCache的同步方法是通过在调用异步方法的过程中插入dispatch_semaphore_t信号量实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost</span><br><span class="line">&#123;</span><br><span class="line">    if (!object || !key)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    [self setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, NSString *key, id object) &#123;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    #if !OS_OBJECT_USE_OBJC</span><br><span class="line">    dispatch_release(semaphore);</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMMemoryCache黑榜之线程爆炸"><a href="#TMMemoryCache黑榜之线程爆炸" class="headerlink" title="TMMemoryCache黑榜之线程爆炸"></a>TMMemoryCache黑榜之线程爆炸</h4><p>在实际使用过程中，通过GCD Barrier来保证读写同步在一定程度上是可行的，但在并发量很大的情况，会造成线程爆炸，严重情况下会因为线程资源消耗而导致死锁。一起来看一个例子，我们通过以下代码来模拟通过TMMemoryCache高并发下读写缓存的case：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define TIMES 1000000</span><br><span class="line"></span><br><span class="line">dispatch_queue_t testQueue = dispatch_queue_create([@&quot;com.tmcache.test&quot; UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">for (NSInteger index = 0; index &lt; TIMES; ++index) &#123;</span><br><span class="line">    if (index % 10 == 9) &#123;</span><br><span class="line">        dispatch_async(testQueue, ^&#123;</span><br><span class="line">            [[TMMemoryCache sharedCache] setObject:@(index) forKey:[@(index) stringValue] block:^(TMMemoryCache *cache, NSString *key, id object) &#123;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(testQueue, ^&#123;</span><br><span class="line">            [[TMMemoryCache sharedCache] objectForKey:[@(index) stringValue]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过断点看一下执行过程中的线程状况：</p><p><img src="/2019/03/10/源码解析-TMCache/thread_baozha.png" alt=""></p><p>其实在当前case下已经产生死锁了。</p><p>这是由于GCD的特性导致的。GCD创建了一个大致与内核数量相匹配的线程池，如果我们向GCD提交了一个任务，并且该任务阻塞了该线程。为了弥补线程被阻塞的损失，GCD会创建一个新的线程并将其添加到线程池中，这就是线程爆炸的根本原因。同时，由于线程并不是免费资源，每一个线程都需要固定的内存（用于存储线程局部信息函数调用栈等）和内核（用于线程调度）资源，大量分配线程会导致内核资源耗尽导致死锁。</p><p>这也是平时开发中需要注意的点：对于高并发下的读写操作应避免使用GCD Barrier，可以通过封装NSLock实现一个自定义的读写锁。</p><h3 id="TMDiskCache"><a href="#TMDiskCache" class="headerlink" title="TMDiskCache"></a>TMDiskCache</h3><p>TMDiskCache的实现形式是基于文件读写的。TMDiskCache同样提供了线程安全的同步/异步读写磁盘的API。其异步转同步思路与TMMemoryCache一致这里不再赘述。关于TMDiskCache我们关注的重点不再是线程安全（TMDiskCache所有的读写操作都在一个 serial queue 串行队列中, 不存在竞态情况,），而作者根据磁盘缓存的特性对于API的选择很有借鉴意义。</p><h4 id="TMDiskCache红榜之serial-queue"><a href="#TMDiskCache红榜之serial-queue" class="headerlink" title="TMDiskCache红榜之serial queue"></a>TMDiskCache红榜之serial queue</h4><p>不同于TMMemoryCache，TMCache的作者将TMDiskCache的读写操作放在了一个 serial queue。这是由于磁盘存取的速度瓶颈在磁盘IO上，和是否多线程存取没有太大关系。磁盘IO是一个很复杂的课题，这里只列出几点关于TMCache作者选用serial queue的猜想，不做展开讨论。</p><h5 id="磁盘IO调度层本身就是串行"><a href="#磁盘IO调度层本身就是串行" class="headerlink" title="磁盘IO调度层本身就是串行"></a>磁盘IO调度层本身就是串行</h5><p>调用上层API产生的磁盘IO请求会被放到IO调度层，在IO调度层会缓存请求并试图合并请求，最终内核根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I/O请求。而磁盘I/O调度层本身的调度策略就是串行的，这主要是由于目前计算机体系结构下磁盘是不支持多磁头同时读写的。</p><h5 id="磁盘Cache层提供了足够的优化"><a href="#磁盘Cache层提供了足够的优化" class="headerlink" title="磁盘Cache层提供了足够的优化"></a>磁盘Cache层提供了足够的优化</h5><p>磁盘Cache层在内存中缓存了磁盘上的部分数据。当数据请求到达时，如果Cache存在数据且是最新的，则将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。</p><p>磁盘Cache有两大功能：预读和回写。</p><h6 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h6><p>预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读的页面中，这时继续进行异步预读；第二种情况是所请求的页面处于预读页面之外，这时系统就要进行同步预读。</p><h6 id="回写"><a href="#回写" class="headerlink" title="回写"></a>回写</h6><p>回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。通过这种异步的数据I/O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，减少了访问底层存储介质的次数，使存储系统的性能大大提高。</p><h5 id="多线程下的磁盘I-0"><a href="#多线程下的磁盘I-0" class="headerlink" title="多线程下的磁盘I/0"></a>多线程下的磁盘I/0</h5><p>有了这些基础我们再来分别看一下多个线程调用读和写分别会发生什么。</p><h6 id="多个线程同时读"><a href="#多个线程同时读" class="headerlink" title="多个线程同时读"></a>多个线程同时读</h6><p>在未命中磁盘Cache的情况下，会提交多个I/O任务到磁盘I/O调度层。可能依靠IO调度层本身的调度算法及对于同一文件I/O请求的合并带来效率上的些许提升。但是比起CPU消耗及多个线程上下文切换其意义并不是很大。而且对于同一文件I/O请求在串行发起多次的情况下，除第一次I/O请求会读磁盘外其余都会命中磁盘Cache，所以I/O调度层对于同一文件I/O请求的合并不会带来实际的意义。</p><h6 id="多个线程同时写"><a href="#多个线程同时写" class="headerlink" title="多个线程同时写"></a>多个线程同时写</h6><p>根据磁盘Cache的回写功能，不难看出多线程同时写只是更快的填满了写缓冲区，并不会带来实际意义上的效率提升。</p><h4 id="TMDiskCache红榜之文件删除"><a href="#TMDiskCache红榜之文件删除" class="headerlink" title="TMDiskCache红榜之文件删除"></a>TMDiskCache红榜之文件删除</h4><p>关于文件删除TMDiskCache的实现方案是将待删除文件移至tmp文件夹，然后将具体的删除任务丢到优先级最低的DISPATCH_QUEUE_PRIORITY_BACKGROUND去做。这样只有在程序真正空闲时才会处理具体删除操作。如果程序最终都没有处理删除操作在程序，在程序结束后系统会自动删除tmp文件夹内的文件。一起来看一下相关源码吧：</p><h5 id="文件删除源码"><a href="#文件删除源码" class="headerlink" title="文件删除源码"></a>文件删除源码</h5><p>共享的文件删除队列（DISPATCH_QUEUE_PRIORITY_BACKGROUND优先级）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (dispatch_queue_t)sharedTrashQueue</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_queue_t trashQueue;</span><br><span class="line">    static dispatch_once_t predicate;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">        NSString *queueName = [[NSString alloc] initWithFormat:@&quot;%@.trash&quot;, TMDiskCachePrefix];</span><br><span class="line">        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return trashQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享的存放删除文件的tmp文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURL *)sharedTrashURL</span><br><span class="line">&#123;</span><br><span class="line">    static NSURL *sharedTrashURL;</span><br><span class="line">    static dispatch_once_t predicate;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">        //临时文件夹</span><br><span class="line">        sharedTrashURL = [[[NSURL alloc] initFileURLWithPath:NSTemporaryDirectory()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:YES];</span><br><span class="line">        </span><br><span class="line">        if (![[NSFileManager defaultManager] fileExistsAtPath:[sharedTrashURL path]]) &#123;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            [[NSFileManager defaultManager] createDirectoryAtURL:sharedTrashURL</span><br><span class="line">                                     withIntermediateDirectories:YES</span><br><span class="line">                                                      attributes:nil</span><br><span class="line">                                                           error:&amp;error];</span><br><span class="line">            TMDiskCacheError(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return sharedTrashURL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待删除文件移动至tmp文件夹，这里另外一个点是通过调用[[NSProcessInfo processInfo] globallyUniqueString]生成了一个临时文件名，该方法会确保每次“调用”会不一样，所以不会产生相同的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)moveItemAtURLToTrash:(NSURL *)itemURL</span><br><span class="line">&#123;</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:[itemURL path]])</span><br><span class="line">        return NO;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSString *uniqueString = [[NSProcessInfo processInfo] globallyUniqueString]; //每次&quot;调用&quot;会不一样，可以用作一些临时缓存文件的名字</span><br><span class="line">    NSURL *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];</span><br><span class="line">    BOOL moved = [[NSFileManager defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&amp;error];</span><br><span class="line">    TMDiskCacheError(error);</span><br><span class="line">    return moved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空操作，遍历并删除tmp文件夹下所有文件，该任务被丢到DISPATCH_QUEUE_PRIORITY_BACKGROUND优先级队列中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)emptyTrash</span><br><span class="line">&#123;</span><br><span class="line">    UIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</span><br><span class="line">    </span><br><span class="line">    dispatch_async([self sharedTrashQueue], ^&#123;        </span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        NSArray *trashedItems = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[self sharedTrashURL]</span><br><span class="line">                                                              includingPropertiesForKeys:nil</span><br><span class="line">                                                                                 options:0</span><br><span class="line">                                                                                   error:&amp;error];</span><br><span class="line">        TMDiskCacheError(error);</span><br><span class="line"></span><br><span class="line">        for (NSURL *trashedItemURL in trashedItems) &#123;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            [[NSFileManager defaultManager] removeItemAtURL:trashedItemURL error:&amp;error];</span><br><span class="line">            TMDiskCacheError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMDiskCache黑榜之不当API使用"><a href="#TMDiskCache黑榜之不当API使用" class="headerlink" title="TMDiskCache黑榜之不当API使用"></a>TMDiskCache黑榜之不当API使用</h4><p>一起来看TMDiskCache中以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAgeLimit:(NSTimeInterval)ageLimit</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMDiskCache *weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        TMDiskCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        strongSelf-&gt;_ageLimit = ageLimit;</span><br><span class="line">        </span><br><span class="line">        [strongSelf trimToAgeLimitRecursively];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意两点：</p><ol><li>_queue 为串行队列</li><li>使用了dispatch_barrier_async()栅栏函数</li></ol><p>所以上面的代码是在串行队列中使用了栅栏函数？？难道串行队列不是保障了任务按入队顺序依次执行且上一个执行完毕才会执行下一个？？关于<a href="https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async" target="_blank" rel="noopener">dispatch_barrier_async()</a>一起来看一下苹果爸爸怎么说：</p><blockquote><p>The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_async function.</p></blockquote><p>如果我们传入非自定义队列或串行队列那使用dispatch_barrier_async()函数就等于是在用 dispatch_async()。滥用API有木有，虽然不会产生性能、质量上的影响但的确是一个槽点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;源码解析——TMCache&quot;&gt;&lt;a href=&quot;#源码解析——TMCache&quot; class=&quot;headerlink&quot; title=&quot;源码解析——TMCache&quot;&gt;&lt;/a&gt;源码解析——TMCache&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本文为阅读TMCache源码后所产，TMCache由著名网站tumblr开发虽然目前已停止维护，源码中还是有很多值得借鉴的点。客户端缓存从硬件介质上来看，无非就是内存和磁盘两种。在TMCache中分别对应TMMemoryCache（内存级别缓存）、TMDiskCache（磁盘级别缓存）。通常来讲磁盘缓存由于涉及磁盘IO、文件编解码较内存缓存而言会更复杂一些。本文中笔者将循着TMCache的实现分析TMMemoryCache、TMDiskCache源码中一些平时开发中值得借鉴的点(红榜)及一些需要避免的点（黑榜）。&lt;/p&gt;
&lt;p&gt;PS：为方便阅读、聚焦本文讨论的key点，本文中对所引入的TMCache源码进行不同程度的精简。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>性能调优------卡顿监控</title>
    <link href="http://yoursite.com/2019/03/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/10/性能调优-卡顿监控/</id>
    <published>2019-03-10T05:23:22.000Z</published>
    <updated>2019-03-10T05:24:07.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文将循着<a href="https://cloud.tencent.com/developer/article/1030608" target="_blank" rel="noopener">微信iOS卡顿监控系统</a>的思路：起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来。做一个简单的deom，体验一把。</p><a id="more"></a><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>废话少说，直接撸代码。首先创建一个NSThread的子类BWKPingThread。</p><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>一个简单的初始化方法，入参为卡顿监测的时间阈值，超过该阈值即上报卡顿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithThreshold:(NSInteger)threshold;</span><br></pre></td></tr></table></figure><h3 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h3><h4 id="类拓展"><a href="#类拓展" class="headerlink" title="类拓展"></a>类拓展</h4><p>在类拓展中声明三个属性：</p><ul><li>threshold：存储卡端监测时间阈值</li><li>pingSemaphore：用于卡端监控的信号量</li><li>runloopObserver：用于监控主线程runloop的observer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface BWKPingThread()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger threshold;</span><br><span class="line">@property (nonatomic, strong) dispatch_semaphore_t pingSemaphore;</span><br><span class="line">@property (nonatomic, assign) CFRunLoopObserverRef runloopObserver;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="init方法-amp-addRunloopObserver方法"><a href="#init方法-amp-addRunloopObserver方法" class="headerlink" title="init方法 &amp; addRunloopObserver方法"></a>init方法 &amp; addRunloopObserver方法</h4><p>初始化工作，添加observer观测主线程runloop，在没一个runloop回调中调用dispatch_semaphore_signal()自增信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithThreshold:(NSInteger)threshold&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _threshold = threshold;</span><br><span class="line">        _pingSemaphore = dispatch_semaphore_create(0);</span><br><span class="line">        [self addRunloopObserver];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addRunloopObserver</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    CFRunLoopActivity observedActivities = kCFRunLoopBeforeSources | kCFRunLoopBeforeWaiting | kCFRunLoopAfterWaiting;</span><br><span class="line">    _runloopObserver = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, observedActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        __strong __typeof(self) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf.pingSemaphore != NULL) &#123;</span><br><span class="line">            dispatch_semaphore_signal(strongSelf.pingSemaphore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), _runloopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(_runloopObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>重写NSThread的main方法，调用dispatch_semaphore_wait()等待信号量的释放，如果等待时间超过阈值，则监测到主线程阻塞、上报卡顿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">    while (!self.cancelled) &#123;</span><br><span class="line">        long status = dispatch_semaphore_wait(self.pingSemaphore, dispatch_time(DISPATCH_TIME_NOW, self.threshold * NSEC_PER_MSEC));</span><br><span class="line">        if (status != 0) &#123;</span><br><span class="line">            NSLog(@&quot;The main thread is blocked.&quot;);</span><br><span class="line">            dispatch_semaphore_wait(self.pingSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><p>重写cancel方法，移除observer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel</span><br><span class="line">&#123;</span><br><span class="line">    [super cancel];</span><br><span class="line">    dispatch_semaphore_signal(self.pingSemaphore);</span><br><span class="line">    if (self.runloopObserver) &#123;</span><br><span class="line">        CFRunLoopObserverInvalidate(self.runloopObserver);</span><br><span class="line">        self.runloopObserver = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>我们在主线程中创建pingThread，并通过模拟耗时操作阻塞主线程以测试卡顿监测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BWKPingThread * pingThread = [[BWKPingThread alloc] initWithThreshold:1];</span><br><span class="line"></span><br><span class="line">[pingThread start];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    //耗时操作</span><br><span class="line">    for (int  i = 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过控制台log可以看到成功监测到卡顿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-04-21 21:20:20.309915+0800 Ping_Demo[98239:5860372] The main thread is blocked.</span><br></pre></td></tr></table></figure><h3 id="卡顿堆栈？"><a href="#卡顿堆栈？" class="headerlink" title="卡顿堆栈？"></a>卡顿堆栈？</h3><p>这里推荐一个三方库<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>。通过plcrashreporter可以拿到所有线程堆栈，国内很多Crash上报平台都是通过plcrashreporter实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本文将循着&lt;a href=&quot;https://cloud.tencent.com/developer/article/1030608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信iOS卡顿监控系统&lt;/a&gt;的思路：起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来。做一个简单的deom，体验一把。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------Priority_Queue实现</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Priority-Queue%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Priority-Queue实现/</id>
    <published>2019-03-10T05:21:18.000Z</published>
    <updated>2019-03-10T05:22:54.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法设计——Priority-Queue实现"><a href="#算法设计——Priority-Queue实现" class="headerlink" title="算法设计——Priority_Queue实现"></a>算法设计——Priority_Queue实现</h2><h3 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h3><blockquote><p>普通队列是一种先进先出（FIFO）的数据结构。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高优先先出（first in，lagest out）的行为特征。</p></blockquote><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>使用排序和数组可以简单的实现Priority Queue，插入到列表的时间复杂度为𝑂（𝑛），排序列表的时间复杂度为𝑂(𝑛log𝑛)。更优的方式是使用大顶堆（小顶堆），以大顶堆（小顶堆）实现的Priority Queue的出队、入队时间复杂度均为𝑂(log 𝑛)。</p><a id="more"></a><h3 id="二进制堆"><a href="#二进制堆" class="headerlink" title="二进制堆"></a>二进制堆</h3><blockquote><ol><li>堆中某个节点的值总是不大于或不小于其父节点的值（分别为大顶堆和小顶堆）。</li><li>堆是一颗完全二叉树。</li></ol></blockquote><p>从二叉树角度来看大顶堆：</p><p><img src="/2019/03/10/算法设计-Priority-Queue实现/heap.png" alt=""></p><p>以数组存储该大顶堆：</p><p><img src="/2019/03/10/算法设计-Priority-Queue实现/array.png" alt=""></p><p>子节点与父节点的关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_left = p * 2;</span><br><span class="line">p_right = p * 2 + 1;</span><br></pre></td></tr></table></figure><h3 id="调整堆（出队、入队操作）"><a href="#调整堆（出队、入队操作）" class="headerlink" title="调整堆（出队、入队操作）"></a>调整堆（出队、入队操作）</h3><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ol><li>新元素插在树的末尾，如果树的最后一层已满，添加一层。</li><li>如果插入元素打破大顶堆（小顶堆）的结构，与其父节点交换。</li><li>重复第二步直至满足大顶堆（小顶堆）的结构。</li></ol><p>入队时间复杂度： 𝑂(log 𝑛)</p><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><ol><li>交换根节点元素与最后一个元素，删除根节点元素（现在是最后一个元素）。</li><li>如果交换后的根节点打破大顶堆的结构，与其较大的孩子节点交换。</li><li>重复第二部直至满足大顶堆结构。</li></ol><p>出队时间复杂度：𝑂(log 𝑛)</p><h3 id="堆调整的可视化演示"><a href="#堆调整的可视化演示" class="headerlink" title="堆调整的可视化演示"></a>堆调整的可视化演示</h3><p><a href="https://visualgo.net/en/heap?slide=1" target="_blank" rel="noopener">堆 可视化演示</a></p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><h4 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;stdbool.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct priority_Queue_Node&#123;</span><br><span class="line">    int priority;//优先级</span><br><span class="line">    int member;//数据域</span><br><span class="line">&#125;Priority_Queue_Node, * p_Priority_Node;</span><br><span class="line"></span><br><span class="line">typedef struct priority_Queue&#123;</span><br><span class="line">    Priority_Queue_Node * nodeList;</span><br><span class="line">    int length;//已分配内存长度</span><br><span class="line">    int contentLength;//当前内容长度</span><br><span class="line">&#125;Priority_Queue, * p_Priority_Queue;</span><br><span class="line"></span><br><span class="line">void InitPriorityQueue(p_Priority_Queue queue, int n);//初始化</span><br><span class="line">bool Insert(p_Priority_Queue queue, int member,int priority);//入队</span><br><span class="line">bool Empty(p_Priority_Queue queue);//判空</span><br><span class="line">int RemoveTop(p_Priority_Queue queue);//出队</span><br><span class="line">void travelPriorityQueue(p_Priority_Queue queue);//遍历</span><br></pre></td></tr></table></figure><h4 id="c文件"><a href="#c文件" class="headerlink" title=".c文件"></a>.c文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Priority_Queue.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">void adjustAfterInsert(p_Priority_Queue queue);</span><br><span class="line">void adjustAfterRemove(p_Priority_Queue queue);</span><br><span class="line">void swap(p_Priority_Node node1,p_Priority_Node node2);</span><br><span class="line"></span><br><span class="line">void InitPriorityQueue(p_Priority_Queue queue, int n)&#123;</span><br><span class="line">    Priority_Queue_Node * nodeList = malloc(sizeof(Priority_Queue_Node) * 2);</span><br><span class="line">    if (nodeList == NULL) &#123;</span><br><span class="line">        printf(&quot;分配内存失败&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    queue -&gt; nodeList = nodeList;</span><br><span class="line">    queue -&gt; length = n;</span><br><span class="line">    queue -&gt; contentLength = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckPriority(p_Priority_Queue queue, int priority)&#123;</span><br><span class="line">    int position = 0;</span><br><span class="line">    bool legal = true;</span><br><span class="line">    while (position &lt; queue -&gt; contentLength) &#123;</span><br><span class="line">        if ((queue -&gt; nodeList + position) -&gt; priority == priority ) &#123;</span><br><span class="line">            printf(&quot;非法优先级&quot;);</span><br><span class="line">            legal = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        position ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return legal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert(p_Priority_Queue queue, int member,int priority)&#123;</span><br><span class="line">    if (!CheckPriority(queue, priority)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (queue -&gt; length == queue -&gt; contentLength) &#123;</span><br><span class="line">        queue -&gt; length *= 2;</span><br><span class="line">        queue -&gt; nodeList = realloc(queue -&gt; nodeList, sizeof(Priority_Queue_Node) * queue -&gt; length);</span><br><span class="line">        if (NULL == queue -&gt; nodeList) &#123;</span><br><span class="line">            printf(&quot;分配内存失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int contentLength = queue -&gt; contentLength;</span><br><span class="line">    p_Priority_Node node = queue -&gt; nodeList + contentLength;</span><br><span class="line">    node -&gt; member = member;</span><br><span class="line">    node -&gt; priority = priority;</span><br><span class="line">    queue -&gt; contentLength += 1;</span><br><span class="line">    adjustAfterInsert(queue);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Insert %d with pri %d\n&quot;,member,priority);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int RemoveTop(p_Priority_Queue queue)&#123;</span><br><span class="line"></span><br><span class="line">    int return_val;</span><br><span class="line">    if (Empty(queue)) &#123;</span><br><span class="line">        printf(&quot;Queue is empty&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        p_Priority_Node pNode = queue -&gt; nodeList;</span><br><span class="line">        return_val = pNode -&gt; member;</span><br><span class="line">        swap(&amp;(queue -&gt; nodeList)[0], &amp;(queue -&gt; nodeList)[queue -&gt; contentLength - 1]);</span><br><span class="line">        queue -&gt; contentLength -= 1;</span><br><span class="line">        adjustAfterRemove(queue);</span><br><span class="line">        printf(&quot;removeValue %d\n&quot;,return_val);</span><br><span class="line">        return return_val;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Empty(p_Priority_Queue queue)&#123;</span><br><span class="line">    if (0 == queue -&gt; contentLength) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void travelPriorityQueue(p_Priority_Queue queue)&#123;</span><br><span class="line">    if (Empty(queue)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int position = 0;</span><br><span class="line">    while (position &lt; queue -&gt; contentLength) &#123;</span><br><span class="line">        printf(&quot;member --- %d with %d ---- priority\n&quot;,(queue -&gt; nodeList + position) -&gt; member , (queue -&gt; nodeList + position) -&gt; priority );</span><br><span class="line">        position++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队后调整</span><br><span class="line">void adjustAfterInsert(p_Priority_Queue queue)&#123;</span><br><span class="line">    int insertPosition = queue -&gt; contentLength - 1;</span><br><span class="line">    while (insertPosition) &#123;</span><br><span class="line">        int swapPosition = insertPosition / 2;</span><br><span class="line">        p_Priority_Node swapNode = &amp;(queue -&gt; nodeList)[swapPosition];</span><br><span class="line">        p_Priority_Node insertNode = &amp;(queue -&gt; nodeList)[insertPosition];</span><br><span class="line">        if (swapNode -&gt; priority &lt; insertNode -&gt; priority) &#123;</span><br><span class="line">            swap(swapNode, insertNode);</span><br><span class="line">            insertPosition = swapPosition;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出队后调整</span><br><span class="line">void adjustAfterRemove(p_Priority_Queue queue)&#123;</span><br><span class="line">    int parent = 1;</span><br><span class="line">    while (parent * 2 &lt;= queue -&gt; contentLength) &#123;</span><br><span class="line">        int left = parent * 2;</span><br><span class="line">        int right = (parent * 2 + 1);</span><br><span class="line">        if (right &gt; queue -&gt; contentLength) &#123;</span><br><span class="line">            right = queue -&gt; contentLength;</span><br><span class="line">        &#125;</span><br><span class="line">        p_Priority_Node parentNode = &amp;(queue -&gt; nodeList)[parent - 1];</span><br><span class="line">        p_Priority_Node leftNode = &amp;(queue -&gt; nodeList)[left -1];</span><br><span class="line">        p_Priority_Node rightNode = &amp;(queue -&gt; nodeList)[right -1];</span><br><span class="line">        p_Priority_Node swapNode;</span><br><span class="line">        if (leftNode -&gt; priority &gt;= rightNode -&gt; priority) &#123;</span><br><span class="line">            parent = left;</span><br><span class="line">            swapNode = leftNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            parent = right;</span><br><span class="line">            swapNode = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (swapNode -&gt; priority &gt;= parentNode -&gt; priority) &#123;</span><br><span class="line">            swap(parentNode, swapNode);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(p_Priority_Node node1,p_Priority_Node node2)&#123;</span><br><span class="line">    p_Priority_Node tempNode = malloc(sizeof(Priority_Queue_Node));</span><br><span class="line">    </span><br><span class="line">    if (NULL == tempNode) &#123;</span><br><span class="line">        printf(&quot;分配内存失败&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tempNode -&gt; priority = node1 -&gt; priority;</span><br><span class="line">    tempNode -&gt; member = node1 -&gt; member;</span><br><span class="line">    </span><br><span class="line">    node1 -&gt; member = node2 -&gt; member;</span><br><span class="line">    node1 -&gt; priority = node2 -&gt; priority;</span><br><span class="line">    </span><br><span class="line">    node2 -&gt; priority = tempNode -&gt; priority;</span><br><span class="line">    node2 -&gt; member = tempNode -&gt; member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void testPriorityQueue()&#123;</span><br><span class="line">    Priority_Queue queue;</span><br><span class="line">    InitPriorityQueue(&amp;queue, 2);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        int pr = arc4random() % 100;</span><br><span class="line">        int member = arc4random() % 100;</span><br><span class="line">        Insert(&amp;queue, member, pr);</span><br><span class="line">        printf(&quot;================================================\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        RemoveTop(&amp;queue);</span><br><span class="line">        travelPriorityQueue(&amp;queue);</span><br><span class="line">        printf(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>由于堆调整是不稳定的，同优先级元素出队顺序是不定的，这里不允许插入同优先级元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法设计——Priority-Queue实现&quot;&gt;&lt;a href=&quot;#算法设计——Priority-Queue实现&quot; class=&quot;headerlink&quot; title=&quot;算法设计——Priority_Queue实现&quot;&gt;&lt;/a&gt;算法设计——Priority_Queue实现&lt;/h2&gt;&lt;h3 id=&quot;Priority-Queue&quot;&gt;&lt;a href=&quot;#Priority-Queue&quot; class=&quot;headerlink&quot; title=&quot;Priority Queue&quot;&gt;&lt;/a&gt;Priority Queue&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;普通队列是一种先进先出（FIFO）的数据结构。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高优先先出（first in，lagest out）的行为特征。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现方案&quot;&gt;&lt;a href=&quot;#实现方案&quot; class=&quot;headerlink&quot; title=&quot;实现方案&quot;&gt;&lt;/a&gt;实现方案&lt;/h3&gt;&lt;p&gt;使用排序和数组可以简单的实现Priority Queue，插入到列表的时间复杂度为𝑂（𝑛），排序列表的时间复杂度为𝑂(𝑛log𝑛)。更优的方式是使用大顶堆（小顶堆），以大顶堆（小顶堆）实现的Priority Queue的出队、入队时间复杂度均为𝑂(log 𝑛)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------LowestCommenAncestor</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-LowestCommenAncestor/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-LowestCommenAncestor/</id>
    <published>2019-03-10T05:19:28.000Z</published>
    <updated>2019-03-10T05:20:47.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法设计——Lowest-Commen-Ancestor"><a href="#算法设计——Lowest-Commen-Ancestor" class="headerlink" title="算法设计——Lowest Commen Ancestor"></a>算法设计——Lowest Commen Ancestor</h2><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>给定一个二叉树，找到两个节点NA， NB的最近公共祖先(LCA)。</p><p>方便理解、比如对于下图:</p><p><img src="/2019/03/10/算法设计-LowestCommenAncestor/lca.png" alt=""></p><a id="more"></a><h3 id="Binary-Search-Tree-的LCA"><a href="#Binary-Search-Tree-的LCA" class="headerlink" title="Binary Search Tree 的LCA"></a>Binary Search Tree 的LCA</h3><p>在二叉搜索树中，利用BST属性，我们可以在O（h）时间找到LCA，其中h是树的高度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 查找n1和n2的公共祖先，该函数假定 n1、n2存在于Binary Search Tree上*/</span><br><span class="line">pLCA_Node lca(pLCA_Node root, int n1, int n2)</span><br><span class="line">&#123;</span><br><span class="line">    while (root != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果n1 ,n2都比根小，LCA存在于左子树</span><br><span class="line">        if (root-&gt;member &gt; n1 &amp;&amp; root-&gt;member &gt; n2)</span><br><span class="line">            root = root-&gt;left_Child;</span><br><span class="line">        </span><br><span class="line">        // 如果n1 ,n2都比根小，LCA存在于右子树</span><br><span class="line">        else if (root-&gt;member &lt; n1 &amp;&amp; root-&gt;member &lt; n2)</span><br><span class="line">            root = root-&gt;right_Child;</span><br><span class="line">        </span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通二叉树的LCA"><a href="#普通二叉树的LCA" class="headerlink" title="普通二叉树的LCA"></a>普通二叉树的LCA</h3><p>普通二叉树节点无特殊规律，无法按上述逻辑实现，对于普通二叉树NA、NB的公共祖先可分为以下三种情况（假定NA、NB存在于二叉树）：</p><ul><li>给定键NA或NB与root匹配，则root为LCA</li><li>NA、NB 分别在root的两边，LCA为root</li><li>NA、NB均位于左子树（或右子树），则LCA位于左子树（或右子树）</li></ul><p>通过单次遍历二叉树查找LCA，时间复杂度为O（n）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果mem1 或 mem2 与root 匹配，则根为LCA</span><br><span class="line">    if (root -&gt; member == mem1 || root -&gt; member == mem2) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在左子树、右子树查找最近公共祖先</span><br><span class="line">    pLCA_Node left_lca = findLCA(root -&gt; left_Child, mem1, mem2);</span><br><span class="line">    pLCA_Node right_lca = findLCA(root -&gt; right_Child, mem1, mem2);</span><br><span class="line"></span><br><span class="line">    //mem1、mem2 分别在root的两边，LCA为root</span><br><span class="line">    if (left_lca &amp;&amp; right_lca) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // LCA位于左子树或右子树</span><br><span class="line">    return left_lca ? left_lca : right_lca;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现是建立在NA、NB均存在于二叉树。如果NA、NB中某个值不存在于二叉树会将另一个值作为LCA返回（理想情况下应该返回NSNULL）。我们可以通过传递两个布尔变量v1、v2 来扩展这个这类情况，当树中存在n1时，v1置位true，当树中存在n2时，v2置为true。</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><h4 id="h-文件"><a href="#h-文件" class="headerlink" title=".h 文件"></a>.h 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct lca_Node&#123;</span><br><span class="line">    struct lca_Node * left_Child;</span><br><span class="line">    struct lca_Node * right_Child;</span><br><span class="line">    int member;</span><br><span class="line">&#125;LCA_Node, * pLCA_Node;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2);</span><br><span class="line">pLCA_Node newLcaNode(int member);</span><br></pre></td></tr></table></figure><h4 id="m-文件"><a href="#m-文件" class="headerlink" title=".m 文件"></a>.m 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;FindLCA.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;stdbool.h&quot;</span><br><span class="line"></span><br><span class="line">pLCA_Node newLcaNode(int member)&#123;</span><br><span class="line">    pLCA_Node temp = malloc(sizeof(LCA_Node));</span><br><span class="line">    temp -&gt; member = member;</span><br><span class="line">    temp -&gt; left_Child = temp -&gt; right_Child = NULL;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCAUtil(pLCA_Node root , int mem1, int mem2, bool * v1, bool * v2)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root -&gt; member == mem1) &#123;</span><br><span class="line">        *v1 = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root -&gt; member == mem2) &#123;</span><br><span class="line">        *v2 = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pLCA_Node left_lca = findLCAUtil(root -&gt; left_Child, mem1, mem2, v1, v2);</span><br><span class="line">    pLCA_Node right_lca = findLCAUtil(root -&gt; right_Child, mem1, mem2, v1, v2);</span><br><span class="line">    if (left_lca &amp;&amp; right_lca) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return left_lca ? left_lca : right_lca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool findKey(pLCA_Node root, int key)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root -&gt; member == key || findKey(root -&gt; left_Child, key) || findKey(root -&gt; right_Child, key)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2)&#123;</span><br><span class="line">    </span><br><span class="line">    bool v1 = false, v2 = false;</span><br><span class="line">    </span><br><span class="line">    pLCA_Node lca = findLCAUtil(root, mem1, mem2, &amp;v1, &amp;v2);</span><br><span class="line">    </span><br><span class="line">    if ((v1 &amp;&amp; v2) || (v1 &amp;&amp; findKey(root, mem2)) || (v2 &amp;&amp; findKey(root, mem1))) &#123;</span><br><span class="line">        return lca;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void testFindLCA()&#123;</span><br><span class="line">//  构造一个上图所示的树</span><br><span class="line">    pLCA_Node root = newLcaNode(1);</span><br><span class="line">    root -&gt; left_Child = newLcaNode(2);</span><br><span class="line">    root -&gt; right_Child = newLcaNode(3);</span><br><span class="line">    root -&gt; left_Child -&gt; left_Child = newLcaNode(4);</span><br><span class="line">    root -&gt; left_Child -&gt; right_Child = newLcaNode(5);</span><br><span class="line">    root -&gt; right_Child -&gt; left_Child = newLcaNode(6);</span><br><span class="line">    root -&gt; right_Child -&gt; right_Child = newLcaNode(7);</span><br><span class="line">    </span><br><span class="line">    pLCA_Node lca = findLCA(root, 4, 5);</span><br><span class="line">    </span><br><span class="line">    if (lca) &#123;</span><br><span class="line">        printf(&quot;LCA(4,5)---%d\n&quot;,lca -&gt; member);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Keys are not present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lca = findLCA(root, 4, 10);</span><br><span class="line">    </span><br><span class="line">    if (lca) &#123;</span><br><span class="line">        printf(&quot;LCA(4,10)---%d\n&quot;,lca -&gt; member);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Keys are not present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LCA(4,5)---2</span><br><span class="line">Keys are not present</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法设计——Lowest-Commen-Ancestor&quot;&gt;&lt;a href=&quot;#算法设计——Lowest-Commen-Ancestor&quot; class=&quot;headerlink&quot; title=&quot;算法设计——Lowest Commen Ancestor&quot;&gt;&lt;/a&gt;算法设计——Lowest Commen Ancestor&lt;/h2&gt;&lt;h3 id=&quot;举个栗子&quot;&gt;&lt;a href=&quot;#举个栗子&quot; class=&quot;headerlink&quot; title=&quot;举个栗子&quot;&gt;&lt;/a&gt;举个栗子&lt;/h3&gt;&lt;p&gt;给定一个二叉树，找到两个节点NA， NB的最近公共祖先(LCA)。&lt;/p&gt;
&lt;p&gt;方便理解、比如对于下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/10/算法设计-LowestCommenAncestor/lca.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------Game of Nim</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Game-of-Nim/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Game-of-Nim/</id>
    <published>2019-03-10T05:18:07.000Z</published>
    <updated>2019-03-10T05:19:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="游戏描述"><a href="#游戏描述" class="headerlink" title="游戏描述"></a>游戏描述</h3><p>Nim游戏是对一些放置成堆的一定数量的硬币开始的：硬币和堆的数量取决于你。有两名玩家玩这个游戏，当轮到某位玩家时，他能从某一堆里取任意数量的硬币，但是至少要取一枚硬币，但是也不能从除你取的这个堆以外的其他堆里再取硬币。取得最后一枚硬币的人获胜。</p><a id="more"></a><h3 id="游戏预测"><a href="#游戏预测" class="headerlink" title="游戏预测"></a>游戏预测</h3><blockquote><p>Nim-Sum：对每一堆硬币进行XOR(异或)得到的最终值成为Nim-Sum<br>例如：设HeapA，HeapB，HeapC，每个堆分别有8，12，13个元素<br>则Nim-Sum = 8⊕12⊕13 = 9</p></blockquote><p>对于Nim游戏，假设两个玩家足够聪明（都不会犯错），游戏的结果取决于两个因素：</p><ul><li>硬币堆数及每堆初始化数量（Nim-Sum值）</li><li>游戏从谁开始</li></ul><p>如果游戏开始时Nim-Sum非零，首先开始的玩家将获胜，否则首先开始的玩家输掉游戏。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><ul><li>如果Nim-Sum为零，则无论当前玩家做什么，下一个状态的Nim-Sum都是非0的。</li><li>如果Nim-Sum为非零，则当前玩家可以通过计算移除某一堆的硬币数量，使下一状态的Nim-Sum为0</li><li>游戏结束时，Nim-Sum为0</li><li><a href="https://en.wikipedia.org/wiki/Nim#Proof_of_the_winning_formula" target="_blank" rel="noopener">更详细的证明</a></li></ul><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>Nim游戏的结果预测是显而易见的，下面的代码实现了如何完美移动硬币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 计算Nim-Sum</span><br><span class="line">int calculateNimSum(int piles[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, nimsum = piles[0];</span><br><span class="line">    for (i=1; i&lt;n; i++)</span><br><span class="line">        nimsum = nimsum ^ piles[i];</span><br><span class="line">    return(nimsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动硬币</span><br><span class="line">void makeMove(int piles[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, nim_sum = calculateNimSum(piles, n);</span><br><span class="line"> </span><br><span class="line">    // 现在轮到的玩家想要获胜，必须确保移动后的Nim-Sum为0</span><br><span class="line">    if (nim_sum != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 如果该移动合法、移动硬币</span><br><span class="line">            if ((piles[i] ^ nim_sum) &lt; piles[i])</span><br><span class="line">            &#123;</span><br><span class="line">            print(&quot;从第%d堆移除%d个硬币\n&quot;,i,piles[i]-(piles[i]^nim_sum));</span><br><span class="line">                piles[i] = (piles[i] ^ nim_sum);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 在对手不犯错误的情况下，现在轮到的玩家将会失败，这里随机移动硬币即可</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        随机移动硬币</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;游戏描述&quot;&gt;&lt;a href=&quot;#游戏描述&quot; class=&quot;headerlink&quot; title=&quot;游戏描述&quot;&gt;&lt;/a&gt;游戏描述&lt;/h3&gt;&lt;p&gt;Nim游戏是对一些放置成堆的一定数量的硬币开始的：硬币和堆的数量取决于你。有两名玩家玩这个游戏，当轮到某位玩家时，他能从某一堆里取任意数量的硬币，但是至少要取一枚硬币，但是也不能从除你取的这个堆以外的其他堆里再取硬币。取得最后一枚硬币的人获胜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
