<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kai&#39;s Blog</title>
  
  <subtitle>Kai&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-15T09:23:48.185Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AstorKai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS Memory Deep Dive</title>
    <link href="http://yoursite.com/2019/07/15/iOS-Memory-Deep-Dive/"/>
    <id>http://yoursite.com/2019/07/15/iOS-Memory-Deep-Dive/</id>
    <published>2019-07-15T09:22:38.000Z</published>
    <updated>2019-07-15T09:23:48.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-Memory-Deep-Dive"><a href="#iOS-Memory-Deep-Dive" class="headerlink" title="iOS Memory Deep Dive"></a>iOS Memory Deep Dive</h2><h3 id="为什么控制内存占用？"><a href="#为什么控制内存占用？" class="headerlink" title="为什么控制内存占用？"></a>为什么控制内存占用？</h3><p>简单的回答是：为了更好的用户体验。减少app的内存占用，几乎一切都会变得更好，可以获得更快的app启动速度，更快的响应速度，自己的app甚至其他开发者的app可以在后台停留更长的时间等等。</p><h3 id="内存占用的分类"><a href="#内存占用的分类" class="headerlink" title="内存占用的分类"></a>内存占用的分类</h3><p>app的内存占用可以分为三类：clean 部分，dirty 部分，compressed部分。在iOS我们讨论app内存占用时，我们真正关心的水dirty 部分和compressed 部分。</p><p>内存是生而“不”平等的，系统以内存页的方式来管理内存。内存页的大小通常是16KB（在不同的处理器和操作系统下，会有不同），内存页又可以被归类为clean page 和 dirty page。一份数据可以占用多个内存页同样的一个内存页也可以存储多份数据。内存页的大小乘以app所占用内存页的数量就是app的内存占用。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>通过一个栗子来直观的看一下clean page 和 dirty page。</p><p>分配一个含有20000个整数的数组，系统会分配给我六个内存页。最初分配时：这些页面时clean page。当我向数据缓冲区开始写数据时，例如，如果我写入到这个数组的第一个位置，这时。第一个内存页就会变成dirty page。类似的如果我写入到了缓冲区的最后一个位置，那最后一页就会变成dirty page。请注意中间的四个页依然时clean page，因为系统并没有将数据写入。</p><h4 id="内存映射文件（memory-mapped-files）"><a href="#内存映射文件（memory-mapped-files）" class="headerlink" title="内存映射文件（memory-mapped files）"></a>内存映射文件（memory-mapped files）</h4><p>另一个有趣的例子是内存映射文件：即为被加载到内存中的磁盘文件。</p><p>如果这个文件是只读文件，那这些内存页将永远是clean page。内核会合理的控制这些内存页的换入和换出操作。</p><p>举个栗子，对于一张50KB的JPEG文件，映射在内存中会占用四个内存页，而第四个内存页是没有被完全占满的。未被占用的部分还可以用来做其他的事情。这种情况下的内存有一些微妙，而前三个页面依然是clean page。可以由内核来合理的控制换入换出操作。</p><h4 id="clean-page-amp-dirty-page"><a href="#clean-page-amp-dirty-page" class="headerlink" title="clean page &amp; dirty page"></a>clean page &amp; dirty page</h4><p>我们再回过头看一下clean page 和 dirty page。</p><p>clean page：简单来说，存储的是可以被换出的数据。比如上面提到的内存映射文件（Image.jpg、Blob.data、Training.model）。再比如Frameworks，每一个framework都含有DATA CONST section。DATA CONST section的数据是典型的可换出数据，但是如果通过runtime做了类似swizzling的操作，这部分数据将是不可换出数据。</p><p>dirty page：dirty page 存储的是所有被app执行过写操作的数据。在iOS中这些页面是不可被换出的（OSX上可以换出到备用存储空间）。这些数据可以是在生命周期内创建的对象（Views、Array、Cache等），也可以是解码后到图片缓冲区。同时它也可以是Frameworks，Framework的DATA Section 和 DATA Dirty Section都是存放在dirty page内。</p><h4 id="compressed-memory"><a href="#compressed-memory" class="headerlink" title="compressed memory"></a>compressed memory</h4><p>刚刚有提到，不同于OSX，iOS下dirty page是不可被换出的。相反，iOS在iOS7引入了内存压缩器（memory compressor），来为我们的app提供更多的可用内存。</p><p>内存压缩器对最近未访问过的内存进行压缩，这样为app创造出更多可用的内存空间。但是，在app访问被压缩数据时，必须先对这些数据进行解压操作。</p><p>一起看一个栗子：</p><p>一个用于缓存的字典：占用了三个内存页，假设一段时间内该字典没有被访问，且系统需要更多的内存，系统就可以把它压缩到一个内存页中。在再次访问该字典时，会对其进行相应的解压操作。</p><h4 id="Memory-warning-amp-compress-memory"><a href="#Memory-warning-amp-compress-memory" class="headerlink" title="Memory warning &amp; compress memory"></a>Memory warning &amp; compress memory</h4><p>app并不总是引起内存警告的原因：例子，低内存的手机上接到一个电话，可能会触发一个内存警告。压缩器使内存释放变得复杂，由于压缩内容实际上我们使用了比实际内存更多的内存。</p><p>回到上一小节的字典缓存的例子：</p><p>通常，在收到内存警告时，我们会对缓存的内存进行释放。既然我在访问这个字典，那么首先需要将字典进行解压（即由一个内存页占用恢复为三个内存页占用），我门反而占用了更多的内存，在内存受限的环境中我们显然不希望这样的事情发生。而且，很有可能我们做了很多操作释放了大多数的缓存数据，可能我们的工作只是让字典的内存占用变为了一个内存页，我们做了很多的操作只是让字典缓存回到了被压缩前的样子（只占用一个内存页）。所以在收到内存警告时我们一定要小心处理。</p><h5 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h5><p>为了避免CPU重复工作我们引入了缓存，但是过多的缓存会导致内存的耗尽，这个在平时开发过程中需要注意平衡。</p><p>比起字典更建议使用NSCache来进行缓存操作。主要有两点：</p><ul><li>NSCache是线程安全的。</li><li>由于NSCache分配内存的方式，它实际上是可清除的，在内存受限的环境中可以工作得更好。</li></ul><h3 id="内存-amp-Image"><a href="#内存-amp-Image" class="headerlink" title="内存 &amp; Image"></a>内存 &amp; Image</h3><p>我们最后一起来聊一下iOS中内存占用最大的对象—图像！</p><p>关于图像，我们最需要了解的是：图像内存的占用与图像的尺寸有关而不是与它的文件大小有关。</p><h4 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>我有一张590KB的图像想把它做为ipa的壁纸，它的尺寸是2048 px<em> 1536px 。那么它实际会使用多少内存呢？ 10MB！ 2048 </em>1536 * 4byte per pixel。</p><p>为什么图像会占用如此大的内存？iOS中渲染图像需要经过三步：load -&gt; decode -&gt; render。</p><ul><li>load： 590kb的图像被加载到内存中。</li><li>decode： 图片被转换为GPU可读取的格式，此时文件大小增加到了10MB。</li><li>render：GPU将图片渲染到屏幕上。</li></ul><h4 id="图片的存储格式-amp-内存占用"><a href="#图片的存储格式-amp-内存占用" class="headerlink" title="图片的存储格式 &amp; 内存占用"></a>图片的存储格式 &amp; 内存占用</h4><p>不同的图像存储格式对应不同的内存占用</p><table><thead><tr><th>格式</th><th style="text-align:center">大小（每像素）</th></tr></thead><tbody><tr><td>SRGB</td><td style="text-align:center">4 bytes</td></tr><tr><td>wide format</td><td style="text-align:center">4 bytes</td></tr><tr><td>alpha 8</td><td style="text-align:center">1 bytes</td></tr></tbody></table><p>可以看到，alpha 8格式的内存占用是SRGB格式的25%,不同的图像格式可以应用于不同的场景，合理的选择图像格式非常重要这可以帮助我们更合理的使用内存。</p><p>那么我们应该如何合理的选择格式？最好的答案是交给系统来选择！</p><h5 id="使用UIGraphicsIMageRender-代替-UIGraphicsBeginImageCOntextWithOptions"><a href="#使用UIGraphicsIMageRender-代替-UIGraphicsBeginImageCOntextWithOptions" class="headerlink" title="使用UIGraphicsIMageRender 代替 UIGraphicsBeginImageCOntextWithOptions"></a>使用UIGraphicsIMageRender 代替 UIGraphicsBeginImageCOntextWithOptions</h5><p>使用 UIGraphicsBeginImageCOntextWithOptions 生成的图片，每个像素总是4个字节SRGB格式。建议使用UIGraphicsImageRenderer，这个方法是从iOS 10引入，在iOS 12上会自动选择最佳的图像格式。</p><h4 id="对图片的向下采样"><a href="#对图片的向下采样" class="headerlink" title="对图片的向下采样"></a>对图片的向下采样</h4><p>当你缩小一幅图像的时候，会按照取平均值的办法把多个像素点变成一个像素点，这个过程称为下采样（Downsampling）。</p><p>UIImage在设置和调整大小的时候，需要将原始图像加压到内存中，然后对内部坐标空间做一系列转换，整个过程会消耗很多资源。我们可以使用ImageIO，它可以直接读取图像大小和元数据信息，不会带来额外的内存开销。 ImageIO使用Streaming API，这样我们只需为生成的图像使用一些dirty memory。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内存是有限的共享资源，在日常开发中应该更合理谨慎的使用内存。日常开发过程中应该关注Xcode等debug工具等产出的内存报告。同时，在内存使用上一些很小的细节可以产生对内存产生很大的影响，如：图片处理，app进入后台时的内存释放等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS-Memory-Deep-Dive&quot;&gt;&lt;a href=&quot;#iOS-Memory-Deep-Dive&quot; class=&quot;headerlink&quot; title=&quot;iOS Memory Deep Dive&quot;&gt;&lt;/a&gt;iOS Memory Deep Dive&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="WWDC" scheme="http://yoursite.com/tags/WWDC/"/>
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>根治顽疾：Keep客户端 In-App Purchase 掉单踩坑指南</title>
    <link href="http://yoursite.com/2019/03/10/%E6%A0%B9%E6%B2%BB%E9%A1%BD%E7%96%BE%EF%BC%9AKeep%E5%AE%A2%E6%88%B7%E7%AB%AF-In-App-Purchase-%E6%8E%89%E5%8D%95%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/</id>
    <published>2019-03-10T05:49:00.000Z</published>
    <updated>2019-03-10T06:13:09.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>In-App Purchase（以下简称IAP）是苹果为开发者提供的应用内购服务。Keep于17年初接入In-App Purchase，功能上线后暴漏出严重的丢单问题，丢单概率大概在百分之一。丢单问题在多人多次优化后仍未能解决，成为Keep客户端的顽疾。直至最近的两次优化彻底根治了丢单问题。本文中笔者将循着Keep客户端解决IAP掉单问题的两次优化之旅跟大家分享排查问题的思路以及最终的方案。</p><a id="more"></a><h2 id="历史问题"><a href="#历史问题" class="headerlink" title="历史问题"></a>历史问题</h2><p>由于IAP本身设计问题及开发者不恰当使用API导致IAP掉单是一个较为普遍的内购问题。同时，网上存在各种没有数据支撑的所谓的“解决方案”及各种“一站式解决掉单”的标题党，会对开发者产生一定的误导。盲目的引入这些方案在没有解决问题的同时平白增加了代码的复杂度。甚至有一些开发者表示IAP漏单是无法避免的，只能通过客服的介入来进行补单。</p><p>在之前的几次排查过程中，由于网上信息的误导，盲目接入了几种网上流传的解决方案。</p><ul><li>本地化存储 ：在收到IAP支付成功回调后，将业务订单号、receipt信息持久化，在app启动时遍历本地存储列表触发补单逻辑。</li><li>网络异常重试：app校验receipt信息htttp请求失败时，会触发重试逻辑，连续重试10次。</li></ul><p>盲目主要指的是，方案本身没有可靠的数据支撑，RD对于接入方案的效果没有预期，缺乏适当的技术埋点追踪接入后的效果。 </p><p>事实上，这两种方案并不能解决掉单问题，且都存在很大的问题：</p><ul><li>本地化存储：完全是无效的冗余逻辑，平白增加代码复杂度。</li><li>网络异常重试：由于缺乏恰当的实现，并不能对补单提供有力的保障。</li></ul><p>我们将通过与第一次优化方案的对比来详细阐述这两种方案所存在的问题。</p><h2 id="第一次优化"><a href="#第一次优化" class="headerlink" title="第一次优化"></a>第一次优化</h2><p>在翻阅IAP相关文档及明确了Keep客户端中存在的历史问题后，明确了从两个角度进行优化：</p><ul><li>程序健壮性：提升程序健壮性避免由于网络、crash等导致的掉单。</li><li>补单实时性：在异常发生时，保障大部分用户实时快速完成补单。</li></ul><p>同时，增加IAP支付流程各个阶段的埋点。为上线后的问题排查及优化效果统计打下基础。</p><h3 id="程序健壮性"><a href="#程序健壮性" class="headerlink" title="程序健壮性"></a>程序健壮性</h3><p>我们将IAP流程简化为如下： </p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/iap_pay_w.png" alt=""></p><p>从流程上来看，由于客户端导致的掉单有两种可能：</p><ol><li>步骤一：用户支付成功，Apple回调客户端通信失败。</li><li>步骤二：Apple回调客户端后，客户端与server通信失败。</li></ol><p>所以提升程序健壮性要从这两种掉单case入手。</p><h4 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h4><p>事实上，对于以上两种掉单case，Apple已经为我们提供了合理的解决方案。</p><p>IAP中每一次支付行为都被抽象成一个事务（SKPaymentTransaction），只有事务被正常完结（调用finishTransaction:）本次支付行为才算完成。在每一次app启动时，通过调用addTransactionObserver:就会触发之前所有未完结的事务。详见：支付队列观察者 。所以，由于事务机制的存在，我们只需做到以下两点就可以避免掉单：</p><ol><li>对于每一个支付事务，在确保服务端处理完后再结束（finishTransaction:）该事务。</li><li>App启动时，注册支付队列观察者（addTransactionObserver:）并添加相应补单逻辑。</li></ol><p>依赖于Apple提供的事务机制显然比本地化存储方案更加可靠，主要体现在以下几点：</p><ol><li>本地化存储只能解决“客户端与server通信失败”的掉单场景。</li><li>本地化存储的数据会随着用户设备更换、app删除重装而丢失而Apple的事务机制不会。</li></ol><p>可以看到，本地化存储解决的掉单场景是Apple所提供支付队列观察者能解决场景的子集。</p><p>所以第一个优化点在于：依靠Apple的事务机制，同时删除冗余的本地化存储方案。 </p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>我们追踪了最近一个月内所有用户支付成功的订单中，通过Apple提供的事务机制恢复的订单。得到如下结论：通过事务机制恢复的订单占总支付成功订单的4.78‰。即，通过第一次优化我们将掉单率降低了4.78‰。</p><h3 id="补单实时性"><a href="#补单实时性" class="headerlink" title="补单实时性"></a>补单实时性</h3><p>事务机制有一个明显的弊端：补单逻辑只有在app重启时才能触发。 重启app对于用户来说是一个很重的操作。我们希望添加某种机制更实时的为用户进行补单，于是我们引入了“网络异常重试逻辑”以提升补单效率，做为事务机制的一个补充。</p><h4 id="网络异常重试"><a href="#网络异常重试" class="headerlink" title="网络异常重试"></a>网络异常重试</h4><p>网络异常重试，主要是为了避免在付款成功后，用户网络状况发生变化（如，乘坐地铁进入隧道）导致与server通信失败的及时重试逻辑。</p><p>网络异常重试，主要是为了避免在付款成功后，用户网络状况发生变化（如，乘坐地铁进入隧道）导致与server通信失败的及时重试逻辑。</p><p>该方案本身没有太大问题，在较低的接入成本与影响面下可以很大程度的提升补单的实时性，是app启动时事务机制补单逻辑的一个很好的补充。不过，需要恰当的实现才能达到最优的效果。</p><p>之前Keep的实现方案是：初始化一个计数器，在网络请求失败的回调内累加计数器并触发重试逻辑，直至重试10次后放弃重试。</p><p>在实际测试过程中在断网的状况下，发出去的网络请求会立刻拿到失败回调，10次重试请求会在1s内发完。所以该方案能达到的效果被大打折扣。</p><p>解决方案当然是拉长重试间隔，另外，由于用户网络恢复的可能是随着时间逐渐递减的，为了避免频繁的重试我们不妨依次延长每一次重试的间隔。Keep目前的方案是以斐波那契数列来做为每一次重试的间隔，即10次重试的间隔分别是：</p><ul><li>1，1，2，3，5，8，13，21，34，55 </li></ul><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>下表是包含首次校验receipt失败（checkOrder_Failed）在内的，触发网络异常重试逻辑的埋点：</p><p>PS：以下数据没有考虑在重试过程中app异常关闭或用户手动关闭app</p><table><thead><tr><th>事件</th><th>次数</th></tr></thead><tbody><tr><td>checkOrder_Failed</td><td>332</td></tr><tr><td>checkOrder_Failed_Retry_1</td><td>166</td></tr><tr><td>checkOrder_Failed_Retry_2</td><td>127</td></tr><tr><td>checkOrder_Failed_Retry_3</td><td>122</td></tr><tr><td>checkOrder_Failed_Retry_4</td><td>103</td></tr><tr><td>checkOrder_Failed_Retry_5</td><td>85</td></tr><tr><td>checkOrder_Failed_Retry_6</td><td>69</td></tr><tr><td>checkOrder_Failed_Retry_7</td><td>52</td></tr><tr><td>checkOrder_Failed_Retry_8</td><td>34</td></tr><tr><td>checkOrder_Failed_Retry_9</td><td>23</td></tr><tr><td>checkOrder_Failed_Retry_10</td><td>15</td></tr></tbody></table><p>在所有首次校验（checkOrder_Failed）失败的332笔订单下，经过10次重试（checkOrder_Failed_Retry_10）后只有15笔订单需要用户重启app来触发补单逻辑。 这样在大概两分半的时间内，通过10次重试，我们追回了95.5%的失败用户为补单的实时性提供了有力的保障。</p><h3 id="本地化存储-amp-补单实时性？"><a href="#本地化存储-amp-补单实时性？" class="headerlink" title="本地化存储 &amp; 补单实时性？"></a>本地化存储 &amp; 补单实时性？</h3><p>通过本地化存储我们可以在更多的时机来触发补单逻辑以提升补单实时性。如：网络切换、app前后台切换。这里需要权衡的点是：</p><ul><li>本地化存储、网络切换，app前后台切换逻辑会影响到百分之百的用户（包括非付费用户），同时会有一定的开发维护成本。</li><li>在加入恰当的网络异常重试逻辑后，网络切换、app前后台切换的补单逻辑能帮助到的用户只有IAP付费用户的万分之几。</li></ul><p>当我们把影响范围的基数放在所有日活用户上后，这种方案的收益比可能只有几十/几百万分之一。所以，Keep目前并没有接入这种方案，补单逻辑只是依赖Apple在app启动时的事务机制。 </p><h2 id="第二次优化"><a href="#第二次优化" class="headerlink" title="第二次优化"></a>第二次优化</h2><p>第一次优化上线不久：客服再次反馈IAP支付掉单问题。而且由于业务膨胀式的发展，虽然优化掉了约千分之五的掉单case每天掉单的数量反而在上升。 </p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>收拾了一下心情，继续整理了接下来的工作思路：</p><ol><li>通过埋点及用户的反馈信息分析用户掉单原因。</li><li>收集信息撰写TSI联系Apple寻求技术支持。</li><li>与同行进行沟通，如何解决掉单问题。</li></ol><p>得到了如下的信息反馈：</p><ol><li>对于反馈用户的订单号，通过埋点查看走到了支付失败的回调中。</li><li>TSI得到的反馈是：在收到用户支付成功请求后一定会对客户端下发支付成功的回调，且在我们没有调用（finishTransaction:）结束该事务的情况下，会持续在每一次app启动时调用支付成功回调。</li><li>在与国内两个直播平台的员工进行沟通后：得到的反馈是，的确有丢单的状况。多次排查无果后，主要措施是由人工客服介入补单来处理。</li></ol><p>不难看出，对于1、2两条信息是矛盾的。不过，在后续的排查过程中还是选择了相信用户的诚信以及Apple的技术能力。站在另一个角度去审视自己的代码。 </p><h3 id="抽丝剥茧"><a href="#抽丝剥茧" class="headerlink" title="抽丝剥茧"></a>抽丝剥茧</h3><p>在选择相信用户和苹果的基础上，以Apple的事务机制来套有两点是可以肯定的：</p><ol><li>在用户支付成功后，Apple回调了支付成功的逻辑。</li><li>在处理该笔订单的过程中，客户端一定调用了（finishTransaction:）结束该事务。</li></ol><p>所以客户端的排查点就在于：在除了服务端处理完后，还有哪些地方调用了finishTransaction:？</p><p>终于，在转换思路后一个隐藏的bug浮出水面————在收到Apple支付成功回调后，客户端会首先校验业务OrderNo的合法性，如果orderNo为空，会直接调用（finishTransaction:）结束该事务，从而导致掉单！</p><h4 id="业务OrderNo"><a href="#业务OrderNo" class="headerlink" title="业务OrderNo"></a>业务OrderNo</h4><p>Keep的业务实现逻辑是，在用户发起购买时会生成对应的OrderNo，OrderNo将在整个购买流程中进行透传，直至用户支付成功后的receipt校验。且整个支付流程中在与Apple交互的过程中，通过Apple“提供”（注意这里的引号）的SKPayment的applicationUsername来传递。</p><p>Iap支付的订单流转逻辑：</p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/client_orderNo.png" alt=""></p><p>所以问题的症结在于，我们使用applicationUsername透传OrderNo合理么？</p><p>那么Apple对于applicationUsername定义是什么？</p><blockquote><p>Use this property to help the store detect irregular activity. For example, in a game, it would be unusual for dozens of different iTunes Store accounts to make purchases on behalf of the same in-game character.</p></blockquote><blockquote><p>The recommended implementation is to use a one-way hash of the user’s account name to calculate the value for this property.</p></blockquote><p>Apple提供applicationUsername，是为了防止用户作弊而不是用于透传业务信息的。所以，归根结底产生bug的原因还是我们开发者滥用API（目前网上依然有很多IAP相关的讨论、博客都是使用applicationUsername来透传业务信息）。</p><h3 id="复现及分析"><a href="#复现及分析" class="headerlink" title="复现及分析"></a>复现及分析</h3><p>在上述猜想的基础上，在线上环境下测试了一些边界情况成功复现了掉单case（必须为线上正式包，沙盒环境无法复现，testflight无法复现）。</p><h4 id="复现步骤："><a href="#复现步骤：" class="headerlink" title="复现步骤："></a>复现步骤：</h4><ol><li>itunes store 登入的appleId未绑定支付方式</li><li>发起支付</li><li>绑定支付方式并杀死keep app</li><li>在appStore完成完成支付</li><li>重启app</li></ol><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>在这种case下，在应用内我们收到的回调状态是这样的：</p><ol><li>Purchasing （Keep app 发起，携带OrderNo）</li><li>Failed（Keep app 发起，携带OrderNo）</li><li>用户绑定支付方式</li><li>Purchasing（AppStore 发起，不携带OrderNo）</li><li>Purchased（AppStore 发起，不携带OrderNo）</li></ol><p>用户分别在Keep、AppStore各发起了一次支付。</p><ul><li>Keep内发起的支付：创建了OrderNo，也完成了对于applicationUsername的赋值，但是由于用户没有绑定支付方式该笔订单以失败结束，所以我们会收到相应失败的回调。</li><li>AppStore内发起的支付：用户支付成功了，但是并没有创建OrderNo，也没有完成对于applicationUsername的赋值，所以在Apple回调支付成功后，没有解析到OrderNo。调用（finishTransaction:）结束该事务后产生掉单。</li></ul><h3 id="订单创建后置"><a href="#订单创建后置" class="headerlink" title="订单创建后置"></a>订单创建后置</h3><p>Keep目前采用的解决方案是，对于未生成OrderNo的订单，采用订单创建后置来处理：</p><h4 id="KeepClient"><a href="#KeepClient" class="headerlink" title="KeepClient"></a>KeepClient</h4><ul><li>客户端去掉OrderNo校验逻辑</li></ul><h4 id="KeepServer"><a href="#KeepServer" class="headerlink" title="KeepServer"></a>KeepServer</h4><ul><li>校验接口的OrderNo改为非必传参数</li><li>支付网关层校验成功后, 发送mq消息给业务方</li><li>业务方收到消息后进行模拟提单</li><li>交易中心完结订单</li><li>交易中心回调业务方接口</li><li>业务方发放权益</li></ul><p>KeepServer订单流转如下图(TradeCenter=交易中心 PayGateway=支付网关):</p><p><img src="/2019/03/10/根治顽疾：Keep客户端-In-App-Purchase-掉单踩坑指南/server_order.png" alt=""></p><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p>同样我们以记一个月所有用户支付成功的订单为样本。通过订单创建后置恢复的订单占总支付成功订单的5.25‰。即，通过此次优化IAP掉单率降低了5.25‰，完美解决了客户端的掉单问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;In-App Purchase（以下简称IAP）是苹果为开发者提供的应用内购服务。Keep于17年初接入In-App Purchase，功能上线后暴漏出严重的丢单问题，丢单概率大概在百分之一。丢单问题在多人多次优化后仍未能解决，成为Keep客户端的顽疾。直至最近的两次优化彻底根治了丢单问题。本文中笔者将循着Keep客户端解决IAP掉单问题的两次优化之旅跟大家分享排查问题的思路以及最终的方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="业务实践 IAP" scheme="http://yoursite.com/tags/%E4%B8%9A%E5%8A%A1%E5%AE%9E%E8%B7%B5-IAP/"/>
    
  </entry>
  
  <entry>
    <title>Work with compiler------premain启动优化</title>
    <link href="http://yoursite.com/2019/03/10/Work-with-compiler-premain%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/10/Work-with-compiler-premain启动优化/</id>
    <published>2019-03-10T05:44:45.000Z</published>
    <updated>2019-03-10T05:45:44.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>在Xcode中构建的程序，经由预处理、编译、汇编、链接将源文件（.m和.h文件）转变为Mach-O 二进制可执行文件。Mach-O 中代码被划分为不同的Segment，而每个Segment又包含多个Section。</p><p>Mach-O的架构：</p><p><img src="/Users/wangkai01/Desktop/Pages/Work with compiler------premain启动优化/mach-o.png" alt=""></p><a id="more"></a><h4 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h4><p>执行一个可执行文件时。虚拟内存系统会将Segment映射到进程的地址空间。在虚拟内存系统进行映射时，不同的Segment会以不同的参数（权限）被映射。常见的Segment有：</p><ul><li>__TEXT ：__TEXT段包含了可执行的代码。它们被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。</li><li>__DATA：程序数据段以可读写但不可执行的方式映射。（本文讨论的重点）。</li><li>__PAGEZERO:　空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对 NULL 指针的引用。</li><li>__LINKEDIT:　链接器使用的符号以及其他表。</li></ul><h4 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h4><p>Section 是具体有用的数据存放的地方，下表列出了<strong>DATA 和 </strong>TEXT下的Section：</p><p><img src="/Users/wangkai01/Desktop/Pages/Work with compiler------premain启动优化/section_text.png" alt=""></p><p><img src="/Users/wangkai01/Desktop/Pages/Work with compiler------premain启动优化/section_data.png" alt=""></p><h3 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a>__attribute__</h3><p>__attribute__是一种编译器指令，可以让编译器做更多地错误检查和代码优化，其中就包括大家常见的废弃掉方法、类或者变量的指令__attribute__ ((deprecated(“”)))。</p><p>__attribute__的一般语法形式是__attribute__关键字后面跟两个小括号，在小括号里是逗号分隔的选项。这里我们重点关注<a href="https://clang.llvm.org/docs/AttributeReference.html#section-gnu-section-declspec-allocate" target="_blank" rel="noopener">section() 函数</a>。</p><h4 id="section-函数"><a href="#section-函数" class="headerlink" title="section() 函数"></a>section() 函数</h4><p>前面提到__DATA段为可读写程序数据段，而section() 函数提供了二进制段的读写能力，它可以将一些编译期就可以确定的常量写入数据段。在阅读runtime源码的过程中，可以发现苹果大量利用__attribute__和section()函数在编译器将数据写入__DATA段。</p><p>比如，下述代码编译器在__DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组，用于运行期category的加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样，我们也可以利用__attribute__和section()将数据提前写入__DATA段，以达到程序优化的目的（比如，去+load）。+load()提供了一个非常靠前的执行时机，在实际开发中很多基础库的初始化工作都集中在这个时机执行。而过重的+load()会拖慢程序的premain的加载时间，有了上述的理论基础我们可以在将相关初始化工作封装在函数内并在编译期将相关函数指针写入__DATA段，从而达到延迟加载的效果，节省启动时间。</p><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>受够了理论基础，是时候敲一段代码了~ ，以下代码我们在__DATA段新增section __bwkcfunction__，并将func()的函数指针写入__bwkcfunction__中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (* BWKCFunction) (void);</span><br><span class="line"></span><br><span class="line">void func (void)&#123;</span><br><span class="line">    printf(&quot;hello world in c fun&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void  main ()&#123;</span><br><span class="line">    __attribute__((used,section(&quot;__DATA&quot;&quot;,&quot;&quot;__bwkcfunction__&quot;))) static const BWKCFunction cfunc = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，我们通过命令行编译该代码生成可执行文件a.out（a.out 是clang的默认命名）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang test_attribute.c</span><br></pre></td></tr></table></figure><p>最后通过命令行看一下我们的成果吧~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ xcrun size -x -l -m a.out </span><br><span class="line"></span><br><span class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</span><br><span class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</span><br><span class="line">    Section __text: 0x26 (addr 0x100000f50 offset 3920)</span><br><span class="line">    Section __stubs: 0x6 (addr 0x100000f76 offset 3958)</span><br><span class="line">    Section __stub_helper: 0x1a (addr 0x100000f7c offset 3964)</span><br><span class="line">    Section __cstring: 0x16 (addr 0x100000f96 offset 3990)</span><br><span class="line">    Section __unwind_info: 0x48 (addr 0x100000fac offset 4012)</span><br><span class="line">total 0xa4</span><br><span class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</span><br><span class="line">    Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</span><br><span class="line">    Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</span><br><span class="line">    Section __bwkcfunction__: 0x8 (addr 0x100001018 offset 4120)</span><br><span class="line">total 0x20</span><br><span class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</span><br><span class="line">total 0x100003000</span><br></pre></td></tr></table></figure><p>可以看到，在<em>DATA段，我们成功插入了\</em>_bwkcfunction__ section，且该section的大小为8字节（一个c语言指针的大小）。然后我们就可以在程序运行的过程中在需要的时候取出对应的函数指针，从而实现懒加载~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mach-O&quot;&gt;&lt;a href=&quot;#Mach-O&quot; class=&quot;headerlink&quot; title=&quot;Mach-O&quot;&gt;&lt;/a&gt;Mach-O&lt;/h3&gt;&lt;p&gt;在Xcode中构建的程序，经由预处理、编译、汇编、链接将源文件（.m和.h文件）转变为Mach-O 二进制可执行文件。Mach-O 中代码被划分为不同的Segment，而每个Segment又包含多个Section。&lt;/p&gt;
&lt;p&gt;Mach-O的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/Users/wangkai01/Desktop/Pages/Work with compiler------premain启动优化/mach-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa简介</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/</id>
    <published>2019-03-10T05:42:27.000Z</published>
    <updated>2019-03-10T05:44:22.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a>是一个将函数响应式编程范例带入Objective-C的开源库。由<a href="https://github.com/joshaber" target="_blank" rel="noopener">Josh Abernathy</a>和<a href="https://github.com/jspahrsummers" target="_blank" rel="noopener">Justin Spahr-Summers</a>在对<a href="https://mac.github.com/" target="_blank" rel="noopener">GitHub for Mac</a>的开发过程中产生的副产物。RAC富含cocoa框架多种组件，提供基于时间变化的数据流的组合和变换。</p><a id="more"></a><h3 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h3><p>函数响应式编程是思考软件将输入转化为输出在时间上的持续过程的一种方式。它糅合了函数式编程和响应式编程的特点，满足函数式编程的一些特性，将时间轴上的离散事件通过响应式编程的数据流向下传播的一种编程范式。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/frp.png" alt=""></p><p>先来看一下什么是函数式编程/响应式编程。</p><h3 id="函数式编程（FP）"><a href="#函数式编程（FP）" class="headerlink" title="函数式编程（FP）"></a>函数式编程（FP）</h3><p>函数式编程是一种编程范式，它将电脑运算视为数学上的函数计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。</p><p>在之前的一篇文章里对FP做了更详尽的剖析，这里就不多做解读。（强烈建议阅读继续阅读之前阅读该篇文章）。</p><h3 id="响应式编程-RP"><a href="#响应式编程-RP" class="headerlink" title="响应式编程 (RP)"></a>响应式编程 (RP)</h3><p>响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态数据流，而相关计算模型会自动将变化的值通过数据流进行传播。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><blockquote><p>命令式编程环境中<br>a ＝ b ＋ c<br>赋值之后b或c的值变化后，a的值不会跟着变化<br>而在响应式编程中，a的值会随着b或c的更新而更新。</p></blockquote><p>Excel就是响应式编程的另一个例子。对数据进行求和或求均值操作，包含公式结果的单元格的值会根据其他单元格的值的变化而变化。</p><p>iOS开发中的Autolayout也是响应式编程的一个例子。当父View的位置发生变化，根据相互之间的关系Constraint，子View的frame也会随之变化。</p><h3 id="为什么使用FRP"><a href="#为什么使用FRP" class="headerlink" title="为什么使用FRP"></a>为什么使用FRP</h3><p>函数式响应编程提高了代码抽象层次，所以我们可以只关注定义了业务逻辑的那些相互依赖的事件，而非纠结于大量的实现细节。FRP的代码往往会更加简明。</p><p>特别是在开发现在这些有着大量与数据事件相关的 UI events 的高互动性 Webapps、手机 apps 的时候，FRP 的优势就更加明显。10年前，网页的交互就只是提交一个很长的表单到后端，而在前端只产生简单的渲染。Apps 就表现得更加的实时了：修改一个表单域就能自动地把修改后的值保存到后端，为一些内容”点赞”时，会实时的反应到其它在线用户那里等等。</p><p>现在的 Apps 有着大量各种各样的实时 Events，以给用户提供一个交互性较高的体验。我们需要工具去应对这个变化，而函数响应式编程就是一个答案。</p><h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>示例引用于：<a href="https://zhuanlan.zhihu.com/p/27678951" target="_blank" rel="noopener">响应式编程介绍</a></p><p>假设我们想要得到一个包含”双击”事件的Stream。为了使它更有趣，假设我们想要这个Stream要同时考虑三击，或更加宽泛，连击。想象一下在传统的命令式编程中应该怎样实现。我敢打赌代码会像一团乱麻，并且会使用一些变量保存状态，同时也有一些计算时间间隔的代码。</p><p>而在响应式编程中，这个功能的实现就非常简单。事实上，这逻辑只有四行代码。但现在我们不管这些代码。用图表的方式思考是理解怎样构建Stream的最好方法。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/Click_Stream.png" alt=""></p><p>灰色的方框是用来转换 Stream 函数的。</p><ul><li>首先，简而言之，我们把连续 250 ms 内的 Click 都积累到一个列表中（就是 buffer(stream.throttle(250ms) 做的事),结果是一个列表的 Stream。</li><li>然后我们使用 map() 把每个列表映射为一个整数，即它的长度。</li><li>最终，我们使用 filter(x &gt;= 2) 把整数 1 给过滤掉。就这样，3 个操作就生成了我们想要的 Stream。</li><li>然后我们就可以订阅(“监听”)这个 Stream，并以我们所希望的方式作出反应。</li></ul><p>我希望你能感受到这个示例的优美之处。这个示例只是冰山一角：你可以把同样的操作应用到不同种类的 Stream 上，例如，一个 API 响应的 Stream；另一方面，还有很多其它可用的函数。</p><h3 id="基于时间变化的数据流"><a href="#基于时间变化的数据流" class="headerlink" title="基于时间变化的数据流"></a>基于时间变化的数据流</h3><p>前面提到，RAC提供基于时间变化的数据流的组合和变化，那么什么是基于时间变化的数据流？</p><h4 id="连续数据流-amp-离散数据流"><a href="#连续数据流-amp-离散数据流" class="headerlink" title="连续数据流 &amp; 离散数据流"></a>连续数据流 &amp; 离散数据流</h4><p>数组就是一个最简单的数据流，数组内的值是连续的。而基于时间变化的数据流在一个事件范围内以离散形式存在。如鼠标的点击事件，我们将点击鼠标的事件采集起来就能够得到一个基于时间变化的数据流。如图：</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_1.png" alt=""></p><h4 id="多维数组-amp-多维数据流"><a href="#多维数组-amp-多维数据流" class="headerlink" title="多维数组 &amp; 多维数据流"></a>多维数组 &amp; 多维数据流</h4><p>C语言中数组内的元素可以是数组形成多维数组。相似的数据流内元素也可以是一个数据流形成多维数据流，如图：</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_2.png" alt=""></p><h3 id="数据流的操作"><a href="#数据流的操作" class="headerlink" title="数据流的操作"></a>数据流的操作</h3><p>RAC提供了对数据流的组合和变换，我们可以对数据流进行一定的操作得到新的流如：</p><ul><li>对值操作得到新的流</li><li>对值的数量进行操作得到新的流</li><li>对维度操作得到新的流</li><li>对时间间隔进行操作得到新的流</li></ul><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_operation.png" alt=""></p><p>除此之外我们还可以对多个流进行合并、变换等操作</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa简介/stream_merge.png" alt=""></p><h3 id="RAC的核心组件"><a href="#RAC的核心组件" class="headerlink" title="RAC的核心组件"></a>RAC的核心组件</h3><p>这里对RAC的核心组件做简要介绍，在后续的学习过程中会做更深入整理</p><h4 id="RACSteam"><a href="#RACSteam" class="headerlink" title="RACSteam"></a>RACSteam</h4><p>RACSteam是RAC对数据流的抽象，提供了一些抽象的接口，其功能主要体现在其两个子类RACSignal（离散数据流）和RACSequence（连续数据流）。</p><p>我们从两个角度分析一个RACSignal 和 RACSequence</p><h5 id="Data-vs-Event"><a href="#Data-vs-Event" class="headerlink" title="Data vs Event"></a>Data vs Event</h5><p>RACSequence：处理的是数据，表示一个序列，里面存放的是一系列的数据，类似数组。<br>RACSignal：处理的是事件，值事件、错误事件、终止事件。</p><h5 id="pullDriver-vs-pushDriver"><a href="#pullDriver-vs-pushDriver" class="headerlink" title="pullDriver vs pushDriver"></a>pullDriver vs pushDriver</h5><p>RACSignal的数据驱动类型是pushDriver;那么什么是pushDriver？</p><ul><li>从值的创建角度：pushDriver意味着信号的值在创建时没有被定义，并可能在稍后的时间里产生信号的值。例如：网络请求或任何用户输入。</li><li>从值的传递角度：每当产生新的信号都会，信号源就会给订阅者发送数据。对于数据调取者是被动接受的。  </li></ul><p>RACSequence的数据驱动类型是pullDriver;那么什么是pullDriver？</p><ul><li>从值的创建角度：pullDriver意味着信号的值在创建的时候就被定义。例如：数组里的值。</li><li>从值的传递角度：任何时间想要拿到数据调取者都可以从数据流里拉取数据。整个时间控制掌握在调取者手中。  </li></ul><p>pushDriver可以理解为看电视，pullDriver可以理解为看书。</p><h4 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h4><p>RACSubscriber对象是RACSignal的订阅者，负责处理RACSignal传出的数据。RACSubscriber对象初始化的时候回传入的nextBlock、 errorBlock、completeBlock分别处理RACSignal的值事件、错误事件、终止事件。</p><h4 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h4><p>RACSubscriber在对事件进行订阅时会返回RACDisposable对象，可以通过RACDisposable来终止对信号的订阅。</p><h4 id="RACScheduler"><a href="#RACScheduler" class="headerlink" title="RACScheduler"></a>RACScheduler</h4><p>RACScheduler底层是RAC对GCD的封装，是RAC中负责任务调度的调度器。 RACScheduler通过对GCD封装让并发编程与RAC高度整合。使RAC的使用者更畅快的沉浸在FRP的世界里。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://zhuanlan.zhihu.com/p/27678951" target="_blank" rel="noopener">响应式编程介绍</a><br><a href="https://www.zhihu.com/question/26079335/answer/32084850" target="_blank" rel="noopener">函数式响应型编程(Functional Reactive Programming)会在什么问题上有优势?</a><br> <a href="https://stackoverflow.com/questions/28952900/what-is-the-difference-between-racsequence-and-racsignal" target="_blank" rel="noopener">What is the difference between RACSequence and RACSignal</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ReactiveCocoa&lt;/a&gt;是一个将函数响应式编程范例带入Objective-C的开源库。由&lt;a href=&quot;https://github.com/joshaber&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Josh Abernathy&lt;/a&gt;和&lt;a href=&quot;https://github.com/jspahrsummers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Justin Spahr-Summers&lt;/a&gt;在对&lt;a href=&quot;https://mac.github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub for Mac&lt;/a&gt;的开发过程中产生的副产物。RAC富含cocoa框架多种组件，提供基于时间变化的数据流的组合和变换。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa高阶操作</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E9%AB%98%E9%98%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/</id>
    <published>2019-03-10T05:40:33.000Z</published>
    <updated>2019-03-10T05:42:01.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>延续上一篇ReactiveCocoa操作详解,本篇笔者围绕针对RAC信号的维度变换（升阶、降阶）进行深入探究，同时在文章结尾给出Functor、Applicatives和Monad的概念。</p><a id="more"></a><h3 id="升阶-amp-降阶"><a href="#升阶-amp-降阶" class="headerlink" title="升阶 &amp; 降阶"></a>升阶 &amp; 降阶</h3><p>在ReactiveCocoa简介中，笔者提到类似C语言中的多维数组,RAC中同样存在多维信号的概念。多维信号发送的每一个值都是一个信号，为方便后续交流笔者将其称为“值信号”。本篇中以大写英文字母“A、B、C”表示值信号，以阿拉伯数字“1、2、3”表示普通值。</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/up-down.png" alt=""></p><h3 id="高阶信号"><a href="#高阶信号" class="headerlink" title="高阶信号"></a>高阶信号</h3><h4 id="高阶信号的创建"><a href="#高阶信号的创建" class="headerlink" title="高阶信号的创建"></a>高阶信号的创建</h4><p>通过return创建一个返回信号的信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal return:@1];</span><br><span class="line">RACSignal *signalHighOrder = [RACSignal return:signal];</span><br></pre></td></tr></table></figure><p>通过map变换返回一个信号，达到对信号升阶的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *anotherSignal = [signal map:^id(id value) &#123;</span><br><span class="line">return [RACSignal return:value];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="高阶信号的订阅"><a href="#高阶信号的订阅" class="headerlink" title="高阶信号的订阅"></a>高阶信号的订阅</h4><p>通过嵌套订阅拿到真正的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[highOrderSignal subscribeNext:^(RACSignal *aSignal) &#123;</span><br><span class="line">[aSignal subscribeNext:^(id x) &#123;</span><br><span class="line">// get real value here.</span><br><span class="line">&#125;];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><h3 id="降阶操作"><a href="#降阶操作" class="headerlink" title="降阶操作"></a>降阶操作</h3><p>通过map升阶将值转换为值信号，在实际应用中最终还是需要获得值。RAC为我们提供了多种降阶操作以满足不同的场景。</p><h4 id="SwitchToLatest"><a href="#SwitchToLatest" class="headerlink" title="SwitchToLatest"></a>SwitchToLatest</h4><p>switchToLatest操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。switchToLatest将原信号输出的最新的值信号的next事件和error事件作为新信号的next时间和error事件输出。</p><ul><li>Next事件：输出原信号输出的最新值信号的next事件。</li><li>Error事件：输出原信号输出的最新值信号的error事件、同时会在原信号输出error事件。</li><li>Completed事件：取原信号的completed事件和原信号的最后一个值信号的completed事件的在时间维度上较晚发出者。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/switchTolatest.png" alt=""></p><h5 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h5><p>为突出信号A、B、C在时间维度发送事件的先后顺序，这里使用RACSignal的子类代替RACSubject。RACSubject与RACSignal稍有不同，在后续冷热信号中会详细探讨。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject * signalA = [RACSubject subject];</span><br><span class="line">RACSubject * signalB = [RACSubject subject];</span><br><span class="line">RACSubject * signalC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals switchToLatest] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 3 5 7 8</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@1];</span><br><span class="line">[signalOfSignals sendNext:signalB];</span><br><span class="line"></span><br><span class="line">[signalA sendNext:@2];</span><br><span class="line">[signalB sendNext:@3];</span><br><span class="line">[signalA sendNext:@4];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalC];</span><br><span class="line">[signalA sendCompleted];</span><br><span class="line">[signalC sendNext:@5];</span><br><span class="line">[signalB sendNext:@6];</span><br><span class="line">[signalB sendCompleted];</span><br><span class="line">[signalOfSignals sendCompleted];</span><br><span class="line">[signalC sendNext:@7];</span><br><span class="line">[signalC sendNext:@8];</span><br><span class="line">[signalC sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="If-then-else"><a href="#If-then-else" class="headerlink" title="If:then:else"></a>If:then:else</h4><p>If:then:else操作基于boolSignal发送的最新值，在tureSignal、falseSignal之间切换。<br>要求boolSignal的值必须为NSNumber类型，且boolSignal、tureSignal、falseSignal均不为nil。<br>If:then:else操作其实是一个语法糖，底层使用switchToLatest实现。</p><ul><li>Next事件：boolSignal发送ture，输出tureSignal信号的next事件；boolSignal发送false，输出falseSignal信号的next事件。</li><li>Error事件：boolSignal发送ture，输出tureSignal信号的error事件；boolSignal发送false，输出falseSignal信号的error事件。</li><li>Completed事件：当boolSignal与当前选中信号都发送completed事件后，发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/if-then-else.png" alt=""></p><h5 id="Coding-1"><a href="#Coding-1" class="headerlink" title="Coding"></a>Coding</h5><p>为突出时间概念同样使用RACSubject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * boolSignal = [RACSubject subject];</span><br><span class="line">RACSubject * signalTure = [RACSubject subject];</span><br><span class="line">RACSubject * signalFalse = [RACSubject subject];</span><br><span class="line">RACSignal * resultSignal = [RACSignal if:boolSignal then:signalTure else:signalFalse];</span><br><span class="line"></span><br><span class="line">[resultSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 2 c d 5 6 g h</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@YES];</span><br><span class="line">[signalTure sendNext:@1];</span><br><span class="line">[signalTure sendNext:@2];</span><br><span class="line">[signalFalse sendNext:@&quot;a&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;b&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@NO];</span><br><span class="line">[signalTure sendNext:@3];</span><br><span class="line">[signalTure sendNext:@4];</span><br><span class="line">[signalFalse sendNext:@&quot;c&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;d&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@YES];</span><br><span class="line">[signalTure sendNext:@5];</span><br><span class="line">[signalTure sendNext:@6];</span><br><span class="line">[signalFalse sendNext:@&quot;e&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;f&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendNext:@NO];</span><br><span class="line">[signalTure sendNext:@7];</span><br><span class="line">[signalTure sendNext:@8];</span><br><span class="line">[signalFalse sendNext:@&quot;g&quot;];</span><br><span class="line">[signalFalse sendNext:@&quot;h&quot;];</span><br><span class="line"></span><br><span class="line">[boolSignal sendCompleted];</span><br><span class="line">[signalFalse sendCompleted];</span><br><span class="line">[signalTure sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h4><p>concat操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。<br>链接原信号发送的所有值信号,注意与ReactiveCocoa操作详解concat:相区分 。</p><ul><li>Next事件：依次发送值信号的next事件，在当前订阅值信号发送completed事件后，开始发送下一个值信号的next事件。</li><li>Error事件：输出值信号的error事件，同时会在原信号输出error事件。</li><li>Completed事件：原信号和当前订阅值信号均发送completed事件后，输出completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/concat1.png" alt=""></p><h5 id="Coding-2"><a href="#Coding-2" class="headerlink" title="Coding"></a>Coding</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signalOfSignals = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    RACSignal * signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">        [subscriber sendNext:@4];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal * signalB = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@&quot;a&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;b&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;c&quot;];</span><br><span class="line">        [subscriber sendNext:@&quot;d&quot;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] deliverOn:[RACScheduler scheduler]] ;</span><br><span class="line">    </span><br><span class="line">    [subscriber sendNext:signalA];</span><br><span class="line">    [subscriber sendNext:signalB];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals concat] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 2 3 4 a b c d </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h5><p>利用concat实现1秒延时信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = @[@1, @3, @7, @9, @8].rac_sequence.signal;</span><br><span class="line">RACSignal *timerSignal = [[signal map:^id(id value) &#123;</span><br><span class="line"> return [[RACSignal return:value] delay:1];</span><br><span class="line">  &#125;] concat];</span><br></pre></td></tr></table></figure><h4 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h4><p>flatten操作要求原信号必须是一个高阶信号（信号的信号），即信号的值必须是一个信号。<br>对原信号进行降阶操作，对原信号输出的值信号输出的所有next事件、error事件作为新信号的事件按时间顺序依次输出。</p><ul><li>Next事件：按时间顺序依次输出原信号的值信号的next事件。</li><li>Error事件：输出原信号的值信号的error事件。</li><li>Completed事件：在所有信号均输出completed事件后输出completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa高阶操作/Flatten.png" alt=""></p><h5 id="Coding-3"><a href="#Coding-3" class="headerlink" title="Coding"></a>Coding</h5><p>为突出时间概念同样使用RACSubject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RACSubject * signalOfSignals = [RACSubject subject];</span><br><span class="line">RACSubject * signalA = [RACSubject subject];</span><br><span class="line">RACSubject * signalB = [RACSubject subject];</span><br><span class="line">RACSubject * signalC = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[signalOfSignals flatten] subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);//output 1 3 5 7 8</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalA];</span><br><span class="line">[signalA sendNext:@1];</span><br><span class="line">[signalOfSignals sendNext:signalB];</span><br><span class="line"></span><br><span class="line">[signalA sendNext:@2];</span><br><span class="line">[signalB sendNext:@3];</span><br><span class="line">[signalA sendNext:@4];</span><br><span class="line"></span><br><span class="line">[signalOfSignals sendNext:signalC];</span><br><span class="line">[signalA sendCompleted];</span><br><span class="line">[signalC sendNext:@5];</span><br><span class="line">[signalB sendNext:@6];</span><br><span class="line">[signalB sendCompleted];</span><br><span class="line">[signalOfSignals sendCompleted];</span><br><span class="line">[signalC sendNext:@7];</span><br><span class="line">[signalC sendNext:@8];</span><br><span class="line">[signalC sendCompleted];</span><br></pre></td></tr></table></figure><h4 id="FlattenMap"><a href="#FlattenMap" class="headerlink" title="FlattenMap"></a>FlattenMap</h4><p>不止局限于RAC（例如：RxJava），flattenMap在整个函数式编程中也是一个重要的概念。以字面理解flattenMap是flatten操作和map操作的结合，事实上也的确如此。</p><h5 id="Flatten-amp-amp-Map"><a href="#Flatten-amp-amp-Map" class="headerlink" title="Flatten &amp;&amp; Map"></a>Flatten &amp;&amp; Map</h5><p>flattenMap的本质是map然后flatten：它首先利用map将值映射为信号（升阶），然后利用flatten进行降阶。这里只是说明功能，flattenMap的实现并不是通过调用map+flatten实现的。实质上flattenMap的map是通过在block生成中间信号M，flatten是在内部对中间信号进行订阅实现的。后续会对RAC源码进行更深入探究，这里只说明功能。</p><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><p>考虑将一个无效值转换为error事件，不止局限于理论在实际开发中我们也经常碰到这样的需求。</p><h6 id="Flatten-amp-amp-Map组合实现"><a href="#Flatten-amp-amp-Map组合实现" class="headerlink" title="Flatten &amp;&amp; Map组合实现"></a>Flatten &amp;&amp; Map组合实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = @[@1,@2,@3,@0].rac_sequence.signal;</span><br><span class="line"></span><br><span class="line">RACSignal * mappedSignal = [[signal map:^id(NSNumber * value) &#123;</span><br><span class="line">    if (value.integerValue == 0) &#123;</span><br><span class="line">        return [RACSignal error:[NSError errorWithDomain:@&quot;bosskai.com&quot; code:-1 userInfo:nil]];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [RACSignal return:value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]flatten] ;</span><br><span class="line"></span><br><span class="line">[mappedSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x); // output 1 2 3</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,error); // Error Domain=bosskai.com Code=-1 &quot;(null)&quot;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h6 id="FlattenMap实现"><a href="#FlattenMap实现" class="headerlink" title="FlattenMap实现"></a>FlattenMap实现</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = @[@1,@2,@3,@0].rac_sequence.signal;</span><br><span class="line"> </span><br><span class="line"> RACSignal * mappedSignal = [signal flattenMap:^RACStream *(NSNumber * value) &#123;</span><br><span class="line">     if (value.integerValue == 0) &#123;</span><br><span class="line">         return [RACSignal error:[NSError errorWithDomain:@&quot;booskai.com&quot; code:-1 userInfo:nil]];</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         return [RACSignal return:value];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> [mappedSignal subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,x); // output 1 2 3</span><br><span class="line"> &#125; error:^(NSError *error) &#123;</span><br><span class="line">     NSLog(@&quot;%@&quot;,error); // Error Domain=bosskai.com Code=-1 &quot;(null)&quot;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><p>实际开发中其实有很多类似的需求，FlattenMap也提供了完美的支持。利用FlattenMap可以轻松的完成信号间的转换，而且FlattenMap是支持串行异步操作的。那么为什么说FlattenMap在函数是编程中也是一个重要的概念呢？因为FlattenMap满足Monad。</p><h3 id="Functor、Applicatives和Monad"><a href="#Functor、Applicatives和Monad" class="headerlink" title="Functor、Applicatives和Monad"></a>Functor、Applicatives和Monad</h3><p>Functor、Applicatives和Monad是函数式编程汇总三个非常重要的术语。计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：Functor、Applicatives和Monad。</p><p>本篇中笔者从结论出发让大家有一个大概的印象，在之后的一篇post中会从swift出发为大家做详细剖析。我们可以将Functor、Applicatives和Monad理解为协议，协议内容为满足某种操作。</p><p>Functor： 应用一个函数到封装后的对象，如RAC中的map。<br>Applicatives：应用一个封装后的函数到一个封装后的对象。RAC并未提供对Applicatives的支持。<br>Monad：应用一个返回封装后的对象的函数到一个封装后的对象。RAC中的flattenMap。</p><p>封装后的对象我们可以理解为，RAC中的Signal、swift中的Optional。有点绕~，先有个概念。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;延续上一篇ReactiveCocoa操作详解,本篇笔者围绕针对RAC信号的维度变换（升阶、降阶）进行深入探究，同时在文章结尾给出Functor、Applicatives和Monad的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------ReactiveCocoa操作详解</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/</id>
    <published>2019-03-10T05:37:39.000Z</published>
    <updated>2019-03-10T05:40:08.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在之前的一篇Post中对函数响应式编程和RAC做了简单剖析,强烈建议没看过的同学猛戳链接。</p><p>ReactiveCocoa的核心是RACSignal类代表的信号。信号会产生一个事件流，事件有三种类型next、completed、error，一个信号源可以发送任意数量的next时间，直到该信号结束（completed）或因错误（error）而关闭。通过对信号的订阅可以获得不同事件的回调。使用这个简单的事件流模型，通过对信号的变换、组合操作，我们可以处理日常iOS开发中的按钮点击、网络请求响应、KVO或用户位置变化等各种事件类型。</p><p>本篇我们会围绕RACSignal的基本使用及各类操作做详细探究。</p><a id="more"></a><h3 id="RACSignal的创建"><a href="#RACSignal的创建" class="headerlink" title="RACSignal的创建"></a>RACSignal的创建</h3><p>RAC中我们可以通过以下几种方式获得一个信号。</p><h4 id="单元信号"><a href="#单元信号" class="headerlink" title="单元信号"></a>单元信号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal1 = [RACSignal return:@&quot;some Value&quot;];</span><br><span class="line">  RACSignal * signal2 = [RACSignal error:[NSError new]];</span><br><span class="line">  RACSignal * signal3 = [RACSignal empty];</span><br><span class="line">  RACSignal * signal4 = [RACSignal never];</span><br></pre></td></tr></table></figure><h4 id="动态信号"><a href="#动态信号" class="headerlink" title="动态信号"></a>动态信号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal5 = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       [subscriber sendNext:@1];</span><br><span class="line">       [subscriber sendNext:@2];</span><br><span class="line">       [subscriber sendError:[NSError new]];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接"><a href="#Cocoa桥接" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIButton  * btn = [UIButton new];</span><br><span class="line">   RACSignal * signal6 = [btn rac_signalForSelector:@selector(setFrame:)];</span><br><span class="line">   RACSignal * signal7 = [btn rac_signalForControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">   RACSignal * signal8 = [btn rac_willDeallocSignal];</span><br><span class="line">   RACSignal * signal9 = RACObserve(btn, backgroundColor);</span><br></pre></td></tr></table></figure><h4 id="信号变换"><a href="#信号变换" class="headerlink" title="信号变换"></a>信号变换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal10 = [signal1 map:^id(NSString * value) &#123;</span><br><span class="line">      return [value substringFromIndex:1];</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><h4 id="序列转换"><a href="#序列转换" class="headerlink" title="序列转换"></a>序列转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RACSequence * sequence = [RACSequence return:@1];</span><br><span class="line">   RACSignal * signal11 = sequence.signal;</span><br></pre></td></tr></table></figure><h3 id="信号的订阅方式"><a href="#信号的订阅方式" class="headerlink" title="信号的订阅方式"></a>信号的订阅方式</h3><h4 id="订阅方法"><a href="#订阅方法" class="headerlink" title="订阅方法"></a>订阅方法</h4><p>RAC的作者煞费苦心的为我们提供了对一个信号的next、error、completed三种事件的排列组合的订阅方法，这里列举一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[signal11 subscribeNext:^(id x) &#123;</span><br><span class="line">       NSLog(@&quot;next value is %@&quot;,x);</span><br><span class="line">   &#125; error:^(NSError *error) &#123;</span><br><span class="line">       NSLog(@&quot;Ops! Get some error:%@&quot;,error);</span><br><span class="line">   &#125; completed:^&#123;</span><br><span class="line">       NSLog(@&quot;It finished success&quot;);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(btn, backgroundColor)  = [RACSignal return:[UIColor redColor]];</span><br></pre></td></tr></table></figure><h4 id="Cocoa桥接-1"><a href="#Cocoa桥接-1" class="headerlink" title="Cocoa桥接"></a>Cocoa桥接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[btn rac_liftSelector:@selector(convertRect:toView:) withSignals:signal1, signal2,nil];</span><br></pre></td></tr></table></figure><h3 id="RACSignal各类操作"><a href="#RACSignal各类操作" class="headerlink" title="RACSignal各类操作"></a>RACSignal各类操作</h3><p>引用一张上一篇Post中的图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/stream_operation.png" alt=""></p><p>本篇文章主要围绕对值操作、对数量操作、对时间间隔操作及多个信号间的组合变换做深入探究，对维度的操作的探究会放在后续的文章中。</p><p>在深入下去之前，需要先了解一下RACTuple，RAC中很多操作都会用到或产生RACTuple。</p><h4 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h4><p>RACTuple（元组类）是RAC中的集合类，其底层实现是对NSArray的封装。RACTuple有以下特点：</p><ul><li>遵循NSFastEnumeration协议（可用for in枚举）</li><li>遵循NSCopy协议</li><li>遵循NSCoding协议</li><li>实现了objectAtIndexedSubscript:方法（可用下标访问元素）</li><li>可把NSNull.null转为RACTupleNil.tupleNil</li><li>封装了一系列遍历的集合操作方法</li></ul><h5 id="RACTuple的简单使用方式："><a href="#RACTuple的简单使用方式：" class="headerlink" title="RACTuple的简单使用方式："></a>RACTuple的简单使用方式：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//普通创建 </span><br><span class="line"> RACTuple *tuple1 = [RACTuple tupleWithObjects:@1, @2, @3, nil];</span><br><span class="line"> RACTuple *tuple2 = [RACTuple tupleWithObjectsFromArray:@[@1, @2, @3]];</span><br><span class="line"> RACTuple *tuple3 = [[RACTuple alloc] init]; </span><br><span class="line"></span><br><span class="line">//宏创建</span><br><span class="line"> RACTuple *tuple4 = RACTuplePack(@1, @2, @3, @4); </span><br><span class="line"></span><br><span class="line">//解包(等号前面是参数定义，后面是已存在的Tuple，参数个数需要跟Tuple元素相同）</span><br><span class="line"> RACTupleUnpack(NSNumber * value1, NSNumber * value2, NSNumber * value3, NSNumber * value4) = tuple4; </span><br><span class="line"></span><br><span class="line">//元素访问方式</span><br><span class="line"> NSLog(@&quot;%@&quot;, [tuple4 objectAtIndex:1]); NSLog(@&quot;%@&quot;, tuple4[1]);</span><br></pre></td></tr></table></figure><h3 id="RACSignal的操作"><a href="#RACSignal的操作" class="headerlink" title="RACSignal的操作"></a>RACSignal的操作</h3><p>对于信号操作、变化后得到的结果会从Next事件、Error事件、Completed事件三个角度并结合相应图例给出，不会对其底层实现做深入探究。</p><h4 id="对值操作"><a href="#对值操作" class="headerlink" title="对值操作"></a>对值操作</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Next事件：新信号的值由原信号值经过映射得出。（映射由传入block给出）<br>Error事件：透传原信号error事件。<br>Completed事件：透传原信号completed事件。</p><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Map.png" alt=""></p><h5 id="MapReplace"><a href="#MapReplace" class="headerlink" title="MapReplace"></a>MapReplace</h5><ul><li>Next事件：原信号的值会被转换成一串相同的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例<br><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/MapReplace.png" alt=""></p><h5 id="ReduceEach"><a href="#ReduceEach" class="headerlink" title="ReduceEach"></a>ReduceEach</h5><p>ReduceEach操作要求原信号的值必须是一个元组（RACTuple）。</p><ul><li>Next事件：对原信号发送的元组进行解包，利用解包后的值作为block的入参经过映射得出新的值。（映射由block给出）。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ReduceEach.png" alt=""></p><h5 id="ReduceApply"><a href="#ReduceApply" class="headerlink" title="ReduceApply"></a>ReduceApply</h5><p>ReduceApply其功能类似于ReduceEach。不过这里和ReduceEach不同的是，源信号产生的每个元组（每个值）的第0个元素必须是一个block，后面n个元素为block的入参，第0位的block有几个入参，后面就需要有几个元素，多余的元素为无效元素。</p><ul><li>Next事件：对原信号发送的元组进行解包，以元组的第0个元素为block，其余元素为入参得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ReduceApply.png" alt=""></p><h6 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h6><p>不是很好理解，这里给出相应代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">      </span><br><span class="line">      id block = ^id(NSNumber * first,NSNumber * second)&#123;</span><br><span class="line">          return @(first.integerValue + second.integerValue);</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      [subscriber sendNext:RACTuplePack(block,@1,@2,@5)];</span><br><span class="line">      return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">      &#125;];</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  RACSignal * signalB = [signalA reduceApply];</span><br><span class="line">  </span><br><span class="line">  [signalB subscribeNext:^(id x) &#123;</span><br><span class="line">      NSLog(@&quot;%@&quot;,x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure><p>上例代码中block只有两个入参，所以只会取1，2计算得出新值3，tuple内的元素5为无效元素。</p><h5 id="Not"><a href="#Not" class="headerlink" title="Not"></a>Not</h5><p>not操作要求源信号产生的每个值都是NSNumber类型。新信号的值由原信号值的布尔值取非得出。</p><ul><li>Next事件：由原信号值的布尔值取非得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Not.png" alt=""></p><h5 id="And"><a href="#And" class="headerlink" title="And"></a>And</h5><p>and操作要求源信号产生的每个值都是元组类型且元组内的每一个元素都必须是NSNumber类型。and操作会创建一个新的信号，新信号的值由元组内各元素的布尔值求与得出。</p><ul><li>Next事件：由源信号发送的元组内各元素的布尔值求与得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/and.png" alt=""></p><h5 id="Or"><a href="#Or" class="headerlink" title="Or"></a>Or</h5><p>or操作与and操作类似，不同的是新信号的值由元组内各元素的布尔值求或得出。这里不做展开讨论。</p><h5 id="Materialize"><a href="#Materialize" class="headerlink" title="Materialize"></a>Materialize</h5><p>materialize操作会创建一个新信号，新信号的值为将原信号的值包装为RACEvent类型。</p><ul><li>Next事件：由原信号的值包装为RACEvent类型得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><h6 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h6><p>materialize操作通过源码更容易理解。通过对原信号的订阅，将原信号的值、error、complete包装成RACEvent类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)materialize &#123;</span><br><span class="line">return [[RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">return [self subscribeNext:^(id x) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithValue:x]];</span><br><span class="line">&#125; error:^(NSError *error) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithError:error]];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendNext:RACEvent.completedEvent];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -materialize&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dematerialize"><a href="#Dematerialize" class="headerlink" title="Dematerialize"></a>Dematerialize</h5><p>Dematerialize是materialize的逆操作,新信号的值为将原信号值（RACEvent类型）还原为正常的值信号。</p><ul><li>Next事件：由原信号的值(RACEvent类型)还原得出新的值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><h6 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h6><p>同样通过源码来看dematerialize操作。通过bind函数对原信号进行变换。新信号会根据event.eventType进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)dematerialize &#123;</span><br><span class="line">return [[self bind:^&#123;</span><br><span class="line">return ^(RACEvent *event, BOOL *stop) &#123;</span><br><span class="line">switch (event.eventType) &#123;</span><br><span class="line">case RACEventTypeCompleted:</span><br><span class="line">*stop = YES;</span><br><span class="line">return [RACSignal empty];</span><br><span class="line"></span><br><span class="line">case RACEventTypeError:</span><br><span class="line">*stop = YES;</span><br><span class="line">return [RACSignal error:event.error];</span><br><span class="line"></span><br><span class="line">case RACEventTypeNext:</span><br><span class="line">return [RACSignal return:event.value];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:@&quot;[%@] -dematerialize&quot;, self.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数量操作"><a href="#数量操作" class="headerlink" title="数量操作"></a>数量操作</h4><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><p>将原信号的值进行过滤后，符合条件的值会做为新信号的值返回，否则原信号的值会被吞掉。</p><ul><li>Next事件：对原信号发送的值进行过滤后得出。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Filter.png" alt=""></p><h5 id="Ignore"><a href="#Ignore" class="headerlink" title="Ignore"></a>Ignore</h5><p>ignore的底层实现是对Filter的封装。对原信号的值进行校验，与传入值相等的值会被吞掉，其他值会作为新信号的值返回。这里的相等为满足 “==” 操作符 或 “isEqual” 操作符。</p><ul><li>Next事件：对原信号发送的值进行过滤后得出。</li><li>Error事件：透传原信号error事件。</li></ul><p>Completed事件：透传原信号completed事件。</p><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ignore.png" alt=""></p><h5 id="IgnoreValues"><a href="#IgnoreValues" class="headerlink" title="IgnoreValues"></a>IgnoreValues</h5><p>ignoreValues的底层实现同样是对Filter的封装。创建一个忽略所有原有信号值的信号。即新信号不会发送任何next事件。这里不做展开讨论。</p><h5 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h5><p>distinctUntilChanged操作会对接收到的原信号的值与原信号上一次发送的值做校验，如果相等则忽略该值，只有和原信号上一次发送的值不同才会做为新信号的值进行传递。这里的相等同样是指满足 “==” 操作符 或 “isEqual” 操作符。</p><ul><li>Next事件：对原信号的值与上一次的值做校验，当前值与上一次值不一致时做为新信号的值发送。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/DistinctUntilChanged.png" alt=""></p><h5 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h5><p>take操作的入参为取原信号的前X个值，做为新信号的值返回，忽略原信号前x值以后的值。</p><ul><li>Next事件：取原信号的前x个值作为新信号的值，忽略其他值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/take.png" alt=""></p><h5 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h5><p>skip操作和take操作是补集关系。take是取原信号的前count个信号值，而skip是从原信号的第count + 1个信号值开始取值做为新信号的值返回。这里不做展开讨论。</p><h5 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a>TakeLast</h5><p>takeLast和take用法一样，不过他取的是原信号的最后x个值。需要注意的是：takeLast一定要调用sendCompleted，告诉他发送完成了，这样才能取到最后几个值，这里也就不对其进行展开了。</p><h5 id="TakeUntilBlock"><a href="#TakeUntilBlock" class="headerlink" title="TakeUntilBlock"></a>TakeUntilBlock</h5><p>根据传入的block做为校验条件。新信号透传原信号发送的值直至原信号发送的值满足校验条件，此时新信号停止发送值。</p><ul><li>Next事件：取原信号的值作为新信号的值直至满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/takeUntilBlock.png" alt=""></p><h5 id="SkipUntilBlock"><a href="#SkipUntilBlock" class="headerlink" title="SkipUntilBlock"></a>SkipUntilBlock</h5><p>根据传入的block做为校验条件。新信号忽略原信号发送的值直至原信号发送的值满足校验条件，此时新信号开始透传原信号发送的值。</p><ul><li>Next事件：忽略原信号发送的值直至原信号发送的值满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/skipUntilBlock.png" alt=""></p><h5 id="SkipWhileBlock"><a href="#SkipWhileBlock" class="headerlink" title="SkipWhileBlock"></a>SkipWhileBlock</h5><p>根据传入的block做为校验条件。新信号忽略原信号发送的值直至发送的值不满足校验条件。此时新信号开始透传原信号发送的值。</p><ul><li>Next事件：忽略原信号发送的值直至原信号发送的值不满足校验条件。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/skipWhileBlock.png" alt=""></p><h5 id="Any"><a href="#Any" class="headerlink" title="Any:"></a>Any:</h5><p>Any:操作根据传入block作为校验条件。如果原信号发送的值中有任何满足校验条件的值新信号发送@1（yes）。 如原信号中无任何满足校验条件的值，在原信号调用sendCompleted后，新信号发送@0（no）。<br>注意：使用Any:操作原信号必须调用sendCompleted，否则在所有值都校验失败的情况下新信号不会发送@0（no）.</p><ul><li>Next事件：原信号所发送的值中有任何值满足校验条件发送@1（yes），否则发送 @0（no）。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例<br>校验失败</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Any-faild.png" alt=""></p><p>校验成功</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/any-success.png" alt=""></p><h5 id="Any-1"><a href="#Any-1" class="headerlink" title="Any"></a>Any</h5><p>当原信号发送任何值，新信号就会发送@1（yes）。Any操作也需要原信号调用sendCompleted，否则在原信号不发送任何值的情况下，新信号不会发送@0（no），这里就不做展开了。</p><h5 id="All"><a href="#All" class="headerlink" title="All:"></a>All:</h5><p>All:操作以传入blcok作为校验条件，当原信号发送的任何值都满足校验条件时，新信号会发送@1（yes），否则新信号发送@0（no）。All:同样需要原信号调用sendCompleted。比较容易理解，也就不再展开。</p><p>#####StartWith<br>startWIth操作，利用contact（后续会提到）在透传原信号发送的值之前插入一个初始值。</p><ul><li>Next事件：在原信号发送的值之前插入一个初始值。</li><li>Error事件：透传原信号error事件。</li><li>Completed事件：透传原信号completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/startWith.png" alt=""></p><h5 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h5><p>在原信号发送completed事件后，持续重复发送原信号的值。</p><ul><li>Next事件：在原信号发送completed之前，发送原信号的值。 在原信号发送completed事件后，持续重复发送原信号的值。</li><li>Error事件：透传原信号error事件。不再重复发送原信号的值。</li><li>Completed事件：无completed事件。</li></ul><p>图例<br>原信号未发送error、completed</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_no_error-completed.png" alt=""></p><p>原信号发送error</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_send_error.png" alt=""></p><p>原信号发送completed</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/repeat_send_completed.png" alt=""></p><h5 id="Retry"><a href="#Retry" class="headerlink" title="Retry:"></a>Retry:</h5><p>透传原信号发送的值,在原信号出现error的时候，重试x次（重复订阅原信号x次），如果依旧error那么就会停止重试。</p><ul><li>Next事件: 发送原信号的值,在原信号发送error后，重试x次。</li><li>Error事件：在原信号发送error后，重试x次。如果依旧错误传递error。</li><li>Completed事件：透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/retry.png" alt=""></p><h5 id="Retry-1"><a href="#Retry-1" class="headerlink" title="Retry"></a>Retry</h5><p>retry为无限重试操作。底层为调用retry:实现，此时的入参为0。这里不做展开讨论。</p><h5 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h5><ul><li>Next事件: 将原信号的值收集起来，保存在NSMutableArray中，做为新信号的值。在原信号发送completed事件后发送该值。</li><li>Error事件：在原信号发送error后，丢弃所有值并传递error事件。</li><li>Completed事件：收到原信号的completed事件后发送收集起来的值并透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/collect.png" alt=""></p><p>ScanWithStart:reduce:</p><ul><li>Next事件: 以第一个入参为初始值，原信号每发送一个值以reduceBlock的策略为递推计算结果，计算结果作为新信号的值立刻发送。</li><li>Error事件：透传error事件。</li><li>Completed事件：透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/ScanWithStart-reduce-.png" alt=""></p><p>#####AggregateWithStart:reduce:<br>本质为调用scanWithStart:reduce:操作和takeLast组合实现。</p><ul><li>Next事件: 以第一个入参为初始值，原信号每发送一个值以reduceBlock的策略为递推计算结果，在原信号发送sendCompleted后，新信号发送递推所得计算结果。</li><li>Error事件：透传error事件、丢弃计算结果。</li><li>Completed事件：发送计算结果并透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Aggregate.png" alt=""></p><h5 id="AggregateWithStartFactory-reduce"><a href="#AggregateWithStartFactory-reduce" class="headerlink" title="AggregateWithStartFactory: reduce:"></a>AggregateWithStartFactory: reduce:</h5><p>startFactory :aggregateWithStartFactory 本质为调用 aggregateWithStart实现，startFactory代码块的计算结果会作为start的入参传入aggregateWithStart。这里不做进一步展开。</p><h5 id="AggregateWithStart-reduceWithIndex"><a href="#AggregateWithStart-reduceWithIndex" class="headerlink" title="AggregateWithStart:reduceWithIndex:"></a>AggregateWithStart:reduceWithIndex:</h5><p>在aggregateWithStart:reduce: 的基础上，每次reduceBlock的递推都会带上统计当前递推次数的index。底层实现aggregateWithStart:reduce:为调用aggregateWithStart:reduceWithIndex:时忽略index参数。不做展开讨论。</p><h5 id="ScanWithStart-reduceWithIndex"><a href="#ScanWithStart-reduceWithIndex" class="headerlink" title="ScanWithStart:reduceWithIndex:"></a>ScanWithStart:reduceWithIndex:</h5><p>功能上与scanWithStart:reduce:类似，同样在reduceBlock会携带当前递推次数的index。scanWithStart:reduce:的底层实现同样为调用scanWithStart:reduceWithIndex:时忽略block内的index入参。同样不做展开讨论。</p><h4 id="对时间间隔操作"><a href="#对时间间隔操作" class="headerlink" title="对时间间隔操作"></a>对时间间隔操作</h4><h5 id="Delay"><a href="#Delay" class="headerlink" title="Delay:"></a>Delay:</h5><p>Delay:操作对原信号的next事件和completed事件延时发送，比较容易理解这里不做展开讨论。</p><ul><li>Next事件: 对原信号的值延迟x秒发送。</li><li>Error事件：立即透传error事件。</li><li>Completed事件：对于原信号的Completed事件延迟x秒发送。</li></ul><h5 id="Throttle"><a href="#Throttle" class="headerlink" title="Throttle:"></a>Throttle:</h5><p>throttle:通常用于搜索输入框，在用户享受实时更新搜索数据的同时减轻服务端压力。这里简单的Coding不能很形象说明，就不再编写代码。</p><ul><li>Next事件: 原信号在x秒内无新的值产生，新信号发送该值。</li><li>Error事件：透传error事件，如果之前有未发送next事件丢弃该事件（不再发送）。</li><li>Completed事件：新信号立刻透传该事件，如果之前有未发送next事件的值立即发送该值。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/throttle.png" alt=""></p><h5 id="Throttle-valuesPassingTest"><a href="#Throttle-valuesPassingTest" class="headerlink" title="Throttle:valuesPassingTest:"></a>Throttle:valuesPassingTest:</h5><p>在throttle：的基础上加入校验操作。</p><ul><li>Next事件: 对原信号发送的值进行校验，校验失败丢弃该值。校验成功，若原信号在x秒内无新的校验成功的next值产生，新信号发送该值。</li><li>Error事件：透传error事件，如果之前有未发送next事件的值丢弃该值（不再发送）。</li><li>Completed事件：新信号立刻透传该事件，如果之前有未发送校验成功的next事件的值立即发送该值。</li></ul><h5 id="BufferWithTime-onScheduler"><a href="#BufferWithTime-onScheduler" class="headerlink" title="BufferWithTime:onScheduler"></a>BufferWithTime:onScheduler</h5><ul><li>Next事件: 缓冲原信号未来一段时间内发送的next事件，将所有值包装成RACTuple返回。</li><li>Error事件：透传error事件，丢弃缓冲池内的值。</li><li>Completed事件：将缓冲池内的next事件立即发送后，立即透传completed事件。</li></ul><h4 id="多信号的组合、变换"><a href="#多信号的组合、变换" class="headerlink" title="多信号的组合、变换"></a>多信号的组合、变换</h4><h5 id="Concat"><a href="#Concat" class="headerlink" title="Concat:"></a>Concat:</h5><p>对A、B两个信号进行链接，A发送completed事件后开始发送B信号的事件。</p><ul><li>Next事件：透传A信号的值，A信号发送completed事件后开始透传B信号的值。</li><li>Error事件：A、B任一信号发出error事件后透传该事件，且不再进行拼接操作。</li><li>Completed事件：B信号发送completed事件后，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Concat.png" alt=""></p><p>concat操作不会改变原有信号值的发送线程。</p><h5 id="Merge"><a href="#Merge" class="headerlink" title="Merge:"></a>Merge:</h5><p>将A、B两个信号进行合并。</p><ul><li>Next事件：按时间顺序透传A、B两信号的next事件。</li><li>Error事件：A、B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A、B两信号，均发送completed事件后，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Merge.png" alt=""></p><p>merge操作不会改变原有信号值的发送线程。</p><h5 id="Zip"><a href="#Zip" class="headerlink" title="Zip:"></a>Zip:</h5><p>将A、B两信号发送的值压缩为一个元组。每个流的第一个值将被合并、然后是第二个、第三个，直到一个流被终止。</p><ul><li>Next事件：在A、B两信号都发送next事件后，将next事件携带值合并成一个元组作。新信号以该元组为值发送next事件。</li><li>Error事件：A、B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A、B两信号，任意信号发送completed，新信号发送completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/Zip.png" alt=""></p><p>Zip操作新信号发送事件的线程与触发线程一致。</p><h4 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest:"></a>CombineLatest:</h4><ul><li>Next事件：将来自A/B两信号的最新值组合成一个RACTuples，A、B任何一个信号发送值（如果另一个信号曾经发送过值）都会产生一个RACTuple并传递下去。</li><li>Error事件：A/B两信号，任意信号发送error事件，透传error事件。</li><li>Completed事件：A/B两信号，任意信号发送completed事件，透传completed事件。</li></ul><p>图例</p><p><img src="/2019/03/10/ReactiveCocoa-ReactiveCocoa操作详解/CombineLatest.png" alt=""></p><p>CombineLatest操作新信号发送事件的线程与触发线程一致。</p><h3 id="斐波那契数列信号"><a href="#斐波那契数列信号" class="headerlink" title="斐波那契数列信号"></a>斐波那契数列信号</h3><p>在之前的一篇Post里提示出提到我们可以用函数式编程表示一个无限的数据结构如斐波那契数列、无限递增的数据结构。<br>那么在RAC中应该如何来做呢？</p><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *repeat1 = [[RACSignal return:@1] repeat];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [repeat1 scanWithStart:RACTuplePack(@1, @1) reduce:^id(RACTuple *running, id _) &#123;</span><br><span class="line">    NSNumber * next = @([running.first integerValue] + [running.second integerValue]);</span><br><span class="line">    return RACTuplePack(running.second, next);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalB subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="无限递增的数据结构"><a href="#无限递增的数据结构" class="headerlink" title="无限递增的数据结构"></a>无限递增的数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *repeat1 = [[RACSignal return:@1] repeat];</span><br><span class="line"></span><br><span class="line">RACSignal *signalB = [repeat1 scanWithStart:@0 reduce:^id(NSNumber * running, NSNumber * next) &#123;</span><br><span class="line">    return @(running.integerValue + next.integerValue);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signalB subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>To be continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在之前的一篇Post中对函数响应式编程和RAC做了简单剖析,强烈建议没看过的同学猛戳链接。&lt;/p&gt;
&lt;p&gt;ReactiveCocoa的核心是RACSignal类代表的信号。信号会产生一个事件流，事件有三种类型next、completed、error，一个信号源可以发送任意数量的next时间，直到该信号结束（completed）或因错误（error）而关闭。通过对信号的订阅可以获得不同事件的回调。使用这个简单的事件流模型，通过对信号的变换、组合操作，我们可以处理日常iOS开发中的按钮点击、网络请求响应、KVO或用户位置变化等各种事件类型。&lt;/p&gt;
&lt;p&gt;本篇我们会围绕RACSignal的基本使用及各类操作做详细探究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------Functor、Applicatives和Monad</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-Functor%E3%80%81Applicatives%E5%92%8CMonad/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-Functor、Applicatives和Monad/</id>
    <published>2019-03-10T05:35:58.000Z</published>
    <updated>2019-03-10T05:37:01.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：函数式编程中的Functor、Applicatives和Monad。</p><p>Functor、Applicatives和Monad的概念源自范畴论。本篇笔者从Swift的Optional入手阐述Functor、Applicatives和Monad在函数式编程中的概念。对比于OC，swift提供了对函数式编程更好的支持。</p><a id="more"></a><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Apple在WWDC 2014开发者大会上发布了用于Mac OS X和iOS编程的新一代编程语言Swift。Optional（可选值）为Swift中一个重要的概念。</p><h3 id="Optional-封装后的值"><a href="#Optional-封装后的值" class="headerlink" title="Optional-封装后的值"></a>Optional-封装后的值</h3><p>Optional数据类型事实上就是封装后的值，即对值及其上下文环境进行封装的结果。</p><p>Optional的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个Optional类型的值，为空的时候就是.none,不为空的时候就是.some。当我们将一个函数应用于Optional，不同上下文（.some或.none）我们将得到不同的结果。函数式编程中Functor、Applicatives和Monad的概念就是基于对封装后的值进行操作。</p><p>函数式编程中将值与上下文进行封装，对封装后的值进行操作可以集中于我们想要完成的事情，省去了异常分支（.none）的判断、嵌套。这样的代码具有更高的可读性，也更不易出错。如在RAC中对RACSignal发送的map、filter操作的过程中，我们将精力集中在next事件上，error、completed事件的传递处理都封装在RACSignal中。</p><h3 id="MyOptional"><a href="#MyOptional" class="headerlink" title="MyOptional"></a>MyOptional</h3><p>Swift的Optional只满足函数式编程中的Functor,Monad，并不满足Applicatives的概念。笔者在ReactiveCocoa高阶操作中给出了Functor、Applicatives和Monad概念定义。本篇中笔者用Swift实现满足Functor、Applicatives和Monad概念的MyOptional对这些概念进一步阐述。</p><h4 id="MyOptional定义"><a href="#MyOptional定义" class="headerlink" title="MyOptional定义"></a>MyOptional定义</h4><p>类似Optional 给出简单定义 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum MyOperation &lt;T&gt; &#123;</span><br><span class="line">    case some(T)</span><br><span class="line">    case none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将Functor、Applicatives和Monad理解为一种协议，遵循该协议实现对应的方法，即为满足Functor、Applicatives和Monad。</p><h4 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h4><blockquote><p>Functor:应用一个函数到封装后的对象。</p></blockquote><p>添加map函数，应用函数到MyOptional对象，使MyOptional满足Functor。</p><h5 id="map实现"><a href="#map实现" class="headerlink" title="map实现"></a>map实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension MyOptional&#123;</span><br><span class="line">    //应用一个函数到MyOptional</span><br><span class="line">    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; MyOptional&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .some(a):</span><br><span class="line">            return MyOptional&lt;U&gt;.some(f(a))</span><br><span class="line">            </span><br><span class="line">        case .none:</span><br><span class="line">            return MyOptional&lt;U&gt;.none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="map使用"><a href="#map使用" class="headerlink" title="map使用"></a>map使用</h5><p>通过map方法，应用plusTree到MyOptional对象，同时在plusTree中我们只关注想要执行的操作，.none的异常分支被封装在MyOptional的map实现中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func plusTree(addend:Int) -&gt; Int &#123;</span><br><span class="line">  return  addend + 3</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">let some = MyOptional.some(2).map(f: plusTree)</span><br><span class="line">let none = MyOptional&lt;Int&gt;.none.map(f: plusTree)</span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><h4 id="Applicatives"><a href="#Applicatives" class="headerlink" title="Applicatives"></a>Applicatives</h4><blockquote><p>Applicatives:应用一个封装后的方法到一个封装后的对象。</p></blockquote><p>函数式编程中函数是一等公民，我们可以将值与其上下文进行封装，同样我们也可以将函数与其上下文进行封装。</p><p>添加apply函数，应用函数到MyOptional对象，使MyOptional满足Applicatives。</p><h5 id="apply实现"><a href="#apply实现" class="headerlink" title="apply实现"></a>apply实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension MyOperation&#123;</span><br><span class="line">    //应用一个封装过的函数到MyOperation</span><br><span class="line">    func apply&lt;U&gt;(f:(MyOperation&lt;(T)-&gt;U&gt;))-&gt; MyOperation&lt;U&gt; &#123;</span><br><span class="line">        switch f &#123;</span><br><span class="line">        case let .some(someF):</span><br><span class="line">            return self.map(f: someF)</span><br><span class="line">        case .none:</span><br><span class="line">            return .none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="apply使用"><a href="#apply使用" class="headerlink" title="apply使用"></a>apply使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func plusTree(addend:Int) -&gt; Int &#123;</span><br><span class="line">   return  addend + 3</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">let funcSome = MyOptional.some(plusTree)</span><br><span class="line">let funcNone = MyOptional&lt;(Int)-&gt;Int&gt;.none</span><br><span class="line">        </span><br><span class="line">let some = MyOptional.some(2).apply(f: funcSome)</span><br><span class="line">let none = MyOptional.some(2).apply(f: funcNone) </span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><p>将plusTree和 MyOptional&lt;(Int)-&gt;Int&gt;.none封装为MyOption，并通过apply进行调用。</p><h4 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h4><blockquote><p>Monad：应用一个返回封装后的对象的方法到一个封装后的对象。</p></blockquote><p>添加flatMap函数，应用一个返回封装后的对象的函数到一个封装后的对象。使MyOptional满足Monad。</p><h5 id="flatMap实现"><a href="#flatMap实现" class="headerlink" title="flatMap实现"></a>flatMap实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension MyOptional&#123;</span><br><span class="line"></span><br><span class="line">    //应用一个返回MyOptional的函数到MyOptional</span><br><span class="line">    func flatMap&lt;U&gt;(f: (T) -&gt; MyOptional&lt;U&gt;) -&gt; MyOptional&lt;U&gt; &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .some(a):</span><br><span class="line">            return f(a)</span><br><span class="line">        case .none:</span><br><span class="line">            return .none</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="flatMap使用"><a href="#flatMap使用" class="headerlink" title="flatMap使用"></a>flatMap使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//返回MyOptional的函数</span><br><span class="line">func plusTree(addend:Int) -&gt; MyOptional &lt;Int&gt; &#123;</span><br><span class="line">  return  MyOptional&lt;Int&gt;.some(addend + 3)</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">let some = MyOptional.some(2).flatMap(f: plusTree)</span><br><span class="line">let none = MyOptional&lt;Int&gt;.none.flatMap(f: plusTree)</span><br><span class="line">        </span><br><span class="line">print(some)// output some(5)</span><br><span class="line">print(none)// output none</span><br></pre></td></tr></table></figure><p>至此，通过添加map、apply、flatMap函数，MyOptional分别“遵循Functor、Applicative、Monad协议”。我们可以称MyOptional是Functor/Applicative/Monad。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>一个 Functor 就是一种实现了 Functor typeclass（协议） 的数据类型；</li><li>一个 Applicative 就是一种实现了 Applicative typeclass（协议） 的数据类型；</li><li>一个 Monad 就是一种实现了 Monad typeclass（协议）的数据类型。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures/" target="_blank" rel="noopener">Swift Functors, Applicatives, and Monads in Pictures</a><br><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank" rel="noopener">Functors, Applicative Functors and Monoids</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;计算机科学习惯于为抽象概念命名术语，我们也从这些术语中获益良多。这些术语使我们在交流中能够引用抽象概念，并立即使对方知道我们的意思，比如我们从设计模式的共享名称（工厂、装饰器等）中获益良多。其中一些术语非常抽象，如：函数式编程中的Functor、Applicatives和Monad。&lt;/p&gt;
&lt;p&gt;Functor、Applicatives和Monad的概念源自范畴论。本篇笔者从Swift的Optional入手阐述Functor、Applicatives和Monad在函数式编程中的概念。对比于OC，swift提供了对函数式编程更好的支持。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------冷信号vs热信号</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-%E5%86%B7%E4%BF%A1%E5%8F%B7vs%E7%83%AD%E4%BF%A1%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-冷信号vs热信号/</id>
    <published>2019-03-10T05:34:26.000Z</published>
    <updated>2019-03-10T05:35:22.437Z</updated>
    
    <content type="html"><![CDATA[<p>冷热信号的概念是源自于源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：</p><blockquote><ol><li>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。</li><li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。 </li></ol></blockquote><p>冷热信号分别对应RAC中的RACSignal和RACSubject，RACSubject是RACSignal的子类。本文中笔者将从示例代码引入RACSignal（冷信号）在实际应用中的问题及RACSubject（热信号）的使用，通过剖析RACSubject的源码，阐述冷热信号的概念及RACSubject的实现。</p><a id="more"></a><h3 id="懒惰的RACSignal"><a href="#懒惰的RACSignal" class="headerlink" title="懒惰的RACSignal"></a>懒惰的RACSignal</h3><p>笔者函数式编程提到了惰性求值的概念:</p><blockquote><p>惰性求值（尽可能延迟表达式求值），表达式不会在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p></blockquote><p>RACSignal就是惰性求值的。RACSignal的didSubscribe block只有在RACSignal被订阅的时候才会被执行，而且每次订阅RACSignal都会执行一遍didSubscribe block。也正是这个特性赋予了RACSignal冷信号的特点。同时，RACSignal的这些特点也导致了其在实际应用中的一些问题。</p><h4 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h4><p>一起看以下示例代码</p><h5 id="示例一：RACSignal-amp-副作用"><a href="#示例一：RACSignal-amp-副作用" class="headerlink" title="示例一：RACSignal &amp; 副作用"></a>示例一：RACSignal &amp; 副作用</h5><p>以下代码在didSubscribe中引入副作用”i += 1“，通过Output可以看出这种情况下对同一个信号多次订阅拿到不同的值，这显然是我们不想看到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__block int i = 0;</span><br><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    i += 1;</span><br><span class="line">    [subscriber sendNext:@(i)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber1---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber2---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscriber3---recived---%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-04 18:53:38.660673+0800 RACDemo[98599:6473410] subscriber1---recived---1</span><br><span class="line">2018-03-04 18:53:38.661029+0800 RACDemo[98599:6473410] subscriber2---recived---2</span><br><span class="line">2018-03-04 18:53:38.661184+0800 RACDemo[98599:6473410] subscriber3---recived---3</span><br></pre></td></tr></table></figure><h4 id="RACSignal-amp-时间"><a href="#RACSignal-amp-时间" class="headerlink" title="RACSignal &amp; 时间"></a>RACSignal &amp; 时间</h4><p>以下代码signal以1秒的间隔依次发送1，2，3。subscriber1立即订阅signal（signal未发送任何值之前），subscribe2在3.1秒后（signal将所有值发送完毕后）订阅signal。在不同时间订同一信号获取的结果是一样的。通过Output可以看出在任意时间点订阅signal，signal都会以1秒的间隔依次发送1，2，3。很多情况下，这同样不是我们想看到的，subscribe2只关心signal在3.1秒之后发送的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">    &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subscribe1----recieve-%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:3.1 schedule:^&#123;</span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;subscribe2----recieve-%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><p>注意时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2018-03-04 18:58:21.864222+0800 RACDemo[98639:6481792] subscribe1----recieve-1</span><br><span class="line">2018-03-04 18:58:22.863358+0800 RACDemo[98639:6481792] subscribe1----recieve-2</span><br><span class="line">2018-03-04 18:58:23.963592+0800 RACDemo[98639:6481792] subscribe1----recieve-3</span><br><span class="line">2018-03-04 18:58:24.967656+0800 RACDemo[98639:6481792] subscribe2----recieve-1</span><br><span class="line">2018-03-04 18:58:25.964144+0800 RACDemo[98639:6481792] subscribe2----recieve-2</span><br><span class="line">2018-03-04 18:58:26.967526+0800 RACDemo[98639:6481792] subscribe2----recieve-3</span><br></pre></td></tr></table></figure><p>结合在懒惰的RACSignal中提到RACSignal的特点。不难理解，示例一、示例二所展示的结果正式由于RACSignal的惰性求值及每次订阅重复调用didSubscribe block导致的。</p><h3 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h3><p>我们对示例二的代码进行一个小的改动,创建热信号subject,subject订阅signal，subscriber订阅subject不再直接订阅signal。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RACSignal * signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:1 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:2 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">    &#125;];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:3 schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@3];</span><br><span class="line">    &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject * subject = [RACSubject subject];</span><br><span class="line">[signal subscribe:subject];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;subject subscriber1----recieve-%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[RACScheduler mainThreadScheduler] afterDelay:3.1 schedule:^&#123;</span><br><span class="line">    [subject subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;subject subscriber2----recieve-%@&quot;,x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>Output</p><p>一起来看看发生了啥，立即订阅的subscriber1收到了所有值，而3.1秒之后订阅的subscribe2没有收到任何值。RACSubject就是RAC中的热信号，subject字面意思是“主题”。RACSubject是与时间强相关的。在事件发生时，只有已经订阅该主题的subscriber才会被通知。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-05 13:30:38.591185+0800 RACDemo[11918:7623749] subject subscriber1----recieve-1</span><br><span class="line">2018-03-05 13:30:39.590616+0800 RACDemo[11918:7623749] subject subscriber1----recieve-2</span><br><span class="line">2018-03-05 13:30:40.689946+0800 RACDemo[11918:7623749] subject subscriber1----recieve-3</span><br></pre></td></tr></table></figure><h3 id="RACSubject的实现"><a href="#RACSubject的实现" class="headerlink" title="RACSubject的实现"></a>RACSubject的实现</h3><p>我们通过分析RACSubject的源码来探究热信号的概念。</p><p>RACSubject是RACSignal的子类。相比于RACSignal丰富的头文件，RACSubject对外的接口并没有提供太多方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface RACSubject : RACSignal &lt;RACSubscriber&gt;</span><br><span class="line">+ (instancetype)subject;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>RACSubject的特性主要由subscribers订阅者数组和RACSubscriber协议提供。</p><h4 id="subscribers订阅者数组"><a href="#subscribers订阅者数组" class="headerlink" title="subscribers订阅者数组"></a>subscribers订阅者数组</h4><p>RACSubject维护了一个订阅者数组，每当有新的订阅者产生，都会将传入的 id 对象加入数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">        RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">        subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">        NSMutableArray *subscribers = self.subscribers;</span><br><span class="line">        @synchronized (subscribers) &#123;</span><br><span class="line">                [subscribers addObject:subscriber];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                @synchronized (subscribers) &#123;</span><br><span class="line">                        NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">                                return obj == subscriber;</span><br><span class="line">                        &#125;];</span><br><span class="line"></span><br><span class="line">                        if (index != NSNotFound) [subscribers removeObjectAtIndex:index];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;]];</span><br><span class="line"></span><br><span class="line">        return disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅的过程分为三个部分：</p><ol><li>初始化一个 RACPassthroughSubscriber 实例；</li><li>将subscriber加入RACSubject持有的数组中；</li><li>创建一个RACDisposable对象，在当前subscriber销毁时，将自身从数组中移除。</li></ol><p>订阅者数组，为RACSubject提供了一对多的能力。事件发生时RACSubject通过实现RACSubscriber协议提供的方法，遍历subscribers数组逐个发送消息。</p><h4 id="RACSubscriber协议"><a href="#RACSubscriber协议" class="headerlink" title="RACSubscriber协议"></a>RACSubscriber协议</h4><p>RACSubscriber协议为RACSubject提供了在创建成功后向订阅者继续发送消息的能力，RACSignal只能通过创建信号的didSubscribe block遵循该协议的subscriber发送消息。所以我们可以说，RACSignal是不可变的，RACSubject是可变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol RACSubscriber &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(nullable id)value;</span><br><span class="line">- (void)sendError:(nullable NSError *)error;</span><br><span class="line">- (void)sendCompleted;</span><br><span class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendNext:value];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendError:(NSError *)error &#123;</span><br><span class="line">        [self.disposable dispose];</span><br><span class="line"></span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sendCompleted &#123;</span><br><span class="line">        [self.disposable dispose];</span><br><span class="line"></span><br><span class="line">        [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSubject实现相对简单。类似于通知，通过维护订阅者数组在事件发生后为所有订阅者发送消息。在具体的编码过程中加入了一些锁用以避免线程竞争。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，结合Hot Observable和Cold Observable。我们不难理解，冷信号就好像看录像，热信号就好像是看直播。</p><blockquote><p>冷信号（看录像）<br>不可变：RACSignal创建后，将要发送的消息就是固定的。（录像录制完成后内容就是固定的）<br>一对一：当有不同的订阅者，RACSignal会重复发送所有消息。(为每一个观看者重复播放录像)<br>被动的：只有订阅者订阅的时候，才会发送消息。（没有人要求观看时不会播放录像）</p></blockquote><blockquote><p>热信号（看直播）<br>可变：RACSubject创建后，可以持续添加新事件。（直播总会有新的事情发生）<br>一对多：所有订阅者共享同一个RACSubject。（只有一个主播）<br>主动的：无论是否有订阅者，都会发送新事件。（有没有人看主播都会播）</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://williamzang.com/blog/2015/08/18/talk-about-reactivecocoas-cold-signal-and-hot-signal/" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号</a></p><p><a href="https://spin.atomicobject.com/2014/06/29/replay-replaylast-replaylazily/" target="_blank" rel="noopener">Comparing replay, replayLast, and replayLazily</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冷热信号的概念是源自于源于.NET框架Reactive Extensions(RX)中的Hot Observable和Cold Observable，两者的区别是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。&lt;/li&gt;
&lt;li&gt;Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送。 &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;冷热信号分别对应RAC中的RACSignal和RACSubject，RACSubject是RACSignal的子类。本文中笔者将从示例代码引入RACSignal（冷信号）在实际应用中的问题及RACSubject（热信号）的使用，通过剖析RACSubject的源码，阐述冷热信号的概念及RACSubject的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa------函数式编程初探</title>
    <link href="http://yoursite.com/2019/03/10/ReactiveCocoa-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2019/03/10/ReactiveCocoa-函数式编程初探/</id>
    <published>2019-03-10T05:31:54.000Z</published>
    <updated>2019-03-10T05:33:11.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ReactiveCocoa——函数式编程初探"><a href="#ReactiveCocoa——函数式编程初探" class="headerlink" title="ReactiveCocoa——函数式编程初探"></a>ReactiveCocoa——函数式编程初探</h2><h3 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h3><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程、函数式编程、逻辑式编程，常见的面向对象编程是一种命令式编程。</p><h4 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h4><blockquote><p>命令式编程是面向计算机硬件的抽象，有变量（对应存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），命令式程序就是一个冯诺依曼的指令序列。</p></blockquote><h4 id="函数式编程（FP）"><a href="#函数式编程（FP）" class="headerlink" title="函数式编程（FP）"></a>函数式编程（FP）</h4><blockquote><p>函数式编程是面向数学的抽象， 将计算描述为一种表达式求值， 函数式程序就是一个表达式。</p></blockquote><p>函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖于其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。</p><p>由于函数式编程是面向数学的抽象，更接近人的语言。函数式编程更关注结果，相对的命令式编程关注解决问题的步骤。使用函数式编程，代码会比较简洁，也容易被理解。</p><a id="more"></a><h3 id="函数式编程的本质"><a href="#函数式编程的本质" class="headerlink" title="函数式编程的本质"></a>函数式编程的本质</h3><h4 id="一等公民"><a href="#一等公民" class="headerlink" title="一等公民"></a>一等公民</h4><p>函数式编程中，函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>函数式编程中高阶函数是至少满足下列一个条件的函数：</p><ul><li>接受一个或多个函数作为输入</li><li>输出一个函数</li></ul><p>高阶函数范例：<br>这是一个Python script的例子，其中函式g()有一引数以及回传一函数.这个例子会打印100 ( g(f,7)= (7+3)×(7+3) ).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x + 3</span><br><span class="line"></span><br><span class="line">def g(function, x):</span><br><span class="line">    return function(x) * function(x)</span><br><span class="line"></span><br><span class="line">print g(f, 7)</span><br></pre></td></tr></table></figure><p>范例代码来自于：<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科</a></p><h4 id="不修改状态"><a href="#不修改状态" class="headerlink" title="不修改状态"></a>不修改状态</h4><blockquote><p>不变性是函数式编程的基石，面向对象的编程通过封装可变动的部分来构造能够让人读懂的代码，函数式编程则是通过最大程度地减少可变动的部分来构造出可让人读懂的代码。</p></blockquote><p>函数式编程语言中的变量不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。  </p><p>由于命令式编程语言也可以通过类似于函数指针的方式来实现高阶函数，函数式编程的优势主要是不可变性带来的。没有可变状态，函数就是引用透明、没有副作用的，也是线程安全的。</p><h4 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h4><p>引用透明，指的是函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数，即如果提供同样的输入，那么函数总是返回同样的结果。</p><h4 id="无“副作用”"><a href="#无“副作用”" class="headerlink" title="无“副作用”"></a>无“副作用”</h4><p>副作用，指的是函数内部与外部互动，产生预算以外的其他结果。（最典型的情况是修改全局变量的值）。<br>函数式编程强调无“副作用”，意味着函数要保持独立，所有功能就是计算返回一个新的值，没有其他行为，即，纯函数。</p><h4 id="更易调试"><a href="#更易调试" class="headerlink" title="更易调试"></a>更易调试</h4><p>函数不依赖外部状态也不修改外部状态，函数调用的结果不依赖调用的时间和位置，这样写的代码更容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p><h4 id="易于并发编程"><a href="#易于并发编程" class="headerlink" title="易于并发编程"></a>易于并发编程</h4><p>不可变性带来的另一个好处是：函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。<br>除此之外，就算某个函数式程序本身只是单线程的，编译器也可以将其优化成可以在多CPU上运行的并发程序。以下面程序为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = somewhatLongOperation1();</span><br><span class="line">String s2 = somewhatLongOperation2();</span><br><span class="line">String s3 = concatenate(s1, s2);</span><br></pre></td></tr></table></figure><p>由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。  </p><p>多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。</p><h4 id="只用“表达式”，不用“语句”"><a href="#只用“表达式”，不用“语句”" class="headerlink" title="只用“表达式”，不用“语句”"></a>只用“表达式”，不用“语句”</h4><blockquote><p>严格意义上的函数式编程意味着不适用可变的变量，赋值，循环和其他命令式控制结构进行编程。</p></blockquote><p>“表达式”是一个单纯的运算过程，总是有返回值；“语句”是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>函数式编程的如条件语句、循环语句也不是命令式编程语言中的控制语句，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。</p><h4 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h4><blockquote><p>惰性求值（尽可能延迟表达式求值），表达式不会在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</p></blockquote><p>由于函数是引用透明的以及函数式编程不像命令式编程那样关注执行步骤，这就为系统提供了优化函数式程序的空间，如惰性求值。惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至减少错误。</p><p>惰性求值有如下有点：</p><ul><li>首先，你可以用它们来创建无限序列这样一种数据类型。因为直到需要时才会计算值，这样就可以使用惰性集合模拟无限序列。例如存储一个Fibonacci数列数字的列表。</li><li>第二，减少了存储空间。因为在真正需要时才会发生计算。所以，节约了不必要的存储空间。</li><li>第三，减少计算量，产生更高效的代码。因为在真正需要时才会发生计算。例如，寻找数组中第一个符合某个条件的值。</li></ul><h3 id="Continuation-Passing-Style-CPS"><a href="#Continuation-Passing-Style-CPS" class="headerlink" title="Continuation Passing Style (CPS)"></a>Continuation Passing Style (CPS)</h3><h4 id="惰性求值的不足"><a href="#惰性求值的不足" class="headerlink" title="惰性求值的不足"></a>惰性求值的不足</h4><p>惰性求值当然也有其缺点。其中最大的一个就是，嗯，惰性。现实生活中很多问题还是需要严格求值、严格的执行顺序的。比如下面例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Please enter your name&quot;);</span><br><span class="line">System.in.readLine();</span><br></pre></td></tr></table></figure><p>由于这两行代码并不存在依赖关系，在惰性语言中没人能保证第一行会在第二行之前执行！这也就意味着我们不能处理IO，不能调用系统函数做任何事情，也就是说不能和外界交互了！<br>函数式编程中我们可以通过Continuation Passing Style 来保证代码按一定的顺序执行。</p><h4 id="CPS"><a href="#CPS" class="headerlink" title="CPS"></a>CPS</h4><p>CPS把函数调用完之后接下来要执行的代码通过闭包包裹并作为函数参数调用要执行的函数。方便理解我们先看一个例子</p><h5 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = add(5, 10);</span><br><span class="line">int j = square(i);</span><br></pre></td></tr></table></figure><p>add这个函数将返回15然后这个值会赋给i，这也是add被调用的地方。接下来i的值又会被用于调用square。请注意支持惰性求值的编译器不能打乱这段代码的执行顺序，因为第二个函数的执行依赖于第一个函数的执行结果。这段代码可以用CPS技术重写，这样一来add的返回值就不是传递给其调用者，而是直接传到square里去了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int j = add(5, 10, square);</span><br></pre></td></tr></table></figure><p>在上例中，add多了一个参数：一个函数，add必须在完成自己的计算后，调用这个函数并把结果传给它。</p><p>同样我们以CPS技术重写上述IO代码，编译器就必须顺序执行了，因为重写后的代码建立了依赖关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Please enter your name: &quot;, System.in.readLine);</span><br></pre></td></tr></table></figure><h4 id="CPS-amp-传统函数调用"><a href="#CPS-amp-传统函数调用" class="headerlink" title="CPS &amp; 传统函数调用"></a>CPS &amp; 传统函数调用</h4><h5 id="传统函数调用"><a href="#传统函数调用" class="headerlink" title="传统函数调用"></a>传统函数调用</h5><p>传统函数调用的程序需要额外的函数调用栈才能运行。</p><p>栈里面存放的是参数还有一个供函数运行结束后返回的程序指针，以支持函数返回后程序的继续运行。</p><h5 id="CPS风格函数调用"><a href="#CPS风格函数调用" class="headerlink" title="CPS风格函数调用"></a>CPS风格函数调用</h5><p>用CPS风格写出来的程序不需要栈，但是每次调用函数的时候都会要多加一个参数。</p><p>在这里完全没有函数需要做传统意义上的“返回”操作，函数执行完后仅需要接着调用另外一个函数就可以了。也完全不需要保留原来的参数：因为这种程序里的函数都不返回，所以它们不会被用第二次！</p><p>在CPS风格下的函数式编程，函数就是一个管道（pipe）。这头进去一个值另一头出来一个新的值并进入下一个管道，没有其他作用。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://www.defmacro.org/2006/06/19/fp.html" target="_blank" rel="noopener">Functional Programming For The Rest of Us</a><br><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式编程思维</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ReactiveCocoa——函数式编程初探&quot;&gt;&lt;a href=&quot;#ReactiveCocoa——函数式编程初探&quot; class=&quot;headerlink&quot; title=&quot;ReactiveCocoa——函数式编程初探&quot;&gt;&lt;/a&gt;ReactiveCocoa——函数式编程初探&lt;/h2&gt;&lt;h3 id=&quot;编程范式&quot;&gt;&lt;a href=&quot;#编程范式&quot; class=&quot;headerlink&quot; title=&quot;编程范式&quot;&gt;&lt;/a&gt;编程范式&lt;/h3&gt;&lt;p&gt;函数式编程是一种编程范式，我们常见的编程范式有命令式编程、函数式编程、逻辑式编程，常见的面向对象编程是一种命令式编程。&lt;/p&gt;
&lt;h4 id=&quot;命令式编程&quot;&gt;&lt;a href=&quot;#命令式编程&quot; class=&quot;headerlink&quot; title=&quot;命令式编程&quot;&gt;&lt;/a&gt;命令式编程&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;命令式编程是面向计算机硬件的抽象，有变量（对应存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），命令式程序就是一个冯诺依曼的指令序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;函数式编程（FP）&quot;&gt;&lt;a href=&quot;#函数式编程（FP）&quot; class=&quot;headerlink&quot; title=&quot;函数式编程（FP）&quot;&gt;&lt;/a&gt;函数式编程（FP）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;函数式编程是面向数学的抽象， 将计算描述为一种表达式求值， 函数式程序就是一个表达式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;函数式编程中的函数这个术语不是指计算机中的函数，而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖于其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。&lt;/p&gt;
&lt;p&gt;由于函数式编程是面向数学的抽象，更接近人的语言。函数式编程更关注结果，相对的命令式编程关注解决问题的步骤。使用函数式编程，代码会比较简洁，也容易被理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReactiveCocoa" scheme="http://yoursite.com/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程安全------nonatomic与野指针不得不说的故事</title>
    <link href="http://yoursite.com/2019/03/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-nonatomic%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://yoursite.com/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/</id>
    <published>2019-03-10T05:29:12.000Z</published>
    <updated>2019-03-10T05:30:57.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crash-操作系统的自我保护"><a href="#Crash-操作系统的自我保护" class="headerlink" title="Crash-操作系统的自我保护"></a>Crash-操作系统的自我保护</h3><p>当运行程序出现内存访问异常（访问野指针、数组越界）、内存不足（linux 下内存不足会出发oom_killer杀死当前进程）等异常情况，操作系统为自身的稳定运行会将异常程序KILL（Crash）掉以避免引起更大的问题。Crash是操作系统的一种自我保护机制，在程序Crash之前会收到操作系统发出的SIGSEGV、SIGKILL等信号。操作系统在发出这些指令之后会立即KILL掉异常应用程序。在日常的Crash清理中，通常会有茫茫多的SIGSEGV、SIGKILL Crash问题难以定位。</p><p>日常开发中另一类，难以定位的Crash将矛头指向了某些系统函数，如比较常见的objc_msgSend崩溃，我们将在 Foundation 与 UIKit 等的系统库中的方法称之为系统方法。作为一个乐观者，我们有理由相信系统方法和操作系统本身的稳定性。Crash的原因大概率（肯定）是我们自己代码出了问题，这些问题通常是由于欠妥的内存管理导致的。</p><a id="more"></a><h3 id="从一个-objc-msgSend-Crash开始"><a href="#从一个-objc-msgSend-Crash开始" class="headerlink" title="从一个 objc_msgSend Crash开始"></a>从一个 objc_msgSend Crash开始</h3><p>一起来看一个objc msgSend Crash的堆栈，该堆栈信息崩溃在了第6行,错误信息为:Thread 10:EXC BAD _ ACCESS( code =1,address=0x1a15cbeb8)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">libobjc.A.dylib`objc_msgSend:</span><br><span class="line">0x1903a01c0:  cmp    x0, #0</span><br><span class="line">0x1903a01c4:  b.le   0x1903a0230               ; objc_msgSend + 112</span><br><span class="line">0x1903a01c8:  ldr    x13, [x0, 0]</span><br><span class="line">0x1903a01cc:  and    x9, x13, #0x1fffffff8</span><br><span class="line">0x1903a01d0:  ldp    x10, x11, [x9, #16] // this line gives an error</span><br><span class="line">0x1903a01d4:  and    w12, w1, w11</span><br><span class="line">0x1903a01d8:  add    x12, x10, x12, lsl #</span><br></pre></td></tr></table></figure><p>可以肯定的是，问题绝不会是出现在objcmsgSend函数的实现上，objc msgSend可以说是OC的灵魂函数。如果这个函数存在漏洞那OC程序也就不太可能运行的起来了。关于objc msgSend这个函数，Apple已经提供了源码<a href="http://www.opensource.apple.com/source/objc4/objc4-647/runtime/Messengers.subproj/objc-msg-arm64.s" target="_blank" rel="noopener">arm64下的源码</a>，为了更高的效率objc msgSend是用汇编实现的。</p><p>结合objc_msgSend的源码我们可以分析以上崩溃信息每一行都做了啥：</p><ul><li><p>第二行 0x1903a01c0: cmp x0, #0</p><p>  检查iSA指针是否为nil或tagged pointer，arm64下苹果爸爸提出了提出了Tagged Pointer的概念，优化了NSNumber、NSDate存储和操作效率。简单来说就是Tagged Pointer对象的指针不再指向任何内存地址，而是被拆成两部分：一部分直接保存数据，另一部分作为特殊标记。所以这里需要对Tagged Pointer做判断。更多关于Tagged Pointer 猛戳深入理解Tagged Pointer</p></li><li><p>第三行 0x1903a01c4: b.le 0x1903a0230</p><p>  跳转操作，如果是tagged pointer 或 nil 跳转至0x1903a0230进行处理，我们这里显然不是程序会继续往下执行。</p></li><li><p>第四行 0x1903a01c8: ldr x13, [x0, 0]</p><p>  将对象的iSA指针，放入x13寄存器中。</p></li></ul><ul><li><p>第五行 0x1903a01cc: and x9, x13, #0x1fffffff8</p><p>  将类对象的真正指针存入x9寄存器，arm64下iSA指针除了存储类对象地址还存储了对象是否存在弱引用、是否正在销毁、对象的引用计数等信息，为取到真正的类对象地址，需将iSA指针同一个特定的立即数#0x1fffffff8进行AND操作</p></li><li><p>第六行 0x1903a01d0: ldp x10, x11, [x9, #16]</p><p>  将类对象存储的方法缓存列表的地址存入寄存器x10。在msgSend的过程中会先从类对象的mathod_cache_list中寻找相应的方法。（注意：程序在这里发生了Crash）。</p></li></ul><p>下图简单展示了上述汇编代码的调用过程：</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/msg_send_crash.png" alt=""></p><p>类对象的指针和方法缓存列表的偏移是一定的，假设我们拿到了正确的iSA指针，我们就可以通过这行代码得出正确的方法缓存列表的地址。在这里程序抛出了异常Crash掉了，那就可以肯定我们拿到了错误的iSA指针（野指针）。</p><p>通过分析，我们可以确定是我们程序内某些异常的内存操作导致了Crash，系统函数（objc_msgSend）却为我们背了锅。我们小心翼翼的使用weak、strong来管理内存，依旧无法避免内存问题，那么问题究竟出现在什么地方？</p><h3 id="危险的nonatomic"><a href="#危险的nonatomic" class="headerlink" title="危险的nonatomic"></a>危险的nonatomic</h3><p>在刚刚接触iOS开发的时候，我们被告知：系统会默认将属性声明为atomic，但atomic在保障get、set操作原子性的同时伤害了性能，所以我们要将属性声明为nonatomic。那么atomic到底在保护什么？里面又做了什么有害性能的操作？</p><h4 id="setter源码"><a href="#setter源码" class="headerlink" title="setter源码"></a>setter源码</h4><p>我们将目光汇集在runtime源码objc-accessors.mm文件的reallySetProperty函数中。通过阅读这个函数，可以很详细的了解到在atomic和nonatomic下不同的setter机制。为方便阅读，下述代码对reallySetProperty做了一定的简化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic)</span><br><span class="line">&#123;</span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;       </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，atomic 与 nonatomic 的差别在是否对 oldValue = slot; 与 slot = newValue; 两个赋值语句加了自旋锁。那么上面这两个问题的答案是显而易见的。atomic通过对写操作加入自旋锁保障了多线程情况下写操作的安全，同时导致了性能的损失。</p><h3 id="nonatomic可能产生的内存问题"><a href="#nonatomic可能产生的内存问题" class="headerlink" title="nonatomic可能产生的内存问题"></a>nonatomic可能产生的内存问题</h3><h4 id="多次release原始值"><a href="#多次release原始值" class="headerlink" title="多次release原始值"></a>多次release原始值</h4><p>下图展示了nonatomic下两个线程同时调用setter方法时的场景：</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/mutile_error_1.png" alt=""></p><p>很明显，如果不同时保证这两个赋值操作的原子性，必然有概率导致 *slot 中的原始值被 release 两次，而这样就会导致 Crash 的发生。因此，可以得出结论，多线程环境下对的nonatomic修饰的属性进行赋值操作有导致程序Crash的概率。</p><h4 id="错误release新创建的对象"><a href="#错误release新创建的对象" class="headerlink" title="错误release新创建的对象"></a>错误release新创建的对象</h4><p>仔细观察上图展示的问题，假设在thread 1释放obj1占用的内存后又立刻对其进行重新分配值newObj。此时，thread 2 的局部变量oldValue与newObj指向同一块内存空间。会有什么问题产生？wow！oldValue会对刚刚创建的newObj进行release操作！这就给程序带来了更大的不确定性，此时对于newObj的引用计数永远比指向newObj的强引用数少1。也就是在某些未知的情况下newObj就会被释放，导致内存错误。当然，也有可能导致上述的objc_msgSend问题。</p><p><img src="/2019/03/10/iOS多线程安全-nonatomic与野指针不得不说的故事/mutil_error_2.png" alt=""></p><h3 id="atomic-万能药？"><a href="#atomic-万能药？" class="headerlink" title="atomic 万能药？"></a>atomic 万能药？</h3><p>那么，atomic是解决多线程内存管理问题的万能药么？答案是否定的。一起来看以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic,strong)NSArray * array;  </span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 1</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (i % 2) &#123;</span><br><span class="line">               self.array = @[@1,@2,@3];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               self.array = @[@1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 2</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (self.array.count == 3) &#123;</span><br><span class="line">               NSLog(@&quot;obj At Inde 2:%@&quot;,[self.array objectAtIndex:2]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>即使我们将array的内存管理语义设为atomic，同时在访问objectAtIndex:之前加上判断，Thread 2还是会Crash。原因是由于前后两行代码之间array所指向的内存区域被线程1修改了。</p><p>atomic通过加锁确保了对于属性setter、getter操作的原子性。setter、getter操作的是属性的指针值，对于属性指针所指向的内存地址并不能起到保护作用。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>关于多线程下的内存管理还有很多东西要讲，比如：</p><ul><li>memory barrier</li><li>为何标量类型可以用assign</li><li>Atomic Operations</li><li>函数式编程中纯函数的概念</li></ul><p>To Be Continue…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Crash-操作系统的自我保护&quot;&gt;&lt;a href=&quot;#Crash-操作系统的自我保护&quot; class=&quot;headerlink&quot; title=&quot;Crash-操作系统的自我保护&quot;&gt;&lt;/a&gt;Crash-操作系统的自我保护&lt;/h3&gt;&lt;p&gt;当运行程序出现内存访问异常（访问野指针、数组越界）、内存不足（linux 下内存不足会出发oom_killer杀死当前进程）等异常情况，操作系统为自身的稳定运行会将异常程序KILL（Crash）掉以避免引起更大的问题。Crash是操作系统的一种自我保护机制，在程序Crash之前会收到操作系统发出的SIGSEGV、SIGKILL等信号。操作系统在发出这些指令之后会立即KILL掉异常应用程序。在日常的Crash清理中，通常会有茫茫多的SIGSEGV、SIGKILL Crash问题难以定位。&lt;/p&gt;
&lt;p&gt;日常开发中另一类，难以定位的Crash将矛头指向了某些系统函数，如比较常见的objc_msgSend崩溃，我们将在 Foundation 与 UIKit 等的系统库中的方法称之为系统方法。作为一个乐观者，我们有理由相信系统方法和操作系统本身的稳定性。Crash的原因大概率（肯定）是我们自己代码出了问题，这些问题通常是由于欠妥的内存管理导致的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程 内存管理" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程安全------多线程下的内存管理</title>
    <link href="http://yoursite.com/2019/03/10/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/03/10/iOS多线程安全-多线程下的内存管理/</id>
    <published>2019-03-10T05:27:52.000Z</published>
    <updated>2019-03-10T05:28:48.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在继续深入之前一起来考虑几个问题：</p><ul><li>64/32位操作系统，64/32指的是什么？</li><li>OC中标量类型属性修饰符为什么是assign？</li><li>i++是原子操作么？</li><li>atomic保障了什么？</li></ul><a id="more"></a><h3 id="CPU的寻址操作"><a href="#CPU的寻址操作" class="headerlink" title="CPU的寻址操作"></a>CPU的寻址操作</h3><p>我们知道，CPU是通过地址总线寻址，然后通过数据总线存取数据的。</p><h4 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h4><p>地址总线的位数决定CPU的寻址范围，若CPU的地址总线宽度是32位，那么CPU的寻址范围是4GB，所以最多支持4G内存。</p><h4 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h4><p>数据总线的位数决定CPU单次通信能交换的信息数量。若数据总线宽度是32位，那么单次交换的信息量为4字节，64位的8字节。这也是为什么C语言中的指针64位下所占空间为8字节，32位下所占空间为4字节。</p><p>我们通常说的64位处理器/32位处理器指的是数据总线的宽度为64位/32位。</p><h4 id="多线程下的寻址操作"><a href="#多线程下的寻址操作" class="headerlink" title="多线程下的寻址操作"></a>多线程下的寻址操作</h4><p>多线程下的内存管理是一个复杂的课题，在继续深入之前，关于CPU多线程下的寻址操作我们需要明确几点：</p><ul><li>地址总线、数据总线都只有一根，所以寻址是串行操作，不存在多个线程同时寻址同一个地址。</li><li>64位下，对于标量类型int、double单次寻址就可以取出，对其存取我们可以理解为原子操作，是多线程安全的。</li><li>32位下单次寻址只可取出4个字节，这种情况下double需要两次寻址才可取出。这种情况下不是线程安全的。</li></ul><h3 id="属性-amp-内存"><a href="#属性-amp-内存" class="headerlink" title="属性&amp;内存"></a>属性&amp;内存</h3><p>以下代码我们为一个SomeObj对象声明了若干属性，并在SomeObj的初始化方法内打印各个实例变量在内存中的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//属性声明</span><br><span class="line"></span><br><span class="line">@property(nonatomic,assign) int int_value;</span><br><span class="line">@property(nonatomic,assign) double double_value;</span><br><span class="line">@property(nonatomic,assign) Rect rect_value;</span><br><span class="line">@property(nonatomic,strong) id obj_Pointer;</span><br><span class="line">@property(nonatomic,assign) int int_value2;</span><br><span class="line"></span><br><span class="line">//init方法</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;address for int value:%p&quot;,&amp;_int_value);</span><br><span class="line">        NSLog(@&quot;address for int value2:%p&quot;,&amp;_int_value2);</span><br><span class="line">        NSLog(@&quot;address for double value:%p&quot;,&amp;_double_value);</span><br><span class="line">        NSLog(@&quot;address for rect value:%p&quot;,&amp;_rect_value);</span><br><span class="line">        NSLog(@&quot;address for pointer value:%p&quot;,&amp;_obj_Pointer);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们调用init方法，打印各个实例变量的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2018-03-25 16:51:09.284092+0800 MemoryTest[22641:3042100] address for int value:0x600000241598</span><br><span class="line">2018-03-25 16:51:09.284201+0800 MemoryTest[22641:3042100] address for int value2:0x60000024159c</span><br><span class="line">2018-03-25 16:51:09.284286+0800 MemoryTest[22641:3042100] address for double value:0x6000002415a0</span><br><span class="line">2018-03-25 16:51:09.284363+0800 MemoryTest[22641:3042100] address for rect value:0x6000002415a8</span><br><span class="line">2018-03-25 16:51:09.284439+0800 MemoryTest[22641:3042100] address for pointer value:0x6000002415b0</span><br></pre></td></tr></table></figure><p>可以看到，在初始化对象时编译器会在类的内存空间内自动分配实例变量的内存，这些内存会随着对象的销毁而释放。从这个角度看，指针类型和标量类型并没有区别（事实当然不是这样）。需要注意的是这里分配的是指针本身所占的8个字节而不是指针所指向的对象。</p><p>我们可以将内存中存储的数据类型大致分为标量类型、指针的值、指针所指向的内存空间三类，接下来将围绕这三种情况进行展开，一些特殊类型如tagged pointer这里就不做讨论。</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><p>结合上面提到的，我们可以得出以下结论：</p><ul><li>由于CPU单次寻址就可取出标量类型，对于标量类型的存取操作天然是原子的、线程安全的。</li><li>由于标量类型的存取操作天然是原子的，所以在未重写标量属性的getter/setter方法的情况下getter/setter方法也是原子的。</li><li>标量类型的内存会随着类对象的销毁而释放，这也是为何对于标量类型的属性可以用assign修饰的原因。</li></ul><p>那么标量类型的数据在多线程下就高枕无忧了么？举个栗子，编程中最基本的操作之一是递增整数。这是一项非常普遍的任务，可以用几个等效的操作完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_int_value = 3;</span><br><span class="line"></span><br><span class="line">//等效的三种方式</span><br><span class="line">_int_value++;</span><br><span class="line">_int_value+=1;</span><br><span class="line">_int_value = _int_value + 1;</span><br></pre></td></tr></table></figure><p>然而，看起来像一个操作 - 递增整型变量 - 实际上包含三个不同的步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Get _int_value (3)</span><br><span class="line">Perform Addition (3 + 1)</span><br><span class="line">Set _int_value (4)</span><br></pre></td></tr></table></figure><p>单线程下get-add-set这些操作是可以保障顺序执行的。在多线程情况下，就有可能产生线程安全问题。最经典的例子就是火车站多窗口售票系统，在操作余票的时候通过加锁保障线程安全。</p><h3 id="OSAtomic"><a href="#OSAtomic" class="headerlink" title="OSAtomic"></a>OSAtomic</h3><p>尽管，锁是同步两个线程的利器。不可否认的是，锁也是一种相对昂贵的操作。非阻塞性同步是解决多线程同步更优雅的方式。libkern/OSAtomic.h 提供了很多强大的多线程编程工具，虽然它是内核头文件的一部分，但它也可以用于内核和驱动程序编程之外。</p><p>我们将上例中提到的“_int_value++”以Atomic Operations改写后，该操作就是原子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSAtomicIncrement64(&amp;(_int_value));</span><br></pre></td></tr></table></figure><p>事实上，真正的情况还要更复杂：为了提高性能，现代CPU/编译器会按照输入数据和执行单元的可用性的顺序执行指令而不是程序中的原始顺序执行（乱序执行）。</p><h3 id="乱序执行-amp-内存屏障"><a href="#乱序执行-amp-内存屏障" class="headerlink" title="乱序执行 &amp; 内存屏障"></a>乱序执行 &amp; 内存屏障</h3><p>程序是工作在OS/编译器/物理硬件共同营造的虚拟环境中的。程序运行环境有一定的规则以确保程序稳定运行，不同的OS/编译器/CPU有各种不同的实现方式但是规则本身是不变的。</p><p>编译器和CPU在满足前面的规则的时候，总是玩各种小九九，在满足前面”承诺“的规则的前提下，（非有意地）破坏没有承诺的规则。</p><p>CPU：每个CPU都有自己的缓存，为提高数据读写速度，CPU会同自己的缓存交换数据而不是直接读写内存。<br>编译器：为充分利用寄存器和CPU流水线编译器可能会重排指令顺序。</p><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">c=a+b;</span><br><span class="line">printf(&quot;a=%d, b=%d, c=%d\n&quot;, a, b, c);</span><br></pre></td></tr></table></figure><p>上面这个程序序列，作用于程序运行环境的时候，环境规则能承诺的是计算c的时候，a肯定等于1，b肯定等于2。最后打印的时候，c肯定等于3。</p><p>但它没有承诺的是：</p><ul><li>a，b，c是内存上的地址（也可以是寄存器一类的东西）</li><li>a首先变成1，然后b才变成2</li><li>如果其他设备或者CPU修改这些内存地址，反应是什么</li><li>等等</li></ul><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>我们可以通过设置内存屏障来避免CPU/编译器类似的优化，内存屏障可以有两个作用：</p><ul><li>阻止屏障两侧的指令重排。</li><li>强制CPU直接读取内存（volatile）</li></ul><p>上述的libkern/OSAtomic.h同样提供了内存屏障版本的API：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSAtomicIncrement64Barrier(&amp;(_int_value));</span><br></pre></td></tr></table></figure><p>对于Objective C的实现来说，几乎所有的加锁操作最后都会设置memory barrier。官方文档表述如下：</p><blockquote><p>Note: Most types of locks also incorporate a memory barrier to ensure that any preceding load and store instructions are completed before entering the critical section.</p></blockquote><p>GCD中有一个队列屏障的概念，dispatch_barrier_async()，可以轻易的实现安全的可变数组、可变字典（读写锁）。</p><h3 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h3><h4 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h4><p>以C语言来说，32位操作系统下指针的大小为4字节，64位操作下指针的大小为8字节。根据上面的理论，CPU单次寻址可以取出指针，所以指针的存取操作时原子的、线程安全的。</p><h4 id="OC指针"><a href="#OC指针" class="headerlink" title="OC指针"></a>OC指针</h4><p>那么以OC为例呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSObject* obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure><p>事实上，答案是否定的，或者说从ARC的角度来看答案是否定的。仅仅从指针赋值的角度来看上述操作的确是原子的，但是为支持ARC上述赋值操作会调用在runtime中引入相应的副作用操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">objc_storeStrong(id *location, id obj)</span><br><span class="line">&#123;</span><br><span class="line">    id prev = *location;</span><br><span class="line">    if (obj == prev) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑：A、B、C三个线程几乎同时对obj进行赋值操作，可能会有什么问题？可能会对同一“prev”调用多次objc_release(prev);从而导致Crash。一个比较类似的Crash是（可能不那么类似）：如果多个线程同时设置UIImageView的image，很可能应用程序会崩溃，因为当前设置的图像可能会被释放两次。</p><p>同样的对于weak类型指针会调用相应的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_storeWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    return storeWeak&lt;DoHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object *)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>显然OC中ARC下的指针赋值操作是非原子的。而OC也提供了atomic关键字来保障属性getter/setter操作的“原子性”，调用getter/setter方法同样会调用到runtime的相应方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    if (offset == 0) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((char*)self + offset);</span><br><span class="line"></span><br><span class="line">    if (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; else if (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (*slot == newValue) return;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到atomic 并没有真正保障getter/setter的原子性，而是通过加锁保障了不会对同一个oldValue 调用多次objc_release(oldValue);操作，从而保障了线程安全，同时也导致了性能的损耗。</p><h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h3><p>那么，atomic是解决多线程内存管理问题的万能药么？答案是否定的。一起来看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic,strong)NSArray * array;  </span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 1</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (i % 2) &#123;</span><br><span class="line">               self.array = @[@1,@2,@3];</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               self.array = @[@1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">       //Thread 2</span><br><span class="line">       for (int i = 0; i &lt; 10000; i ++) &#123;</span><br><span class="line">           if (self.array.count == 3) &#123;</span><br><span class="line">               NSLog(@&quot;obj At Inde 2:%@&quot;,[self.array objectAtIndex:2]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>即使我们将array的内存管理语义设为atomic，同时在访问objectAtIndex:之前加上判断，Thread 2还是会Crash。原因是由于前后两行代码之间array所指向的内存区域被线程1修改了。</p><p>atomic通过加锁确保了对于属性setter、getter访问的线程安全问题。setter、getter操作的是属性的指针值，对于属性指针所指向的内存地址并不能起到保护作用。</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>多线程是一个复杂的课题，从pThread、NSThread、GCD、NSOperation，API的选择、优劣到多线程开发面临的挑战竞态条件、死锁、线程饥饿、优先级反转，再到如何编写性能优异安全的多线程代码。</p><p>To be continue…</p><p>=</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;在继续深入之前一起来考虑几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;64/32位操作系统，64/32指的是什么？&lt;/li&gt;
&lt;li&gt;OC中标量类型属性修饰符为什么是assign？&lt;/li&gt;
&lt;li&gt;i++是原子操作么？&lt;/li&gt;
&lt;li&gt;atomic保障了什么？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="多线程 内存管理" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>源码解析------TMCache</title>
    <link href="http://yoursite.com/2019/03/10/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-TMCache/"/>
    <id>http://yoursite.com/2019/03/10/源码解析-TMCache/</id>
    <published>2019-03-10T05:25:32.000Z</published>
    <updated>2019-03-10T05:26:57.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码解析——TMCache"><a href="#源码解析——TMCache" class="headerlink" title="源码解析——TMCache"></a>源码解析——TMCache</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文为阅读TMCache源码后所产，TMCache由著名网站tumblr开发虽然目前已停止维护，源码中还是有很多值得借鉴的点。客户端缓存从硬件介质上来看，无非就是内存和磁盘两种。在TMCache中分别对应TMMemoryCache（内存级别缓存）、TMDiskCache（磁盘级别缓存）。通常来讲磁盘缓存由于涉及磁盘IO、文件编解码较内存缓存而言会更复杂一些。本文中笔者将循着TMCache的实现分析TMMemoryCache、TMDiskCache源码中一些平时开发中值得借鉴的点(红榜)及一些需要避免的点（黑榜）。</p><p>PS：为方便阅读、聚焦本文讨论的key点，本文中对所引入的TMCache源码进行不同程度的精简。</p><a id="more"></a><h3 id="TMMemoryCache"><a href="#TMMemoryCache" class="headerlink" title="TMMemoryCache"></a>TMMemoryCache</h3><p>TMMemoryCache提供了线程安全的同步/异步读写内存的API。对于内存缓存而言并行读、串行写是刚需（即读写锁），TMMemoryCache对于读写线程安全访问控制及异步转同步的实现值得借鉴。</p><h4 id="TMMemoryCache红榜之读写锁实现"><a href="#TMMemoryCache红榜之读写锁实现" class="headerlink" title="TMMemoryCache红榜之读写锁实现"></a>TMMemoryCache红榜之读写锁实现</h4><p>TMMemoryCache通过GCD并发队列及 <a href="https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async" target="_blank" rel="noopener">dispatch_barrier_async()</a>实现并发读、串行写的线程安全访问。</p><h5 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h5><p>一个比较关键的概念是：dispatch_barrier_async(),dispatch_barrier_async()是GCD提供的类似“内存屏障”的“队列屏障”。dispatch_barrier_async()在GCD并发队列的任务调度中起到一个栅栏的作用，dispatch_barrier_async()提交到队列里的任务会等待之前的任务执行完毕，再开始执行。且dispatch_barrier_async()提交到队列里的任务执行完毕后才会执行之后之后提交到队列里的任务。一图以蔽之：</p><p><img src="/2019/03/10/源码解析-TMCache/barrier_async.png" alt=""></p><p>TMMemoryCache中读写操作都是在一个 concurrent queue(并发队列)中, 通过 dispatch_barrier_async() 保障在同一时间只有一个写任务在执行, 其它读写操作都处于等待状态, 这是 TMMemoryCache 保证线程安全的核心。</p><h5 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h5><p>一起来看一下简化后的源码：</p><h6 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)objectForKey:(NSString *)key block:(TMMemoryCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMMemoryCache *weakSelf = self;</span><br><span class="line">    dispatch_async(_queue, ^&#123;</span><br><span class="line">        TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        id object = [strongSelf-&gt;_dictionary objectForKey:key];</span><br><span class="line"></span><br><span class="line">        block(strongSelf, key, object);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost block:(TMMemoryCacheObjectBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMMemoryCache *weakSelf = self;</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line"></span><br><span class="line">        TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        [strongSelf-&gt;_dictionary setObject:object forKey:key];</span><br><span class="line"></span><br><span class="line">        if (block) &#123;</span><br><span class="line">            __weak TMMemoryCache *weakSelf = strongSelf;</span><br><span class="line">            dispatch_async(strongSelf-&gt;_queue, ^&#123;</span><br><span class="line">                TMMemoryCache *strongSelf = weakSelf;</span><br><span class="line">                if (strongSelf)</span><br><span class="line">                    block(strongSelf, key, object);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMMemoryCache红榜之异步转同步实现"><a href="#TMMemoryCache红榜之异步转同步实现" class="headerlink" title="TMMemoryCache红榜之异步转同步实现"></a>TMMemoryCache红榜之异步转同步实现</h4><p>TMMemoryCache的同步方法是通过在调用异步方法的过程中插入dispatch_semaphore_t信号量实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)setObject:(id)object forKey:(NSString *)key withCost:(NSUInteger)cost</span><br><span class="line">&#123;</span><br><span class="line">    if (!object || !key)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">    [self setObject:object forKey:key withCost:cost block:^(TMMemoryCache *cache, NSString *key, id object) &#123;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    #if !OS_OBJECT_USE_OBJC</span><br><span class="line">    dispatch_release(semaphore);</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMMemoryCache黑榜之线程爆炸"><a href="#TMMemoryCache黑榜之线程爆炸" class="headerlink" title="TMMemoryCache黑榜之线程爆炸"></a>TMMemoryCache黑榜之线程爆炸</h4><p>在实际使用过程中，通过GCD Barrier来保证读写同步在一定程度上是可行的，但在并发量很大的情况，会造成线程爆炸，严重情况下会因为线程资源消耗而导致死锁。一起来看一个例子，我们通过以下代码来模拟通过TMMemoryCache高并发下读写缓存的case：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define TIMES 1000000</span><br><span class="line"></span><br><span class="line">dispatch_queue_t testQueue = dispatch_queue_create([@&quot;com.tmcache.test&quot; UTF8String], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">for (NSInteger index = 0; index &lt; TIMES; ++index) &#123;</span><br><span class="line">    if (index % 10 == 9) &#123;</span><br><span class="line">        dispatch_async(testQueue, ^&#123;</span><br><span class="line">            [[TMMemoryCache sharedCache] setObject:@(index) forKey:[@(index) stringValue] block:^(TMMemoryCache *cache, NSString *key, id object) &#123;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        dispatch_async(testQueue, ^&#123;</span><br><span class="line">            [[TMMemoryCache sharedCache] objectForKey:[@(index) stringValue]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过断点看一下执行过程中的线程状况：</p><p><img src="/2019/03/10/源码解析-TMCache/thread_baozha.png" alt=""></p><p>其实在当前case下已经产生死锁了。</p><p>这是由于GCD的特性导致的。GCD创建了一个大致与内核数量相匹配的线程池，如果我们向GCD提交了一个任务，并且该任务阻塞了该线程。为了弥补线程被阻塞的损失，GCD会创建一个新的线程并将其添加到线程池中，这就是线程爆炸的根本原因。同时，由于线程并不是免费资源，每一个线程都需要固定的内存（用于存储线程局部信息函数调用栈等）和内核（用于线程调度）资源，大量分配线程会导致内核资源耗尽导致死锁。</p><p>这也是平时开发中需要注意的点：对于高并发下的读写操作应避免使用GCD Barrier，可以通过封装NSLock实现一个自定义的读写锁。</p><h3 id="TMDiskCache"><a href="#TMDiskCache" class="headerlink" title="TMDiskCache"></a>TMDiskCache</h3><p>TMDiskCache的实现形式是基于文件读写的。TMDiskCache同样提供了线程安全的同步/异步读写磁盘的API。其异步转同步思路与TMMemoryCache一致这里不再赘述。关于TMDiskCache我们关注的重点不再是线程安全（TMDiskCache所有的读写操作都在一个 serial queue 串行队列中, 不存在竞态情况,），而作者根据磁盘缓存的特性对于API的选择很有借鉴意义。</p><h4 id="TMDiskCache红榜之serial-queue"><a href="#TMDiskCache红榜之serial-queue" class="headerlink" title="TMDiskCache红榜之serial queue"></a>TMDiskCache红榜之serial queue</h4><p>不同于TMMemoryCache，TMCache的作者将TMDiskCache的读写操作放在了一个 serial queue。这是由于磁盘存取的速度瓶颈在磁盘IO上，和是否多线程存取没有太大关系。磁盘IO是一个很复杂的课题，这里只列出几点关于TMCache作者选用serial queue的猜想，不做展开讨论。</p><h5 id="磁盘IO调度层本身就是串行"><a href="#磁盘IO调度层本身就是串行" class="headerlink" title="磁盘IO调度层本身就是串行"></a>磁盘IO调度层本身就是串行</h5><p>调用上层API产生的磁盘IO请求会被放到IO调度层，在IO调度层会缓存请求并试图合并请求，最终内核根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I/O请求。而磁盘I/O调度层本身的调度策略就是串行的，这主要是由于目前计算机体系结构下磁盘是不支持多磁头同时读写的。</p><h5 id="磁盘Cache层提供了足够的优化"><a href="#磁盘Cache层提供了足够的优化" class="headerlink" title="磁盘Cache层提供了足够的优化"></a>磁盘Cache层提供了足够的优化</h5><p>磁盘Cache层在内存中缓存了磁盘上的部分数据。当数据请求到达时，如果Cache存在数据且是最新的，则将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。</p><p>磁盘Cache有两大功能：预读和回写。</p><h6 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h6><p>预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读的页面中，这时继续进行异步预读；第二种情况是所请求的页面处于预读页面之外，这时系统就要进行同步预读。</p><h6 id="回写"><a href="#回写" class="headerlink" title="回写"></a>回写</h6><p>回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。通过这种异步的数据I/O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，减少了访问底层存储介质的次数，使存储系统的性能大大提高。</p><h5 id="多线程下的磁盘I-0"><a href="#多线程下的磁盘I-0" class="headerlink" title="多线程下的磁盘I/0"></a>多线程下的磁盘I/0</h5><p>有了这些基础我们再来分别看一下多个线程调用读和写分别会发生什么。</p><h6 id="多个线程同时读"><a href="#多个线程同时读" class="headerlink" title="多个线程同时读"></a>多个线程同时读</h6><p>在未命中磁盘Cache的情况下，会提交多个I/O任务到磁盘I/O调度层。可能依靠IO调度层本身的调度算法及对于同一文件I/O请求的合并带来效率上的些许提升。但是比起CPU消耗及多个线程上下文切换其意义并不是很大。而且对于同一文件I/O请求在串行发起多次的情况下，除第一次I/O请求会读磁盘外其余都会命中磁盘Cache，所以I/O调度层对于同一文件I/O请求的合并不会带来实际的意义。</p><h6 id="多个线程同时写"><a href="#多个线程同时写" class="headerlink" title="多个线程同时写"></a>多个线程同时写</h6><p>根据磁盘Cache的回写功能，不难看出多线程同时写只是更快的填满了写缓冲区，并不会带来实际意义上的效率提升。</p><h4 id="TMDiskCache红榜之文件删除"><a href="#TMDiskCache红榜之文件删除" class="headerlink" title="TMDiskCache红榜之文件删除"></a>TMDiskCache红榜之文件删除</h4><p>关于文件删除TMDiskCache的实现方案是将待删除文件移至tmp文件夹，然后将具体的删除任务丢到优先级最低的DISPATCH_QUEUE_PRIORITY_BACKGROUND去做。这样只有在程序真正空闲时才会处理具体删除操作。如果程序最终都没有处理删除操作在程序，在程序结束后系统会自动删除tmp文件夹内的文件。一起来看一下相关源码吧：</p><h5 id="文件删除源码"><a href="#文件删除源码" class="headerlink" title="文件删除源码"></a>文件删除源码</h5><p>共享的文件删除队列（DISPATCH_QUEUE_PRIORITY_BACKGROUND优先级）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (dispatch_queue_t)sharedTrashQueue</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_queue_t trashQueue;</span><br><span class="line">    static dispatch_once_t predicate;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">        NSString *queueName = [[NSString alloc] initWithFormat:@&quot;%@.trash&quot;, TMDiskCachePrefix];</span><br><span class="line">        trashQueue = dispatch_queue_create([queueName UTF8String], DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        dispatch_set_target_queue(trashQueue, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0));</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return trashQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享的存放删除文件的tmp文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURL *)sharedTrashURL</span><br><span class="line">&#123;</span><br><span class="line">    static NSURL *sharedTrashURL;</span><br><span class="line">    static dispatch_once_t predicate;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">        //临时文件夹</span><br><span class="line">        sharedTrashURL = [[[NSURL alloc] initFileURLWithPath:NSTemporaryDirectory()] URLByAppendingPathComponent:TMDiskCachePrefix isDirectory:YES];</span><br><span class="line">        </span><br><span class="line">        if (![[NSFileManager defaultManager] fileExistsAtPath:[sharedTrashURL path]]) &#123;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            [[NSFileManager defaultManager] createDirectoryAtURL:sharedTrashURL</span><br><span class="line">                                     withIntermediateDirectories:YES</span><br><span class="line">                                                      attributes:nil</span><br><span class="line">                                                           error:&amp;error];</span><br><span class="line">            TMDiskCacheError(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return sharedTrashURL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>待删除文件移动至tmp文件夹，这里另外一个点是通过调用[[NSProcessInfo processInfo] globallyUniqueString]生成了一个临时文件名，该方法会确保每次“调用”会不一样，所以不会产生相同的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+(BOOL)moveItemAtURLToTrash:(NSURL *)itemURL</span><br><span class="line">&#123;</span><br><span class="line">    if (![[NSFileManager defaultManager] fileExistsAtPath:[itemURL path]])</span><br><span class="line">        return NO;</span><br><span class="line">    </span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSString *uniqueString = [[NSProcessInfo processInfo] globallyUniqueString]; //每次&quot;调用&quot;会不一样，可以用作一些临时缓存文件的名字</span><br><span class="line">    NSURL *uniqueTrashURL = [[TMDiskCache sharedTrashURL] URLByAppendingPathComponent:uniqueString];</span><br><span class="line">    BOOL moved = [[NSFileManager defaultManager] moveItemAtURL:itemURL toURL:uniqueTrashURL error:&amp;error];</span><br><span class="line">    TMDiskCacheError(error);</span><br><span class="line">    return moved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空操作，遍历并删除tmp文件夹下所有文件，该任务被丢到DISPATCH_QUEUE_PRIORITY_BACKGROUND优先级队列中执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (void)emptyTrash</span><br><span class="line">&#123;</span><br><span class="line">    UIBackgroundTaskIdentifier taskID = [TMCacheBackgroundTaskManager beginBackgroundTask];</span><br><span class="line">    </span><br><span class="line">    dispatch_async([self sharedTrashQueue], ^&#123;        </span><br><span class="line">        NSError *error = nil;</span><br><span class="line">        NSArray *trashedItems = [[NSFileManager defaultManager] contentsOfDirectoryAtURL:[self sharedTrashURL]</span><br><span class="line">                                                              includingPropertiesForKeys:nil</span><br><span class="line">                                                                                 options:0</span><br><span class="line">                                                                                   error:&amp;error];</span><br><span class="line">        TMDiskCacheError(error);</span><br><span class="line"></span><br><span class="line">        for (NSURL *trashedItemURL in trashedItems) &#123;</span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            [[NSFileManager defaultManager] removeItemAtURL:trashedItemURL error:&amp;error];</span><br><span class="line">            TMDiskCacheError(error);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [TMCacheBackgroundTaskManager endBackgroundTask:taskID];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TMDiskCache黑榜之不当API使用"><a href="#TMDiskCache黑榜之不当API使用" class="headerlink" title="TMDiskCache黑榜之不当API使用"></a>TMDiskCache黑榜之不当API使用</h4><p>一起来看TMDiskCache中以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAgeLimit:(NSTimeInterval)ageLimit</span><br><span class="line">&#123;</span><br><span class="line">    __weak TMDiskCache *weakSelf = self;</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(_queue, ^&#123;</span><br><span class="line">        TMDiskCache *strongSelf = weakSelf;</span><br><span class="line">        if (!strongSelf)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        strongSelf-&gt;_ageLimit = ageLimit;</span><br><span class="line">        </span><br><span class="line">        [strongSelf trimToAgeLimitRecursively];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意两点：</p><ol><li>_queue 为串行队列</li><li>使用了dispatch_barrier_async()栅栏函数</li></ol><p>所以上面的代码是在串行队列中使用了栅栏函数？？难道串行队列不是保障了任务按入队顺序依次执行且上一个执行完毕才会执行下一个？？关于<a href="https://developer.apple.com/documentation/dispatch/1452797-dispatch_barrier_async" target="_blank" rel="noopener">dispatch_barrier_async()</a>一起来看一下苹果爸爸怎么说：</p><blockquote><p>The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_async function.</p></blockquote><p>如果我们传入非自定义队列或串行队列那使用dispatch_barrier_async()函数就等于是在用 dispatch_async()。滥用API有木有，虽然不会产生性能、质量上的影响但的确是一个槽点。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;源码解析——TMCache&quot;&gt;&lt;a href=&quot;#源码解析——TMCache&quot; class=&quot;headerlink&quot; title=&quot;源码解析——TMCache&quot;&gt;&lt;/a&gt;源码解析——TMCache&lt;/h2&gt;&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本文为阅读TMCache源码后所产，TMCache由著名网站tumblr开发虽然目前已停止维护，源码中还是有很多值得借鉴的点。客户端缓存从硬件介质上来看，无非就是内存和磁盘两种。在TMCache中分别对应TMMemoryCache（内存级别缓存）、TMDiskCache（磁盘级别缓存）。通常来讲磁盘缓存由于涉及磁盘IO、文件编解码较内存缓存而言会更复杂一些。本文中笔者将循着TMCache的实现分析TMMemoryCache、TMDiskCache源码中一些平时开发中值得借鉴的点(红榜)及一些需要避免的点（黑榜）。&lt;/p&gt;
&lt;p&gt;PS：为方便阅读、聚焦本文讨论的key点，本文中对所引入的TMCache源码进行不同程度的精简。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码解析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>性能调优------卡顿监控</title>
    <link href="http://yoursite.com/2019/03/10/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/03/10/性能调优-卡顿监控/</id>
    <published>2019-03-10T05:23:22.000Z</published>
    <updated>2019-03-10T05:24:07.630Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本文将循着<a href="https://cloud.tencent.com/developer/article/1030608" target="_blank" rel="noopener">微信iOS卡顿监控系统</a>的思路：起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来。做一个简单的deom，体验一把。</p><a id="more"></a><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>废话少说，直接撸代码。首先创建一个NSThread的子类BWKPingThread。</p><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>一个简单的初始化方法，入参为卡顿监测的时间阈值，超过该阈值即上报卡顿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithThreshold:(NSInteger)threshold;</span><br></pre></td></tr></table></figure><h3 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h3><h4 id="类拓展"><a href="#类拓展" class="headerlink" title="类拓展"></a>类拓展</h4><p>在类拓展中声明三个属性：</p><ul><li>threshold：存储卡端监测时间阈值</li><li>pingSemaphore：用于卡端监控的信号量</li><li>runloopObserver：用于监控主线程runloop的observer</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface BWKPingThread()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) NSInteger threshold;</span><br><span class="line">@property (nonatomic, strong) dispatch_semaphore_t pingSemaphore;</span><br><span class="line">@property (nonatomic, assign) CFRunLoopObserverRef runloopObserver;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="init方法-amp-addRunloopObserver方法"><a href="#init方法-amp-addRunloopObserver方法" class="headerlink" title="init方法 &amp; addRunloopObserver方法"></a>init方法 &amp; addRunloopObserver方法</h4><p>初始化工作，添加observer观测主线程runloop，在没一个runloop回调中调用dispatch_semaphore_signal()自增信号量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithThreshold:(NSInteger)threshold&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _threshold = threshold;</span><br><span class="line">        _pingSemaphore = dispatch_semaphore_create(0);</span><br><span class="line">        [self addRunloopObserver];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addRunloopObserver</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    CFRunLoopActivity observedActivities = kCFRunLoopBeforeSources | kCFRunLoopBeforeWaiting | kCFRunLoopAfterWaiting;</span><br><span class="line">    _runloopObserver = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, observedActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        __strong __typeof(self) strongSelf = weakSelf;</span><br><span class="line">        if (strongSelf.pingSemaphore != NULL) &#123;</span><br><span class="line">            dispatch_semaphore_signal(strongSelf.pingSemaphore);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), _runloopObserver, kCFRunLoopCommonModes);</span><br><span class="line">    CFRelease(_runloopObserver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>重写NSThread的main方法，调用dispatch_semaphore_wait()等待信号量的释放，如果等待时间超过阈值，则监测到主线程阻塞、上报卡顿。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">    while (!self.cancelled) &#123;</span><br><span class="line">        long status = dispatch_semaphore_wait(self.pingSemaphore, dispatch_time(DISPATCH_TIME_NOW, self.threshold * NSEC_PER_MSEC));</span><br><span class="line">        if (status != 0) &#123;</span><br><span class="line">            NSLog(@&quot;The main thread is blocked.&quot;);</span><br><span class="line">            dispatch_semaphore_wait(self.pingSemaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><p>重写cancel方法，移除observer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel</span><br><span class="line">&#123;</span><br><span class="line">    [super cancel];</span><br><span class="line">    dispatch_semaphore_signal(self.pingSemaphore);</span><br><span class="line">    if (self.runloopObserver) &#123;</span><br><span class="line">        CFRunLoopObserverInvalidate(self.runloopObserver);</span><br><span class="line">        self.runloopObserver = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><p>我们在主线程中创建pingThread，并通过模拟耗时操作阻塞主线程以测试卡顿监测。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BWKPingThread * pingThread = [[BWKPingThread alloc] initWithThreshold:1];</span><br><span class="line"></span><br><span class="line">[pingThread start];</span><br><span class="line"></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    //耗时操作</span><br><span class="line">    for (int  i = 0; i &lt; 100000000; i ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过控制台log可以看到成功监测到卡顿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-04-21 21:20:20.309915+0800 Ping_Demo[98239:5860372] The main thread is blocked.</span><br></pre></td></tr></table></figure><h3 id="卡顿堆栈？"><a href="#卡顿堆栈？" class="headerlink" title="卡顿堆栈？"></a>卡顿堆栈？</h3><p>这里推荐一个三方库<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>。通过plcrashreporter可以拿到所有线程堆栈，国内很多Crash上报平台都是通过plcrashreporter实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;本文将循着&lt;a href=&quot;https://cloud.tencent.com/developer/article/1030608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;微信iOS卡顿监控系统&lt;/a&gt;的思路：起一个子线程，监控主线程的活动情况，如果发现有卡顿，就将堆栈 dump 下来。做一个简单的deom，体验一把。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能调优" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------Priority_Queue实现</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Priority-Queue%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Priority-Queue实现/</id>
    <published>2019-03-10T05:21:18.000Z</published>
    <updated>2019-03-10T05:22:54.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法设计——Priority-Queue实现"><a href="#算法设计——Priority-Queue实现" class="headerlink" title="算法设计——Priority_Queue实现"></a>算法设计——Priority_Queue实现</h2><h3 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h3><blockquote><p>普通队列是一种先进先出（FIFO）的数据结构。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高优先先出（first in，lagest out）的行为特征。</p></blockquote><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>使用排序和数组可以简单的实现Priority Queue，插入到列表的时间复杂度为𝑂（𝑛），排序列表的时间复杂度为𝑂(𝑛log𝑛)。更优的方式是使用大顶堆（小顶堆），以大顶堆（小顶堆）实现的Priority Queue的出队、入队时间复杂度均为𝑂(log 𝑛)。</p><a id="more"></a><h3 id="二进制堆"><a href="#二进制堆" class="headerlink" title="二进制堆"></a>二进制堆</h3><blockquote><ol><li>堆中某个节点的值总是不大于或不小于其父节点的值（分别为大顶堆和小顶堆）。</li><li>堆是一颗完全二叉树。</li></ol></blockquote><p>从二叉树角度来看大顶堆：</p><p><img src="/2019/03/10/算法设计-Priority-Queue实现/heap.png" alt=""></p><p>以数组存储该大顶堆：</p><p><img src="/2019/03/10/算法设计-Priority-Queue实现/array.png" alt=""></p><p>子节点与父节点的关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p_left = p * 2;</span><br><span class="line">p_right = p * 2 + 1;</span><br></pre></td></tr></table></figure><h3 id="调整堆（出队、入队操作）"><a href="#调整堆（出队、入队操作）" class="headerlink" title="调整堆（出队、入队操作）"></a>调整堆（出队、入队操作）</h3><h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ol><li>新元素插在树的末尾，如果树的最后一层已满，添加一层。</li><li>如果插入元素打破大顶堆（小顶堆）的结构，与其父节点交换。</li><li>重复第二步直至满足大顶堆（小顶堆）的结构。</li></ol><p>入队时间复杂度： 𝑂(log 𝑛)</p><h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><ol><li>交换根节点元素与最后一个元素，删除根节点元素（现在是最后一个元素）。</li><li>如果交换后的根节点打破大顶堆的结构，与其较大的孩子节点交换。</li><li>重复第二部直至满足大顶堆结构。</li></ol><p>出队时间复杂度：𝑂(log 𝑛)</p><h3 id="堆调整的可视化演示"><a href="#堆调整的可视化演示" class="headerlink" title="堆调整的可视化演示"></a>堆调整的可视化演示</h3><p><a href="https://visualgo.net/en/heap?slide=1" target="_blank" rel="noopener">堆 可视化演示</a></p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><h4 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;stdbool.h&quot;</span><br><span class="line"></span><br><span class="line">typedef struct priority_Queue_Node&#123;</span><br><span class="line">    int priority;//优先级</span><br><span class="line">    int member;//数据域</span><br><span class="line">&#125;Priority_Queue_Node, * p_Priority_Node;</span><br><span class="line"></span><br><span class="line">typedef struct priority_Queue&#123;</span><br><span class="line">    Priority_Queue_Node * nodeList;</span><br><span class="line">    int length;//已分配内存长度</span><br><span class="line">    int contentLength;//当前内容长度</span><br><span class="line">&#125;Priority_Queue, * p_Priority_Queue;</span><br><span class="line"></span><br><span class="line">void InitPriorityQueue(p_Priority_Queue queue, int n);//初始化</span><br><span class="line">bool Insert(p_Priority_Queue queue, int member,int priority);//入队</span><br><span class="line">bool Empty(p_Priority_Queue queue);//判空</span><br><span class="line">int RemoveTop(p_Priority_Queue queue);//出队</span><br><span class="line">void travelPriorityQueue(p_Priority_Queue queue);//遍历</span><br></pre></td></tr></table></figure><h4 id="c文件"><a href="#c文件" class="headerlink" title=".c文件"></a>.c文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Priority_Queue.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">void adjustAfterInsert(p_Priority_Queue queue);</span><br><span class="line">void adjustAfterRemove(p_Priority_Queue queue);</span><br><span class="line">void swap(p_Priority_Node node1,p_Priority_Node node2);</span><br><span class="line"></span><br><span class="line">void InitPriorityQueue(p_Priority_Queue queue, int n)&#123;</span><br><span class="line">    Priority_Queue_Node * nodeList = malloc(sizeof(Priority_Queue_Node) * 2);</span><br><span class="line">    if (nodeList == NULL) &#123;</span><br><span class="line">        printf(&quot;分配内存失败&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    queue -&gt; nodeList = nodeList;</span><br><span class="line">    queue -&gt; length = n;</span><br><span class="line">    queue -&gt; contentLength = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool CheckPriority(p_Priority_Queue queue, int priority)&#123;</span><br><span class="line">    int position = 0;</span><br><span class="line">    bool legal = true;</span><br><span class="line">    while (position &lt; queue -&gt; contentLength) &#123;</span><br><span class="line">        if ((queue -&gt; nodeList + position) -&gt; priority == priority ) &#123;</span><br><span class="line">            printf(&quot;非法优先级&quot;);</span><br><span class="line">            legal = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        position ++;</span><br><span class="line">    &#125;</span><br><span class="line">    return legal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Insert(p_Priority_Queue queue, int member,int priority)&#123;</span><br><span class="line">    if (!CheckPriority(queue, priority)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (queue -&gt; length == queue -&gt; contentLength) &#123;</span><br><span class="line">        queue -&gt; length *= 2;</span><br><span class="line">        queue -&gt; nodeList = realloc(queue -&gt; nodeList, sizeof(Priority_Queue_Node) * queue -&gt; length);</span><br><span class="line">        if (NULL == queue -&gt; nodeList) &#123;</span><br><span class="line">            printf(&quot;分配内存失败&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    int contentLength = queue -&gt; contentLength;</span><br><span class="line">    p_Priority_Node node = queue -&gt; nodeList + contentLength;</span><br><span class="line">    node -&gt; member = member;</span><br><span class="line">    node -&gt; priority = priority;</span><br><span class="line">    queue -&gt; contentLength += 1;</span><br><span class="line">    adjustAfterInsert(queue);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Insert %d with pri %d\n&quot;,member,priority);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int RemoveTop(p_Priority_Queue queue)&#123;</span><br><span class="line"></span><br><span class="line">    int return_val;</span><br><span class="line">    if (Empty(queue)) &#123;</span><br><span class="line">        printf(&quot;Queue is empty&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">        p_Priority_Node pNode = queue -&gt; nodeList;</span><br><span class="line">        return_val = pNode -&gt; member;</span><br><span class="line">        swap(&amp;(queue -&gt; nodeList)[0], &amp;(queue -&gt; nodeList)[queue -&gt; contentLength - 1]);</span><br><span class="line">        queue -&gt; contentLength -= 1;</span><br><span class="line">        adjustAfterRemove(queue);</span><br><span class="line">        printf(&quot;removeValue %d\n&quot;,return_val);</span><br><span class="line">        return return_val;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool Empty(p_Priority_Queue queue)&#123;</span><br><span class="line">    if (0 == queue -&gt; contentLength) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void travelPriorityQueue(p_Priority_Queue queue)&#123;</span><br><span class="line">    if (Empty(queue)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int position = 0;</span><br><span class="line">    while (position &lt; queue -&gt; contentLength) &#123;</span><br><span class="line">        printf(&quot;member --- %d with %d ---- priority\n&quot;,(queue -&gt; nodeList + position) -&gt; member , (queue -&gt; nodeList + position) -&gt; priority );</span><br><span class="line">        position++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入队后调整</span><br><span class="line">void adjustAfterInsert(p_Priority_Queue queue)&#123;</span><br><span class="line">    int insertPosition = queue -&gt; contentLength - 1;</span><br><span class="line">    while (insertPosition) &#123;</span><br><span class="line">        int swapPosition = insertPosition / 2;</span><br><span class="line">        p_Priority_Node swapNode = &amp;(queue -&gt; nodeList)[swapPosition];</span><br><span class="line">        p_Priority_Node insertNode = &amp;(queue -&gt; nodeList)[insertPosition];</span><br><span class="line">        if (swapNode -&gt; priority &lt; insertNode -&gt; priority) &#123;</span><br><span class="line">            swap(swapNode, insertNode);</span><br><span class="line">            insertPosition = swapPosition;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 出队后调整</span><br><span class="line">void adjustAfterRemove(p_Priority_Queue queue)&#123;</span><br><span class="line">    int parent = 1;</span><br><span class="line">    while (parent * 2 &lt;= queue -&gt; contentLength) &#123;</span><br><span class="line">        int left = parent * 2;</span><br><span class="line">        int right = (parent * 2 + 1);</span><br><span class="line">        if (right &gt; queue -&gt; contentLength) &#123;</span><br><span class="line">            right = queue -&gt; contentLength;</span><br><span class="line">        &#125;</span><br><span class="line">        p_Priority_Node parentNode = &amp;(queue -&gt; nodeList)[parent - 1];</span><br><span class="line">        p_Priority_Node leftNode = &amp;(queue -&gt; nodeList)[left -1];</span><br><span class="line">        p_Priority_Node rightNode = &amp;(queue -&gt; nodeList)[right -1];</span><br><span class="line">        p_Priority_Node swapNode;</span><br><span class="line">        if (leftNode -&gt; priority &gt;= rightNode -&gt; priority) &#123;</span><br><span class="line">            parent = left;</span><br><span class="line">            swapNode = leftNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            parent = right;</span><br><span class="line">            swapNode = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (swapNode -&gt; priority &gt;= parentNode -&gt; priority) &#123;</span><br><span class="line">            swap(parentNode, swapNode);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(p_Priority_Node node1,p_Priority_Node node2)&#123;</span><br><span class="line">    p_Priority_Node tempNode = malloc(sizeof(Priority_Queue_Node));</span><br><span class="line">    </span><br><span class="line">    if (NULL == tempNode) &#123;</span><br><span class="line">        printf(&quot;分配内存失败&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tempNode -&gt; priority = node1 -&gt; priority;</span><br><span class="line">    tempNode -&gt; member = node1 -&gt; member;</span><br><span class="line">    </span><br><span class="line">    node1 -&gt; member = node2 -&gt; member;</span><br><span class="line">    node1 -&gt; priority = node2 -&gt; priority;</span><br><span class="line">    </span><br><span class="line">    node2 -&gt; priority = tempNode -&gt; priority;</span><br><span class="line">    node2 -&gt; member = tempNode -&gt; member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void testPriorityQueue()&#123;</span><br><span class="line">    Priority_Queue queue;</span><br><span class="line">    InitPriorityQueue(&amp;queue, 2);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        int pr = arc4random() % 100;</span><br><span class="line">        int member = arc4random() % 100;</span><br><span class="line">        Insert(&amp;queue, member, pr);</span><br><span class="line">        printf(&quot;================================================\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 20; i ++) &#123;</span><br><span class="line">        RemoveTop(&amp;queue);</span><br><span class="line">        travelPriorityQueue(&amp;queue);</span><br><span class="line">        printf(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>由于堆调整是不稳定的，同优先级元素出队顺序是不定的，这里不允许插入同优先级元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法设计——Priority-Queue实现&quot;&gt;&lt;a href=&quot;#算法设计——Priority-Queue实现&quot; class=&quot;headerlink&quot; title=&quot;算法设计——Priority_Queue实现&quot;&gt;&lt;/a&gt;算法设计——Priority_Queue实现&lt;/h2&gt;&lt;h3 id=&quot;Priority-Queue&quot;&gt;&lt;a href=&quot;#Priority-Queue&quot; class=&quot;headerlink&quot; title=&quot;Priority Queue&quot;&gt;&lt;/a&gt;Priority Queue&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;普通队列是一种先进先出（FIFO）的数据结构。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高优先先出（first in，lagest out）的行为特征。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实现方案&quot;&gt;&lt;a href=&quot;#实现方案&quot; class=&quot;headerlink&quot; title=&quot;实现方案&quot;&gt;&lt;/a&gt;实现方案&lt;/h3&gt;&lt;p&gt;使用排序和数组可以简单的实现Priority Queue，插入到列表的时间复杂度为𝑂（𝑛），排序列表的时间复杂度为𝑂(𝑛log𝑛)。更优的方式是使用大顶堆（小顶堆），以大顶堆（小顶堆）实现的Priority Queue的出队、入队时间复杂度均为𝑂(log 𝑛)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------LowestCommenAncestor</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-LowestCommenAncestor/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-LowestCommenAncestor/</id>
    <published>2019-03-10T05:19:28.000Z</published>
    <updated>2019-03-10T05:20:47.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法设计——Lowest-Commen-Ancestor"><a href="#算法设计——Lowest-Commen-Ancestor" class="headerlink" title="算法设计——Lowest Commen Ancestor"></a>算法设计——Lowest Commen Ancestor</h2><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>给定一个二叉树，找到两个节点NA， NB的最近公共祖先(LCA)。</p><p>方便理解、比如对于下图:</p><p><img src="/2019/03/10/算法设计-LowestCommenAncestor/lca.png" alt=""></p><a id="more"></a><h3 id="Binary-Search-Tree-的LCA"><a href="#Binary-Search-Tree-的LCA" class="headerlink" title="Binary Search Tree 的LCA"></a>Binary Search Tree 的LCA</h3><p>在二叉搜索树中，利用BST属性，我们可以在O（h）时间找到LCA，其中h是树的高度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 查找n1和n2的公共祖先，该函数假定 n1、n2存在于Binary Search Tree上*/</span><br><span class="line">pLCA_Node lca(pLCA_Node root, int n1, int n2)</span><br><span class="line">&#123;</span><br><span class="line">    while (root != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果n1 ,n2都比根小，LCA存在于左子树</span><br><span class="line">        if (root-&gt;member &gt; n1 &amp;&amp; root-&gt;member &gt; n2)</span><br><span class="line">            root = root-&gt;left_Child;</span><br><span class="line">        </span><br><span class="line">        // 如果n1 ,n2都比根小，LCA存在于右子树</span><br><span class="line">        else if (root-&gt;member &lt; n1 &amp;&amp; root-&gt;member &lt; n2)</span><br><span class="line">            root = root-&gt;right_Child;</span><br><span class="line">        </span><br><span class="line">        else break;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通二叉树的LCA"><a href="#普通二叉树的LCA" class="headerlink" title="普通二叉树的LCA"></a>普通二叉树的LCA</h3><p>普通二叉树节点无特殊规律，无法按上述逻辑实现，对于普通二叉树NA、NB的公共祖先可分为以下三种情况（假定NA、NB存在于二叉树）：</p><ul><li>给定键NA或NB与root匹配，则root为LCA</li><li>NA、NB 分别在root的两边，LCA为root</li><li>NA、NB均位于左子树（或右子树），则LCA位于左子树（或右子树）</li></ul><p>通过单次遍历二叉树查找LCA，时间复杂度为O（n）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果mem1 或 mem2 与root 匹配，则根为LCA</span><br><span class="line">    if (root -&gt; member == mem1 || root -&gt; member == mem2) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在左子树、右子树查找最近公共祖先</span><br><span class="line">    pLCA_Node left_lca = findLCA(root -&gt; left_Child, mem1, mem2);</span><br><span class="line">    pLCA_Node right_lca = findLCA(root -&gt; right_Child, mem1, mem2);</span><br><span class="line"></span><br><span class="line">    //mem1、mem2 分别在root的两边，LCA为root</span><br><span class="line">    if (left_lca &amp;&amp; right_lca) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // LCA位于左子树或右子树</span><br><span class="line">    return left_lca ? left_lca : right_lca;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现是建立在NA、NB均存在于二叉树。如果NA、NB中某个值不存在于二叉树会将另一个值作为LCA返回（理想情况下应该返回NSNULL）。我们可以通过传递两个布尔变量v1、v2 来扩展这个这类情况，当树中存在n1时，v1置位true，当树中存在n2时，v2置为true。</p><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><h4 id="h-文件"><a href="#h-文件" class="headerlink" title=".h 文件"></a>.h 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">typedef struct lca_Node&#123;</span><br><span class="line">    struct lca_Node * left_Child;</span><br><span class="line">    struct lca_Node * right_Child;</span><br><span class="line">    int member;</span><br><span class="line">&#125;LCA_Node, * pLCA_Node;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2);</span><br><span class="line">pLCA_Node newLcaNode(int member);</span><br></pre></td></tr></table></figure><h4 id="m-文件"><a href="#m-文件" class="headerlink" title=".m 文件"></a>.m 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;FindLCA.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;stdbool.h&quot;</span><br><span class="line"></span><br><span class="line">pLCA_Node newLcaNode(int member)&#123;</span><br><span class="line">    pLCA_Node temp = malloc(sizeof(LCA_Node));</span><br><span class="line">    temp -&gt; member = member;</span><br><span class="line">    temp -&gt; left_Child = temp -&gt; right_Child = NULL;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCAUtil(pLCA_Node root , int mem1, int mem2, bool * v1, bool * v2)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root -&gt; member == mem1) &#123;</span><br><span class="line">        *v1 = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root -&gt; member == mem2) &#123;</span><br><span class="line">        *v2 = true;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pLCA_Node left_lca = findLCAUtil(root -&gt; left_Child, mem1, mem2, v1, v2);</span><br><span class="line">    pLCA_Node right_lca = findLCAUtil(root -&gt; right_Child, mem1, mem2, v1, v2);</span><br><span class="line">    if (left_lca &amp;&amp; right_lca) &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    return left_lca ? left_lca : right_lca;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool findKey(pLCA_Node root, int key)&#123;</span><br><span class="line">    if (root == NULL) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (root -&gt; member == key || findKey(root -&gt; left_Child, key) || findKey(root -&gt; right_Child, key)) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pLCA_Node findLCA(pLCA_Node root , int mem1, int mem2)&#123;</span><br><span class="line">    </span><br><span class="line">    bool v1 = false, v2 = false;</span><br><span class="line">    </span><br><span class="line">    pLCA_Node lca = findLCAUtil(root, mem1, mem2, &amp;v1, &amp;v2);</span><br><span class="line">    </span><br><span class="line">    if ((v1 &amp;&amp; v2) || (v1 &amp;&amp; findKey(root, mem2)) || (v2 &amp;&amp; findKey(root, mem1))) &#123;</span><br><span class="line">        return lca;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void testFindLCA()&#123;</span><br><span class="line">//  构造一个上图所示的树</span><br><span class="line">    pLCA_Node root = newLcaNode(1);</span><br><span class="line">    root -&gt; left_Child = newLcaNode(2);</span><br><span class="line">    root -&gt; right_Child = newLcaNode(3);</span><br><span class="line">    root -&gt; left_Child -&gt; left_Child = newLcaNode(4);</span><br><span class="line">    root -&gt; left_Child -&gt; right_Child = newLcaNode(5);</span><br><span class="line">    root -&gt; right_Child -&gt; left_Child = newLcaNode(6);</span><br><span class="line">    root -&gt; right_Child -&gt; right_Child = newLcaNode(7);</span><br><span class="line">    </span><br><span class="line">    pLCA_Node lca = findLCA(root, 4, 5);</span><br><span class="line">    </span><br><span class="line">    if (lca) &#123;</span><br><span class="line">        printf(&quot;LCA(4,5)---%d\n&quot;,lca -&gt; member);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Keys are not present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    lca = findLCA(root, 4, 10);</span><br><span class="line">    </span><br><span class="line">    if (lca) &#123;</span><br><span class="line">        printf(&quot;LCA(4,10)---%d\n&quot;,lca -&gt; member);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Keys are not present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LCA(4,5)---2</span><br><span class="line">Keys are not present</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法设计——Lowest-Commen-Ancestor&quot;&gt;&lt;a href=&quot;#算法设计——Lowest-Commen-Ancestor&quot; class=&quot;headerlink&quot; title=&quot;算法设计——Lowest Commen Ancestor&quot;&gt;&lt;/a&gt;算法设计——Lowest Commen Ancestor&lt;/h2&gt;&lt;h3 id=&quot;举个栗子&quot;&gt;&lt;a href=&quot;#举个栗子&quot; class=&quot;headerlink&quot; title=&quot;举个栗子&quot;&gt;&lt;/a&gt;举个栗子&lt;/h3&gt;&lt;p&gt;给定一个二叉树，找到两个节点NA， NB的最近公共祖先(LCA)。&lt;/p&gt;
&lt;p&gt;方便理解、比如对于下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/10/算法设计-LowestCommenAncestor/lca.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------Game of Nim</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Game-of-Nim/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Game-of-Nim/</id>
    <published>2019-03-10T05:18:07.000Z</published>
    <updated>2019-03-10T05:19:07.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="游戏描述"><a href="#游戏描述" class="headerlink" title="游戏描述"></a>游戏描述</h3><p>Nim游戏是对一些放置成堆的一定数量的硬币开始的：硬币和堆的数量取决于你。有两名玩家玩这个游戏，当轮到某位玩家时，他能从某一堆里取任意数量的硬币，但是至少要取一枚硬币，但是也不能从除你取的这个堆以外的其他堆里再取硬币。取得最后一枚硬币的人获胜。</p><a id="more"></a><h3 id="游戏预测"><a href="#游戏预测" class="headerlink" title="游戏预测"></a>游戏预测</h3><blockquote><p>Nim-Sum：对每一堆硬币进行XOR(异或)得到的最终值成为Nim-Sum<br>例如：设HeapA，HeapB，HeapC，每个堆分别有8，12，13个元素<br>则Nim-Sum = 8⊕12⊕13 = 9</p></blockquote><p>对于Nim游戏，假设两个玩家足够聪明（都不会犯错），游戏的结果取决于两个因素：</p><ul><li>硬币堆数及每堆初始化数量（Nim-Sum值）</li><li>游戏从谁开始</li></ul><p>如果游戏开始时Nim-Sum非零，首先开始的玩家将获胜，否则首先开始的玩家输掉游戏。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><ul><li>如果Nim-Sum为零，则无论当前玩家做什么，下一个状态的Nim-Sum都是非0的。</li><li>如果Nim-Sum为非零，则当前玩家可以通过计算移除某一堆的硬币数量，使下一状态的Nim-Sum为0</li><li>游戏结束时，Nim-Sum为0</li><li><a href="https://en.wikipedia.org/wiki/Nim#Proof_of_the_winning_formula" target="_blank" rel="noopener">更详细的证明</a></li></ul><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><p>Nim游戏的结果预测是显而易见的，下面的代码实现了如何完美移动硬币</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 计算Nim-Sum</span><br><span class="line">int calculateNimSum(int piles[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, nimsum = piles[0];</span><br><span class="line">    for (i=1; i&lt;n; i++)</span><br><span class="line">        nimsum = nimsum ^ piles[i];</span><br><span class="line">    return(nimsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动硬币</span><br><span class="line">void makeMove(int piles[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i, nim_sum = calculateNimSum(piles, n);</span><br><span class="line"> </span><br><span class="line">    // 现在轮到的玩家想要获胜，必须确保移动后的Nim-Sum为0</span><br><span class="line">    if (nim_sum != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for (i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            // 如果该移动合法、移动硬币</span><br><span class="line">            if ((piles[i] ^ nim_sum) &lt; piles[i])</span><br><span class="line">            &#123;</span><br><span class="line">            print(&quot;从第%d堆移除%d个硬币\n&quot;,i,piles[i]-(piles[i]^nim_sum));</span><br><span class="line">                piles[i] = (piles[i] ^ nim_sum);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 在对手不犯错误的情况下，现在轮到的玩家将会失败，这里随机移动硬币即可</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        随机移动硬币</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;游戏描述&quot;&gt;&lt;a href=&quot;#游戏描述&quot; class=&quot;headerlink&quot; title=&quot;游戏描述&quot;&gt;&lt;/a&gt;游戏描述&lt;/h3&gt;&lt;p&gt;Nim游戏是对一些放置成堆的一定数量的硬币开始的：硬币和堆的数量取决于你。有两名玩家玩这个游戏，当轮到某位玩家时，他能从某一堆里取任意数量的硬币，但是至少要取一枚硬币，但是也不能从除你取的这个堆以外的其他堆里再取硬币。取得最后一枚硬币的人获胜。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------DynamicPragramingTriTiling</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-DynamicPragramingTriTiling/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-DynamicPragramingTriTiling/</id>
    <published>2019-03-10T05:15:47.000Z</published>
    <updated>2019-03-10T05:17:31.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>用1 x 2的骨牌放满3 x n的矩形有多少种方法 </p><p>例如：下面是铺满3 x 12的一个方法</p><p><img src="/2019/03/10/算法设计-DynamicPragramingTriTiling/Tri_Tiling.png" alt=""></p><a id="more"></a><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>用dp[n]表示放满前n列的方案数</p><ul><li>n为奇数时显然没有合法方案</li><li><p>n为偶数时考虑最右边一个分割线的位置，那么这个位置只可能取n-2,n-4,…,2</p><ul><li>该位置为n-2时，右边两列有三种放法，</li><li>该位置取其他值时，若要保证m列中没有分割线只有两种放法（m=4时如下图）</li></ul><p><img src="/2019/03/10/算法设计-DynamicPragramingTriTiling/Tri_Tiling_4.png" alt=""></p><p>据此可得递推方程：<br>dp[n]=3 x dp[n-2]+2 x (dp[n-4]+dp[n-6]+…+dp[2])<br>同理有dp[n-2]=3 x dp[n-4]+2 x (dp[n-6]+dp[n-8]+…+dp[2])<br>两式做差得dp[n]=4 x dp[n-2]-dp[n-4]，之后以dp[0]=1,dp[2]=3为起点递推即可</p></li></ul><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int tri_Tiling (int n)&#123;</span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n % 2 == 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n == 2) &#123;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 4 * tri_Tiling(n - 2) - tri_Tiling(n - 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>时间复杂度为O(n)</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int tri_Count = tri_Tiling(3);</span><br><span class="line">printf(&quot;tri_Count_3 == %d\n&quot;,tri_Count);</span><br><span class="line">tri_Count = tri_Tiling(8);</span><br><span class="line">printf(&quot;tri_Count_8 == %d\n&quot;,tri_Count);</span><br><span class="line">tri_Count = tri_Tiling(12);</span><br><span class="line">printf(&quot;tri_Count_12 == %d\n&quot;,tri_Count);</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tri_Count_3 == 0</span><br><span class="line">tri_Count_8 == 153</span><br><span class="line">tri_Count_12 == 2131</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.geeksforgeeks.org/tiling-problem/" target="_blank" rel="noopener">Tiling Problem</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;用1 x 2的骨牌放满3 x n的矩形有多少种方法 &lt;/p&gt;
&lt;p&gt;例如：下面是铺满3 x 12的一个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/10/算法设计-DynamicPragramingTriTiling/Tri_Tiling.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------Dynamic Pragraming Longest Common Subsequence</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Dynamic-Pragraming-Longest-Common-Subsequence/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Dynamic-Pragraming-Longest-Common-Subsequence/</id>
    <published>2019-03-10T05:14:46.000Z</published>
    <updated>2019-03-10T05:15:26.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法设计——Dynamic-Pragraming-Longest-Common-Subsequence"><a href="#算法设计——Dynamic-Pragraming-Longest-Common-Subsequence" class="headerlink" title="算法设计——Dynamic Pragraming Longest Common Subsequence"></a>算法设计——Dynamic Pragraming Longest Common Subsequence</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个序列，找出它们中最长的子序列的长度。子序列是以相同的相对顺序出现的序列，但不一定是连续的。例如，“abc”，“abg”，“bdf”，“aeg”，“”acefg“等等是”abcdefg“的子序列。所以一个长度为n的字符串有2 ^ n个不同的子序列。</p><p>例如：<br>“ABCDGH”和 “AEDFHR” 的LCS是“ADH” 长度为3.<br>“AGGTAB”和 “GXTXAYB”的LCS是“GTAB” 长度为4</p><a id="more"></a><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>设Dij为x1…i 和y1…j的LCS的长度。</p><ul><li><p>初始情况：Di0 = D0j = 0;</p></li><li><p>如果 xi = yj,则: Dij = Di−1,j−1 + 1</p></li><li><p>否则，xi 和 yi 都不存在于LCS，所以Dij可表示为:<br>Dij = max{ Di-1,j , Di,j-2 }</p></li></ul><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int lcs(char * x , char * y ,int x_length, int y_length)&#123;</span><br><span class="line">    if (x_length == 0 || y_length == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x[x_length - 1] == y[y_length -1]) &#123;</span><br><span class="line">        return lcs(x, y, x_length - 1, y_length -1) + 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return MAX(lcs(x, y, x_length - 1, y_length), lcs(x, y, x_length, y_length - 1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>递归实现的时间复杂度为2^n ,最坏情况为，当x，y的所有字符均不匹配时。</p><h4 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int lcs(char * x , char * y ,int x_length, int y_length)&#123;</span><br><span class="line">    int lcs_length[x_length + 1][y_length + 1];</span><br><span class="line">    int i , j;</span><br><span class="line">    for (i = 0; i &lt;= x_length; i ++) &#123;</span><br><span class="line">        </span><br><span class="line">        for (j = 0; j &lt;= y_length; j ++) &#123;</span><br><span class="line">            if (i == 0 || j == 0) &#123;</span><br><span class="line">                lcs_length[i][j] = 0;</span><br><span class="line">            &#125;else if (x[i - 1] == y[j - 1]) &#123;</span><br><span class="line">                lcs_length[i][j] = lcs_length[i - 1][j - 1] + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                lcs_length[i][j] = MAX(lcs_length[i][j - 1], lcs_length[i - 1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lcs_length[x_length][y_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>时间复杂度为 m * n;</p><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char * x = &quot;AGGTAB&quot;;</span><br><span class="line">char * y = &quot;GXTXAYB&quot;;</span><br><span class="line">int lcs_length = lcs(x, y, 6, 7);</span><br><span class="line">printf(&quot;lcs_length == %d\n&quot;,lcs_length);</span><br></pre></td></tr></table></figure><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lcs_length == 4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法设计——Dynamic-Pragraming-Longest-Common-Subsequence&quot;&gt;&lt;a href=&quot;#算法设计——Dynamic-Pragraming-Longest-Common-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;算法设计——Dynamic Pragraming Longest Common Subsequence&quot;&gt;&lt;/a&gt;算法设计——Dynamic Pragraming Longest Common Subsequence&lt;/h2&gt;&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;给定两个序列，找出它们中最长的子序列的长度。子序列是以相同的相对顺序出现的序列，但不一定是连续的。例如，“abc”，“abg”，“bdf”，“aeg”，“”acefg“等等是”abcdefg“的子序列。所以一个长度为n的字符串有2 ^ n个不同的子序列。&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;“ABCDGH”和 “AEDFHR” 的LCS是“ADH” 长度为3.&lt;br&gt;“AGGTAB”和 “GXTXAYB”的LCS是“GTAB” 长度为4&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法设计------Dynamic Pragraming 1-dimensional</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-Dynamic-Pragraming-1-dimensional/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-Dynamic-Pragraming-1-dimensional/</id>
    <published>2019-03-10T05:13:30.000Z</published>
    <updated>2019-03-10T05:14:21.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><blockquote><p>问题：给定n，求 将n 表达为1，3，4的和的写法数量</p></blockquote><blockquote><p>例如 n = 5 , 答案是：6</p></blockquote><blockquote><p>5 = 1 + 1 + 1 + 1 + 1</p></blockquote><blockquote><p>5 = 1 + 1 + 3 </p></blockquote><blockquote><p>5 = 1 + 3 + 1</p></blockquote><blockquote><p>5 = 3 + 1 + 1</p></blockquote><blockquote><p>5 = 1 + 4 </p></blockquote><blockquote><p>5 = 4 + 1</p></blockquote><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>以Dn表示，将n表达为1，3，4的和的数量。</p><p>假定n = x1 + x2 + · · · + xm</p><p>如果xm = 1,其他项的总和为n-1</p><p>则，以xm = 1结尾的和的数目等于 Dn-1</p><p>以此类推的xm = 3 , xm = 4 分别为 Dn-3,Dn-4</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>从上述分析中可得到公式</p><ul><li>D0 = 1;</li><li>Dn = Dn−1 + Dn−3 + Dn−4;</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int count (int * arr, int m , int n)&#123;</span><br><span class="line">    </span><br><span class="line">    if (n == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (n &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int counts = 0;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; m; i ++) &#123;</span><br><span class="line">        counts += count(arr, m , n - arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return counts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int array[] = &#123;1,3,4&#125;;</span><br><span class="line">int count_5 = count(array, 3, 5);</span><br><span class="line">printf(&quot;count_5 == %d&quot;,count_5);</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count_5 == 6</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>以下链接给出了在不关心元素位置时该问题的解</p><p><a href="https://www.geeksforgeeks.org/coin-change-dp-7/" target="_blank" rel="noopener">Dynamic Programming | Set 7 (Coin Change)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;举个栗子&quot;&gt;&lt;a href=&quot;#举个栗子&quot; class=&quot;headerlink&quot; title=&quot;举个栗子&quot;&gt;&lt;/a&gt;举个栗子&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;问题：给定n，求 将n 表达为1，3，4的和的写法数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;例如 n = 5 , 答案是：6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 1 + 1 + 1 + 1 + 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 1 + 1 + 3 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 1 + 3 + 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 3 + 1 + 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 1 + 4 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;5 = 4 + 1&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法设计------BinaryIndexedTree</title>
    <link href="http://yoursite.com/2019/03/10/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-BinaryIndexedTree/"/>
    <id>http://yoursite.com/2019/03/10/算法设计-BinaryIndexedTree/</id>
    <published>2019-03-10T05:10:08.000Z</published>
    <updated>2019-03-10T05:11:34.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>为了方便理解Binary Indexed Tree,考虑以下问题：</p><blockquote><p>对于数组 arr[1…n]，执行以下两种操作:</p></blockquote><blockquote><ul><li>getSum()操作：计算前i个元素的和。</li><li>update()操作：改变第i个元素的值，arr[i] = x (1 &lt;= i &lt;= n)。</li></ul></blockquote><a id="more"></a><h3 id="两个简单的解决方案"><a href="#两个简单的解决方案" class="headerlink" title="两个简单的解决方案"></a>两个简单的解决方案</h3><p>方案一： 通过遍历数组计算前i个元素的和O( n )的时间复杂度。更新元素直接赋值O( 1 )的时间复杂度。</p><p>方案二：创建另一个数组，并在这个数组的第i个索引存储从开始到结束的总和。可以在O（1）时间内计算给定范围的总和，但是更新操作需要O（n）个时间。</p><p>两种方案在需操作数组量很大的情况下，都不是很理想，有什么方案能让两种操作都在O（log n）的时间复杂度内完成呢？。</p><h3 id="Binary-Indexed-Tree（树状数组）"><a href="#Binary-Indexed-Tree（树状数组）" class="headerlink" title="Binary Indexed Tree（树状数组）"></a>Binary Indexed Tree（树状数组）</h3><p>Binary Indexed Tree 基于“所有的正整数都可以表示为2的幂的和”这样的事实（例如，5可以表示为4 + 1），巧妙的将数组进行分割。为上述问题提供了两种操作时间复杂度都控制在O(Log n )的方案。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>Binary Indexed Tree 以数组的形式表示（所以又叫树状数组），记为BITree[]。BITree[]中的元素个数与初始数组arr[]一致。 BITree[]中每个元素存储arr[]的某些元素的总和。</p><p><img src="/2019/03/10/算法设计-BinaryIndexedTree/Binary_Index_Tree.png" alt=""></p><h4 id="getSum-amp-update-实现分析"><a href="#getSum-amp-update-实现分析" class="headerlink" title="getSum() &amp; update() 实现分析"></a>getSum() &amp; update() 实现分析</h4><p>为方便讨论假定数组下标从1开始， 为更清晰的看到规律，我们以二进制的形式表示数组下标。</p><h4 id="getSum-分析"><a href="#getSum-分析" class="headerlink" title="getSum()分析"></a>getSum()分析</h4><p>分析以下求和操作：</p><p>求和getSum（4）： getSum( 0100 ) = BITree [ 0100 ] . </p><p>求和getSum（5）：getSum( 0101 ) = BITree [ 0101 ] + BITree [ 0100 ]。</p><p>求和getSum（7）：getSum( 0111 ) = BITree [ 0111 ] + BITree [ 0110 ] + BITree [ 0100 ] 。 </p><p>求和getSum（11）：getSum( 1011 ) = BITree [ 1011 ] + BITree [ 1010 ] + BITree [ 1000 ] 。</p><p>可以看到getSum(i) 的结果可以通过x个BITree元素求和获得，且遵循以下规律：</p><ul><li>x等于 i二进制表示下位值为1的数量。</li><li>待求和BITree元素下标可通过迭代i = i - (i &amp; (-i))获得，即从右往左将所有为1的二进制位置为0。（i &amp; (-i) 返回 i 的二进制数最低位为１的权值）。</li></ul><h4 id="update-分析"><a href="#update-分析" class="headerlink" title="update()分析"></a>update()分析</h4><p>update（1）: update（0001）——&gt; update (0010) ——&gt;update(0100)——&gt;update(1000)</p><p>update（3）: update（0011）——&gt; update (0010) ——&gt;update(0100)——&gt;update(1000)</p><p>update（5）: update（0101）——&gt; update (0110) ——&gt;update(1000)</p><p>当我们更新第i个元素，直接受影响的下标可通过将i 加上i的最位为1的权值获得，受影响的元素下标可通过迭代i = i + (i &amp; (-i))获得。</p><h3 id="Binary-Indexed-Tree-可视化演示"><a href="#Binary-Indexed-Tree-可视化演示" class="headerlink" title="Binary Indexed Tree 可视化演示"></a>Binary Indexed Tree 可视化演示</h3><p><a href="https://visualgo.net/zh/fenwicktree?slide=1" target="_blank" rel="noopener">可视化演示</a></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="h-文件"><a href="#h-文件" class="headerlink" title=".h 文件"></a>.h 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int getSum(int BITree[], int index);//求和</span><br><span class="line">void updateBIT(int BITree[], int n, int index, int val);//更新BITree的第n个节点</span><br><span class="line">int *constructBITree(int arr[], int n);//构建BITree</span><br><span class="line"></span><br><span class="line">#endif /* BITree_h */</span><br></pre></td></tr></table></figure><h4 id="c文件"><a href="#c文件" class="headerlink" title=".c文件"></a>.c文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;BITree.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line"></span><br><span class="line">int getSum(int BITree[], int index)</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    </span><br><span class="line">    //迭代求和</span><br><span class="line">    while (index&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += BITree[index];</span><br><span class="line">        index -= index &amp; (-index);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateBIT(int BITree[], int n, int index, int val)</span><br><span class="line">&#123;</span><br><span class="line">    // 迭代更新所有相关元素</span><br><span class="line">    while (index &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        BITree[index] += val;</span><br><span class="line">        index += index &amp; (-index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int *constructBITree(int arr[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int * BITree = malloc(sizeof(int) * (n));</span><br><span class="line">    for (int i=0 ; i&lt;n; i++)</span><br><span class="line">        BITree[i] = 0;</span><br><span class="line">    </span><br><span class="line">    // 更新BITree，从1开始为有效数据</span><br><span class="line">    for (int i=1; i&lt; n; i++)</span><br><span class="line">        updateBIT(BITree, n, i, arr[i]);</span><br><span class="line">    </span><br><span class="line">    return BITree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void testBITree()&#123;</span><br><span class="line">    //第0 个元素为无效元素</span><br><span class="line">    int freq[] = &#123;0,2, 1, 5, 7, 9, 5, 8, 9, 4, 2, 9&#125;;</span><br><span class="line">    int n = sizeof(freq)/sizeof(freq[0]);</span><br><span class="line">    int *BITree = constructBITree(freq, n);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Sum of elements in arr[1..5] is %d\n&quot;,getSum(BITree, 11));</span><br><span class="line"></span><br><span class="line">    // 更新操作</span><br><span class="line">    freq[3] += 6;</span><br><span class="line">    updateBIT(BITree, n, 3, 6); //更新</span><br><span class="line">    printf(&quot;After update Sum of elements in arr[1..5] is %d\n&quot;,getSum(BITree, 11));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sum of elements in arr[1..5] is 61</span><br><span class="line">After update Sum of elements in arr[1..5] is 67</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/" target="_blank" rel="noopener">Binary Indexed Tree or Fenwick Tree</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;举个栗子&quot;&gt;&lt;a href=&quot;#举个栗子&quot; class=&quot;headerlink&quot; title=&quot;举个栗子&quot;&gt;&lt;/a&gt;举个栗子&lt;/h3&gt;&lt;p&gt;为了方便理解Binary Indexed Tree,考虑以下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于数组 arr[1…n]，执行以下两种操作:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;getSum()操作：计算前i个元素的和。&lt;/li&gt;
&lt;li&gt;update()操作：改变第i个元素的值，arr[i] = x (1 &amp;lt;= i &amp;lt;= n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法设计" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
